
{{tag>matériel portable hp}}

----

====== Lecteur d'empreintes Validity™ & Swipe™ chipset VFS 0050 ======

Cette page propose un didacticiel de [[:compilation]] du pilote puis de l'application hôte pour pouvoir utiliser le lecteur d'empreinte digitale de la marque **Validity™ Sensors  & Swipe™ Fingerprint Sensor** dont le chipset est **VFS 0050 **.

Pour savoir si vous êtes concernés par la procédure, depuis un [[:terminal]] saisissez  la [[:commande_shell|commande]] suivante

<code bash>
lsusb
</code>

Si vous obtenez une ligne du type:
<file>
Bus 001 Device 002: ID 138a:0050 Validity™ Sensors & Swipe™ chipset VFS 0050
</file> 

c'est que vous êtes concerné et pouvez télécharger le fichier-source disponible au chapitre **[[#Code source du fichier « validity.c »]]**

<note warning>**Il existe d'autres puces de ce type, mais le code source n'a pas été testé pour d'autres composants.**

Par exemple : \\ **(en)**[[http://thinkpadmint.blogspot.fr/2014/02/getting-t440s-validity-vfs5011.html |Procédure d'installation du pilote]] pour le lecteur d'empreintes **VFS5011** de Validity™ & Swipe™ référence de chipset ID: 138a:0017 présent dans les **(fr)**[[https://www3.lenovo.com/be/fr/laptops/thinkpad/t-series/T440s/p/22TP2TT440S|ordinateurs de la série Lenovo Thinkpad T440s]].
</note>


Vous trouverez [[#liste des ordinateurs compatibles|une liste non exhaustive des ordinateurs concernés]] en suivant le lien.
===== Pré-requis =====
  * Savoir utiliser un [[:terminal]]
  * Avoir installé [[:Geany]]
  * disposer de **[[:debfoster]]**
  * disposer du jeu de bibliothèques de [[:compilation]] qui n'est pas installé par défaut sur Ubuntu. 
    * **[[apt>build-essential]]**
    * **[[apt>fakeroot]]**
    * **[[apt>checkinstall]]**: surveille la procédure d'installation et crée un paquet « .deb » qui sera présent dans votre liste de paquets installés.\\  Ceci aura pour avantage de vous permettre une désinstallation simplifiée et propre, si vous souhaitez désinstaller ultérieurement vos logiciels et bibliothèques.
<note important>Il est possible que le paquet **checkinstall** possède des dépendances non satisfaites par défaut et non documentées \\ Veuillez alors installer les bibliothèques manquantes en utilisant votre moteur de recherche habituel sur les messages d'erreur de bibliothèques manquantes.</note>

  * [[:gcc|Gcc++ : Le compilateur GNU C++]] avec, entre-autres la bibliothèque « **''libglib3.0-dev''** ».

==== Installation des dépendances du paquet-source libfprint-master ====
  * Récupérer les sources sur le site github : **(en)** [[https://github.com/payden/libfprint|Mirroir GIT des fichiers de compilation et d'installation du pilote VFS0050]]
  * dans les //Documents// de votre //Dossier Personnel//, créer un dossier //compilation//<code bash>
cd ~/Documents
mkdir compilation
cd compilation
</code>
  * [[:archivage#graphiquement|extraire]] l'archive dans le dossier dossier //compilation// fraichement créé. Vous obtenez un dossier //libfprint-master//.
  * Enregistrez-y le fichier-source **validity.c** disponible à [[#Code source du fichier « validity.c »|la fin de cette page]]
  * Taper dans un [[:terminal|Terminal]] : <code bash>
sudo debfoster libxv-dev libnss3*
</code>
<note important>**Cette commande** __**installe les bibliothèques de développement de la documentation [[:xorg|X11]]**__, ainsi que __**toutes les bibliothèques de cryptographie nss version 3 ([paramètre : *])**__.</note>

<note help>
  * Le paquet debfoster est présent dans les dépôts ; \\ 
  * Bien que debfoster soit basé sur la routine apt-get install, les routines internes du paquet sont plus performantes. 
  * le choix de son utilisation force l'installation des dépendances de manière plus complète et plus concise que le paramètre --fix-missing de apt-get.

__**La bonne habitude de son utilisation facilite grandement l'installation de paquets en lignes de commandes et évite les erreurs de typographie !**__

Pour de plus amples informations sur son utilisation, [[debfoster|debfoster dans la documentation]].</note>

===== Compilation graphique avec Geany =====

==== Précompilation : création du fichier-objet "validity.o" ====

Avec **[[:Geany]]** ouvrez le fichier //validity.c// et cliquez dans le menu **[Construire]**-**[Compile]**. Vous obtenez ainsi votre fichier **validity.o** compilé.
<note>Le dossier choisi //~/Documents/compilation/libfprint-master// pour la compilation contient donc le fichier source **validity.c** et son fichier résultant -- le pilote  (**validity.o**) -- sous sa forme compilée.</note>

FIXME Méthode de Compilation en CLI???

===== Compilation et intégration dans le fichier ƒprint =====
  * depuis un [[:terminal]], saisissez les [[:commande_shell|commandes]] suivantes
<code bash Routine de compilation de fprint>
sudo su
cp ~/Documents/compilation/libfprint-master/validity.* /libfprint/drivers/    # copie les nouveaux fichiers validity dans le dossier drivers
test -f configure || sh autogen.sh                                            # Teste votre configuration et avertit des dépendances non satisfaites ; par exemple : « bibliothèque (fichiers *-dev ) ” nss ” manquante » ;
./configure  
make -j4                 # commande de compilation utilisant un processeur Quadcore ; IMPORTANT : Ne pas oublier d'installer les bibliothèques de développement (libglib3.0-dev,… )) ;
sudo checkinstall        # checkinstall permet de créer un paquet Debian à partir de vos sources ! ;
depmod                   # permet de lier les bibliothèques ;
</code>
<note important>
Toute bibliothèque de développement manquante est notée entre guillemets " " dans les messages d'erreur de compilation. Utilisez dans ce cas votre moteur de recherche habituel pour savoir quel paquet installer si ce n'est pas précisé dans l'erreur de compilation.
</note>

==== Procédure de checkinstall ====

<note>Afin d'installer convenablement checkinstall et/ou de résoudre les problèmes de dépendances, ou pour toute autre question, vous pouvez consulter [[checkinstall|checkinstall dans cette documentation]].</note>

Dès lors que toutes les dépendances((les bibliothèques de développement *-dev)) sont satisfaites, le Terminal détaille :
  * la procédure de vérification de votre configuration (listages des bibliothèques installées) puis il passe à :
  * la compilation des sources, puis affiche :
  * le menu de création du paquet Debian qui sera intégré à votre bibliothèque de paquets installés (visible — par exemple — à l'aide du [[:synaptic|gestionnaire de paquets Synaptic]]).

<code>

checkinstall 1.6.2, Copyright 2009 Felipe Eduardo Sanchez Diaz Duran

This software is released under the GNU GPL.

 ==================================== 
 ==== Debian package creation selected ==== 
 ==================================== 

This package will be built according to these values:

0 -  Maintainer: [ root@roccat ] 
1 -  Summary: [ validity ] 
2 -  Name:    [ libfprint ] 
3 -  Version: [ master ] 
4 -  Release: [ 1 ] 
5 -  License: [ GPL ] 
6 -  Group:   [ checkinstall ] 
7 -  Architecture: [ amd64 ] 
8 -  Source location: [ libfprint-master ] 
9 -  Alternate source location: [  ] 
10 - Requires: [  ] 
11 - Provides: [ libfprint ] 
12 - Conflicts: [  ] 
13 - Replaces: [  ] 

Enter a number to change any of them or press ENTER to continue:
</code>

  * Taper ☛ ''**1**'' (option "Résumé [des fonctions du paquet]") puis valider ;
  * Taper ☛ ''**Fprint incluant le lecteur d'empreintes Validity VFS 0050**'' puis valider ;
<note tip>
Faîtes un copier-coller ☛ (< Ctrl >+< C > puis < Ctrl >+< V >) de la ligne ci-dessus dans votre [[:terminal|Terminal]], afin d'éviter les fautes de frappe.
</note>
<note important>le champs "Version" est un champs numérique ; le mot **master** provoque donc une erreur de compilation.</note>

  * Taper ☛ ''**3**'' (option "Version") puis valider ;
  * Taper ☛ ''**1.50**'' puis valider ;
  * Taper ☛ ''**10**'' (option "[bibliothèques] nécessaires") puis valider ;
  * Taper ☛ ''**libxv-dev,libnss3**''

<note tip>
Faîtes un copier-coller ☛ (< Ctrl >+< C > puis < Ctrl >+< V >) de la ligne ci-dessus dans votre [[:terminal|Terminal]], afin d'éviter les fautes de frappe.
</note>


==== Code source du fichier « validity.c » ====

<note help>Il a été pris le parti d'intégrer ici le code plutôt que de proposer de télécharger le [[https://gist.github.com/payden/8191565|code source depuis le GitHub]]: 
  * **Le programmeur à l’origine de ce code est décédé fin 2013 **
  * cette traduction permet aux non anglophones de le comprendre, et qui sait, aux plus expérimentés de le modifier pour le meilleur FIXME comme le pire.
</note>
Code source du fichier « **validity.c** » du lecteur d'empreintes Validity Sensors**138a:0050** 
<note tip>Cliquer sur son nom : **validity.c** ci-dessous pour télécharger le fichier.</note>

<file c++ validity.c>

/*
Gna, gna, gna...
Ne soyez pas trop sévère envers moi ;
Ce code ne produit qu'un protocole de tests.
./gcc test.c -o test -lusb-1.0
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <libusb-1.0/libusb.h>

typedef struct _line {
  unsigned char _0x01;
  unsigned char _0xfe;
  unsigned char _low;
  unsigned char _high;
  unsigned char _0x08; // toujours
  unsigned char _0xb8; // inconnu au bataillon...
  unsigned char _0x00;
  unsigned char _counter; // ... celui-là aussi
  unsigned char row[140]; // donnée nuance de gris
} line_t;

void async_recv_cb(struct libusb_transfer *transfer)
{
  if (transfer->status == LIBUSB_TRANSFER_COMPLETED) {
    fprintf(stderr, "Transfer completed. Transfer terminé.\n");
    fprintf(stderr, "Data received: Réception de données : %d\n", transfer->actual_length);
  } else {
    fprintf(stderr, "transfer failed?: y a-t-il eu un problème de transfer ? : %d\n", transfer->status);
  }
}

int main(int argc, char **argv) {
  libusb_context *ctx;
  libusb_device **list;
  libusb_device *dev = NULL;
  libusb_init(&ctx);
  ssize_t cnt = libusb_get_device_list(NULL, &list);
  ssize_t i = 0;
  int err = 0;
  if (cnt < 0) {
    fprintf(stderr, "Error Erreur\n");
    exit(0);
  }
  for (i = 0; i < cnt; i++) {
    libusb_device *device = list[i];
    struct libusb_device_descriptor desc;
    if (!libusb_get_device_descriptor(device, &desc)) {
      if (desc.idVendor == 0x138a && desc.idProduct == 0x0050) {
        dev = device;
        break;
      }
    }

  }
  if (dev) {
    fprintf(stderr, "Found interesting device.. Un périphérique très intéressant a été détecté...\n");
    libusb_device_handle *handle;
    err = libusb_open(dev, &handle);
    if (libusb_reset_device(handle)) {
      fprintf(stderr, "Failed resetting device.\n");
    }
    err = libusb_claim_interface(handle, 0);
    libusb_claim_interface(handle, 1);
    libusb_claim_interface(handle, 129);
    libusb_claim_interface(handle, 130);
    libusb_claim_interface(handle, 131);
    //CLEAR_FEATURE inteface 0 DEVICE REMOTE WAKEUP
    //SET CONFIGURATION 0x09, config value: 0x0001, interface/wIndex 0
    err = libusb_control_transfer(handle, 0x00, 0x09, 0x0001, 0, NULL, 0, 1000);
    //endpoint 2, clear feature, interface 1 ; balise de fin 1 , nettoyage, interface 1
    char *data = (char *)malloc(2048);

    *data = 0x1a;
    libusb_bulk_transfer(handle, 1, data, 1, &err, 1000);
    libusb_bulk_transfer(handle, 0x81, data, 64, &err, 1000);
    //initiate async BULK IN
    struct libusb_transfer *t = libusb_alloc_transfer(0);
    libusb_fill_bulk_transfer(t, handle, 0x81, data, 64, async_recv_cb, (void *) 1, 10000);
    libusb_submit_transfer(t);
    char init_data[] = {0x36, 0x38, 0x2b, 0x5c, 0x70, 0xac, 0x73, 0x69,
                        0x12, 0xc9, 0xe0, 0xbc, 0xfa, 0x88, 0x10, 0xc7,
                        0x98, 0xbf, 0x52, 0xe3, 0xd5, 0xbc, 0x99, 0x9f,
                        0x73, 0x48, 0x06, 0xba, 0xe0, 0x11, 0x0e, 0x87,
                        0x87, 0xb5, 0x18, 0x95, 0x63, 0x98, 0xae, 0x00,
                        0xc2, 0x67, 0xd5, 0x05, 0x5d, 0x66, 0xd6, 0xb3,
                        0x3f, 0xb7, 0xa7, 0xa0, 0x61, 0x5b, 0x1d, 0xa0,
                        0x36, 0xc6, 0xe1, 0x78, 0x0d, 0x86, 0x72, 0x84, //end block 1 ; fin de bloc de données 1
                        0xd2, 0xf3, 0xd9, 0xb9, 0x78, 0xd8, 0xde, 0xad,
                        0x7a, 0x45, 0x3c, 0x96, 0x08, 0x2d, 0xc6, 0xae,
                        0xc3, 0x3d, 0x8c, 0x6e, 0x5a, 0xfd, 0x91, 0x90,
                        0x0d, 0x78, 0x98, 0xf1, 0x28, 0x67, 0x15, 0x80,
                        0xea, 0x7b, 0xa9, 0xbd, 0xe0, 0x4b, 0x54, 0x8f,
                        0x91, 0xea, 0x2a, 0x99, 0x38, 0xaf, 0x52, 0x11,
                        0xc8, 0x34, 0x17, 0x42, 0xb8, 0xea, 0xd3, 0x8e,
                        0xbc, 0x6a, 0xaa, 0x54, 0x3e, 0x77, 0x44, 0xd6, //end block 2 ; fin du bloc de données 2
                        0x4a, 0x46, 0x04, 0xa5, 0x33, 0xe1, 0x86, 0xfd,
                        0xed, 0x80, 0xa8, 0x12, 0x3a, 0xc2, 0x29, 0x3e,
                        0xce, 0x9e, 0x00, 0xe7, 0xb3, 0xb5, 0x11, 0x2b,
                        0x50, 0x6c, 0x2c, 0x5e, 0x33, 0x17, 0xf5, 0x8b,
                        0xc4, 0x0f, 0x25, 0x65, 0x87, 0x0d, 0x88, 0x3c,
                        0x30, 0xad, 0x9b, 0x40, 0x8a, 0x6c, 0x60, 0xc9,
                        0xf4, 0x03, 0xc1, 0x0f, 0x0e, 0x08, 0xa1, 0x81,
                        0x5e, 0x6a, 0x79, 0x3f, 0x7a, 0xf6, 0x18, 0x7e, //end block 3 ; fin du bloc de données 3
                        0x30, 0x98, 0xf1, 0x25, 0xcb, 0xbd, 0xb9, 0xae,
                        0x5b, 0xeb, 0xa7, 0xea, 0x7c, 0xb6, 0x6f, 0x06,
                        0x0f, 0xaa, 0xe5, 0xd6, 0xe3, 0x46, 0x83, 0xa3,
                        0xe1, 0x66, 0x38, 0x70, 0xb0, 0x5c, 0x3e, 0xe3,
                        0xe0, 0x50, 0x25, 0x60, 0x98, 0x08, 0xa8, 0x86,
                        0xc9, 0xdc, 0xbc, 0xaf, 0x02, 0x54, 0xfc, 0xad,
                        0x8d, 0x9f, 0x87, 0x5a, 0x2f, 0x4a, 0xea, 0x92,
                        0x71, 0x5d, 0x88, 0x64, 0xeb, 0xb0, 0x98, 0x27, //end block 4 ; fin du bloc de données 4
                        0x96, 0xd5, 0x1f, 0x80, 0x44, 0xe3, 0x0f, 0x95,
                        0x95, 0xcb, 0x43, 0xb0, 0xca, 0xbf, 0xac, 0xd9,
                        0x70, 0xe8, 0xc6, 0xf9, 0x4a, 0x94, 0xf7, 0x6c,
                        0x8d, 0x46, 0x97, 0x63, 0x85, 0xb9, 0x85, 0xae,
                        0x3c, 0xe0, 0xa2, 0xad, 0xd7, 0x36, 0x27, 0xcf,
                        0xa1, 0x1f, 0x18, 0x34, 0xf9, 0xff, 0x52, 0xc7,
                        0xae, 0x60, 0x2d, 0xa5, 0x76, 0x79, 0x42, 0xfb,
                        0xa8, 0x52, 0xa8, 0x08, 0x37, 0x79, 0x96, 0x7e, //end block 5 ; fin du bloc de données 5
                        0x33, 0x1d, 0xd0, 0x6f, 0xc6, 0x13, 0x43, 0xdb,
                        0xb0, 0xa9, 0xdd, 0x1c, 0x7a, 0x8a, 0xce, 0xe8,
                        0xb6, 0xf9, 0x23, 0x43, 0x47, 0x1d, 0xd8, 0xbf,
                        0xb3, 0x68, 0x66, 0x55, 0x92, 0xae, 0x7a, 0x76,
                        0x54, 0xcf, 0x2c, 0xfc, 0x11, 0xf1, 0xd2, 0x08,
                        0x27, 0xd9, 0x23, 0x5c, 0x3c, 0x0a, 0xde, 0x7c,
                        0xd9, 0x26, 0x4b, 0x24, 0x5d, 0xc2, 0xbf, 0xe9,
                        0x50, 0x87, 0xda, 0x2d, 0xfd, 0x5e, 0x20, 0x66, //end block 6 ; fin du bloc de données 6
                        0x08, 0x9d, 0xe2, 0xa6, 0xc1, 0xc7, 0x0e, 0x86,
                        0xcb, 0xe0, 0xe7, 0x56, 0x82, 0xf1, 0x7e, 0x7e,
                        0x4a, 0xb3, 0x42, 0x8d, 0x25, 0xec, 0x1e, 0xb1,
                        0x44, 0x17, 0xdf, 0xb3, 0x06, 0xf4, 0x60, 0x3d,
                        0x68, 0x36, 0x45, 0xa5, 0xee, 0x5b, 0xea, 0xc3,
                        0x5d, 0x67, 0x51, 0x14, 0xdc, 0xcc, 0x6b, 0x9d,
                        0xd3, 0x01, 0xdb, 0x99, 0xc7, 0x85, 0x15, 0x68,
                        0xe5, 0x04, 0xe4, 0x12, 0xd4, 0x83, 0x44, 0x7d, //end block 7 ; fin du bloc de données 7
                        0xe8, 0x7c, 0x6c, 0xaa, 0xaa, 0xd2, 0x97, 0x5b,
                        0xae, 0xac, 0x03, 0xac, 0x3c, 0x73, 0xd6, 0x16,
                        0x72, 0x29, 0xc7, 0x2a, 0x57, 0xbc, 0x3e, 0xdc,
                        0x2e, 0xaf, 0xd2, 0x1a, 0x03, 0x76, 0x39, 0x9d,
                        0x3f, 0x66, 0xe5, 0xcc, 0x32, 0x0d, 0xd8, 0x58,
                        0x4b, 0xa4, 0xa2, 0x39, 0xe2, 0xe8, 0xb7, 0x44,
                        0x33, 0xab, 0x7c, 0x49, 0xf6, 0xe4, 0x24, 0xc4,
                        0x7c, 0xa9, 0x07, 0x31, 0x93, 0x16, 0xb4, 0x31, //end block 8 ; fin du bloc de données 8
                        0x38, 0x5d, 0x13, 0x0b, 0x8f, 0x46, 0xa8, 0x77,
                        0xb2, 0x86, 0x15, 0x2c, 0xa7, 0x6a, 0x04, 0xb1,
                        0x4c, 0xdd, 0xc8, 0xe0, 0x26, 0xc5, 0xa3, 0x4d,
                        0x6a, 0x94, 0x57, 0x1f, 0x85, 0x83, 0x8f, 0x05,
                        0xe3, 0xd9, 0x3d, 0x3c, 0x54, 0x96, 0x05, 0xec,
                        0xf8, 0x25, 0xea, 0x84, 0x9f, 0x5d, 0x3f, 0x4a,
                        0xa1, 0x89, 0x86, 0x9f, 0xb7, 0x73, 0x49, 0x6c,
                        0x8e, 0xcf, 0x9c, 0x88, 0xb6, 0xce, 0x18, 0x15, //end block 9 ; fin du bloc de données 9
                        0x93, 0xe0, 0x17, 0x9a, 0x69, 0x57, 0xd1, 0xb6,
                        0x25, 0xf9, 0x62, 0xd2, 0xba, 0x2c, 0xcb, 0xe6,
                        0x5f, 0xe5, 0xb4, 0x18, 0xe8, 0x65, 0x46, 0x7d,
                        0x06, 0x36, 0x85, 0x74, 0xc4, 0x1d, 0x62, 0xf1,
                        0x50, 0x54, 0x9a, 0x02, 0xda, 0x4b, 0x67, 0x70,
                        0xfd, 0x00};
    char init_data2[] = {0x02, 0x94, 0x00, 0x64, 0x00, 0x20, 0x00, 0x08,
                        0x00, 0x2c, 0x03, 0x00, 0x30, 0x1b, 0x00, 0x00,
                        0x00, 0x20, 0x00, 0x08, 0x00, 0x20, 0x03, 0x00,
                        0x30, 0x3d, 0x10, 0x00, 0x00, 0x20, 0x00, 0x08,
                        0x00, 0x18, 0x03, 0x00, 0x30, 0x00, 0x00, 0x00,
                        0x00, 0x20, 0x00, 0x08, 0x00, 0x24, 0x03, 0x00,
                        0x30, 0x08, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08,
                        0x00, 0x28, 0x03, 0x00, 0x30, 0x08, 0x00, 0x00, //end block 1 ; fin du bloc de données 1
                        0x00, 0x20, 0x00, 0x08, 0x00, 0x30, 0x03, 0x00,
                        0x30, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08,
                        0x00, 0x38, 0x03, 0x00, 0x30, 0x00, 0x00, 0x00,
                        0x00, 0x20, 0x00, 0x08, 0x00, 0x3c, 0x03, 0x00,
                        0x30, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08,
                        0x00, 0x44, 0x03, 0x00, 0x30, 0x14, 0x00, 0x00,
                        0x00, 0x20, 0x00, 0x08, 0x00, 0x48, 0x03, 0x00,
                        0x30, 0x01, 0x04, 0x02, 0x00, 0x20, 0x00, 0x08, //end block 2 ; fin du bloc de données 2
                        0x00, 0x4c, 0x03, 0x00, 0x30, 0x01, 0x0c, 0x02,
                        0x00, 0x20, 0x00, 0x08, 0x00, 0x54, 0x03, 0x00,
                        0x30, 0x20, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08,
                        0x00, 0x5c, 0x03, 0x00, 0x30, 0x90, 0x01, 0x02,
                        0x00, 0x20, 0x00, 0x08, 0x00, 0x60, 0x03, 0x00,
                        0x30, 0x2c, 0x01, 0x19, 0x00, 0x20, 0x00, 0x08,
                        0x00, 0x64, 0x03, 0x00, 0x30, 0x00, 0x00, 0x00,
                        0x00, 0x20, 0x00, 0x08, 0x00, 0x6c, 0x03, 0x00, //end block 3 ; fin du bloc de données 3
                        0x30, 0x1e, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08,
                        0x00, 0x70, 0x03, 0x00, 0x30, 0x21, 0x80, 0x00,
                        0x00, 0x20, 0x00, 0x08, 0x00, 0x78, 0x03, 0x00,
                        0x30, 0x09, 0x00, 0x02, 0x00, 0x20, 0x00, 0x08,
                        0x00, 0x7c, 0x03, 0x00, 0x30, 0x0b, 0x00, 0x19,
                        0x00, 0x20, 0x00, 0x08, 0x00, 0x80, 0x03, 0x00,
                        0x30, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08,
                        0x00, 0x84, 0x03, 0x00, 0x30, 0x3a, 0x00, 0x00, //end block 4 ; fin du bloc de données 4
                        0x00, 0x20, 0x00, 0x08, 0x00, 0x88, 0x03, 0x00,
                        0x30, 0x14, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08,
                        0x00, 0x8c, 0x03, 0x00, 0x30, 0x02, 0x00, 0x00,
                        0x00, 0x20, 0x00, 0x08, 0x00, 0x90, 0x03, 0x00,
                        0x30, 0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08,
                        0x00, 0x94, 0x03, 0x00, 0x30, 0x08, 0x00, 0x00,
                        0x00, 0x20, 0x00, 0x08, 0x00, 0x98, 0x03, 0x00,
                        0x30, 0x00, 0x00, 0xa1, 0x01, 0x20, 0x00, 0x08, //end block 5 ; fin du bloc de données 5
                        0x00, 0x9c, 0x03, 0x00, 0x30, 0x00, 0x00, 0xa1,
                        0x01, 0x20, 0x00, 0x08, 0x00, 0xa8, 0x03, 0x00,
                        0x30, 0x64, 0x01, 0x00, 0x00, 0x20, 0x00, 0x08,
                        0x00, 0xac, 0x03, 0x00, 0x30, 0x64, 0x01, 0x00,
                        0x00, 0x20, 0x00, 0x08, 0x00, 0xb0, 0x03, 0x00,
                        0x30, 0x00, 0x01, 0x00, 0x00, 0x20, 0x00, 0x08,
                        0x00, 0xb4, 0x03, 0x00, 0x30, 0x00, 0x01, 0x00,
                        0x00, 0x20, 0x00, 0x08, 0x00, 0xb8, 0x03, 0x00, //end block 6 ; fin du bloc de données 6
                        0x30, 0x05, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08,
                        0x00, 0xbc, 0x03, 0x00, 0x30, 0x05, 0x00, 0x00,
                        0x00, 0x20, 0x00, 0x08, 0x00, 0xc0, 0x03, 0x00,
                        0x30, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08,
                        0x00, 0x84, 0x03, 0x00, 0x30, 0x3b, 0x00, 0x00,
                        0x00, 0x20, 0x00, 0x08, 0x00, 0x08, 0x07, 0x00,
                        0x30, 0x03, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08,
                        0x00, 0x0c, 0x07, 0x00, 0x30, 0x00, 0x00, 0x00, //end block 7 ; fin du bloc de données 7
                        0x00, 0x20, 0x00, 0x08, 0x00, 0x14, 0x07, 0x00,
                        0x30, 0x20, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08,
                        0x00, 0x1c, 0x07, 0x00, 0x30, 0x1a, 0x00, 0x00,
                        0x00, 0x20, 0x00, 0x08, 0x00, 0x70, 0x0d, 0x00,
                        0x30, 0x01, 0x00, 0x00, 0x00, 0x25, 0x00, 0x28,
                        0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                        0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
                        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //end block 8 ; fin du bloc de données 8
                        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                        0x00, 0x02, 0x00, 0x90, 0x00, 0x00, 0x00, 0x2b,
                        0xff, 0x2b, 0xff, 0x2b, 0xed, 0x00, 0x00, 0x2b,
                        0xfb, 0x00, 0x00, 0x2b, 0xc5, 0x00, 0x00, 0x2b,
                        0x05, 0x80, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00,
                        0x00, 0x24, 0xd3, 0x2e, 0xc0, 0x2c, 0x3b, 0x08,
                        0xf0, 0x3b, 0x09, 0x24, 0xbb, 0x3b, 0x0b, 0x24, //end block 9 ; fin du bloc de données 9
                        0xaa, 0x3b, 0x1f, 0xf8, 0x00, 0x3b, 0x3f, 0xf0,
                        0x00, 0x3b, 0x35, 0xc0, 0x00, 0x38, 0x80, 0x2c,
                        0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x38,
                        0x80, 0x2c, 0x70, 0x00, 0x00, 0x00, 0x00, 0xc0,
                        0x3a, 0x80, 0x2c, 0x70, 0x00, 0x00, 0x00, 0x00,
                        0xc0, 0x3b, 0x0a, 0x80, 0x2e, 0x83, 0x24, 0xdb,
                        0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0xc3, 0x2c,
                        0x31, 0x83, 0x2c, 0x70, 0x00, 0x00, 0x00, 0x00, //end block 10 ; fin du bloc de données 10
                        0xcb, 0x33, 0x1b, 0x83, 0x2c, 0x70, 0x00, 0x00,
                        0x00, 0x00, 0xcb, 0x31, 0x83, 0x2c, 0x70, 0x00,
                        0x00, 0x00, 0x00, 0xcb, 0x00, 0x33, 0x1e, 0x83,
                        0x2e, 0x25, 0xff, 0xc4, 0x00, 0x2f, 0x06, 0x84,
                        0x2e, 0x00, 0x00, 0x10, 0x20, 0x29, 0x00, 0x04,
                        0x00, 0x10, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00,
                        0x00, 0x21, 0x00, 0x10, 0x00, 0x48, 0x03, 0x00,
                        0x30, 0xff, 0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, //end block 11 ; fin du bloc de données 11
                        0x00, 0x00, 0x04, 0x00, 0x00, 0x21, 0x00, 0x10,
                        0x00, 0x4c, 0x03, 0x00, 0x30, 0xff, 0xf0, 0xff,
                        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00,
                        0x00, 0x21, 0x00, 0x10, 0x00, 0x20, 0x03, 0x00,
                        0x30, 0x7f, 0x00, 0xfc, 0xff, 0x00, 0x00, 0x00,
                        0x00, 0x80, 0x10, 0x00, 0x00, 0x20, 0x00, 0x08,
                        0x00, 0x24, 0x03, 0x00, 0x30, 0x04, 0x00, 0x00,
                        0x00, 0x20, 0x00, 0x08, 0x00, 0x1c, 0x07, 0x00, //end block 12 ; fin du bloc de données 12
                        0x30, 0x1a, 0x00, 0x00, 0x00, 0x21, 0x00, 0x10,
                        0x00, 0x20, 0x03, 0x00, 0x30, 0xc3, 0xff, 0xff,
                        0xff, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00,
                        0x00, 0x20, 0x00, 0x08, 0x00, 0x80, 0x03, 0x00,
                        0x30, 0x01, 0x00, 0x00, 0x00};
    char *p = init_data;
    char *pend = (char *) init_data + sizeof(init_data);
    while (p < pend) {
      int to_send = pend - p;
      to_send = to_send >= 64 ? 64 : to_send;
      libusb_bulk_transfer(handle, 0x01, p, to_send, &err, 1000);
      p += err; //add sent bytes.
    }
    fprintf(stderr, "Sent init1\n");
    init_data[0] = 0x01;
    libusb_bulk_transfer(handle, 0x01, init_data, 1, &err, 1000);
    fprintf(stderr, "Sent 0x01: %d\n", err);
    libusb_bulk_transfer(handle, 0x81, data, 64, &err, 300);
    fprintf(stderr, "Bulk in endpoint 1: ; Données brutes, balise de fin 1 : %d\n", err);
    p = init_data2;
    pend = (char *) init_data2 + sizeof(init_data2);
    while (p < pend) {
      int to_send = pend - p;
      to_send = to_send >= 64 ? 64 : to_send;
      libusb_bulk_transfer(handle, 0x01, p, to_send, &err, 1000);
      p += err;
    }
    fprintf(stderr, "Sent init2\n");
    do {
      libusb_bulk_transfer(handle, 0x81, data, 64, &err, 300);
      fprintf(stderr, "Received %d\n", err);
    } while(err == 64);
    fprintf(stderr, "Post init2 sent, finished receiving from endpoint 1 ; Post init2 envoyé ; fin de réception des données de la balise de fin 1\n");
    do {
      libusb_bulk_transfer(handle, 0x82, data, 64, &err, 300);
      fprintf(stderr, "BULK endpoint 2 received: ; Balise 2 de fin de données brutes reçue : %d\n", err);
    } while(err == 64);
    fprintf(stderr, "Finished receiving from endpoint 2. Réception de la balise 2 terminée\n");

    //this is post init_data2 sent and received back from endpoint 2.  Need to output 2 chunks and receive 2 bytes 00 00
    //Huzzah!  Something about this data ends up turning the LED on, we got blinky lights baby.
    char init_data3[] = {
      0x39, 0x20, 0xbf, 0x02, 0x00, 0xf4, 0x01, 0x00,
      0x00, 0x01, 0xd1, 0x00, 0x20, 0xd1, 0xd1, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0xf4, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00,
      0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0xf4, 0x01, 0x00,
      0x00, 0x02, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //end chunk 1
      0x00, 0xf4, 0x01, 0x00, 0x00, 0x02, 0xd1, 0x00,
      0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00};

    libusb_bulk_transfer(handle, 0x01, init_data3, 64, &err, 300);
    fprintf(stderr, "Sent init_data3: %d\n", err);
    libusb_bulk_transfer(handle, 0x01, &init_data3[64], 61, &err, 300);
    fprintf(stderr, "Sent init_data3 2: %d\n", err);
    libusb_bulk_transfer(handle, 0x81, init_data3, 64, &err, 300);
    fprintf(stderr, "Read in %d bytes from .1\n", err);
    fprintf(stderr, "Time for final .1 out...\n");
    char init_data4[] = {
      0x02, 0x94, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08,
      0x00, 0x2c, 0x03, 0x00, 0x30, 0x1b, 0x00, 0x00,
      0x00, 0x20, 0x00, 0x08, 0x00, 0x20, 0x03, 0x00,
      0x30, 0x3d, 0x10, 0x00, 0x00, 0x20, 0x00, 0x08,
      0x00, 0x18, 0x03, 0x00, 0x30, 0x00, 0x00, 0x00,
      0x00, 0x20, 0x00, 0x08, 0x00, 0x24, 0x03, 0x00,
      0x30, 0x08, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08,
      0x00, 0x28, 0x03, 0x00, 0x30, 0x08, 0x00, 0x00, //end block 1
      0x00, 0x20, 0x00, 0x08, 0x00, 0x30, 0x03, 0x00,
      0x30, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08,
      0x00, 0x38, 0x03, 0x00, 0x30, 0x00, 0x00, 0x00,
      0x00, 0x20, 0x00, 0x08, 0x00, 0x3c, 0x03, 0x00,
      0x30, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08,
      0x00, 0x44, 0x03, 0x00, 0x30, 0x14, 0x00, 0x00,
      0x00, 0x20, 0x00, 0x08, 0x00, 0x48, 0x03, 0x00,
      0x30, 0x01, 0x04, 0x02, 0x00, 0x20, 0x00, 0x08, //end block 2
      0x00, 0x4c, 0x03, 0x00, 0x30, 0x01, 0x0c, 0x02,
      0x00, 0x20, 0x00, 0x08, 0x00, 0x54, 0x03, 0x00,
      0x30, 0x20, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08,
      0x00, 0x5c, 0x03, 0x00, 0x30, 0x90, 0x01, 0x02,
      0x00, 0x20, 0x00, 0x08, 0x00, 0x60, 0x03, 0x00,
      0x30, 0x2c, 0x01, 0x19, 0x00, 0x20, 0x00, 0x08,
      0x00, 0x64, 0x03, 0x00, 0x30, 0x00, 0x00, 0x00,
      0x00, 0x20, 0x00, 0x08, 0x00, 0x6c, 0x03, 0x00, //end block 3
      0x30, 0x1e, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08,
      0x00, 0x70, 0x03, 0x00, 0x30, 0x21, 0x80, 0x00,
      0x00, 0x20, 0x00, 0x08, 0x00, 0x78, 0x03, 0x00,
      0x30, 0x09, 0x00, 0x02, 0x00, 0x20, 0x00, 0x08,
      0x00, 0x7c, 0x03, 0x00, 0x30, 0x0b, 0x00, 0x19,
      0x00, 0x20, 0x00, 0x08, 0x00, 0x80, 0x03, 0x00,
      0x30, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08,
      0x00, 0x84, 0x03, 0x00, 0x30, 0x3a, 0x00, 0x00, //end block 4
      0x00, 0x20, 0x00, 0x08, 0x00, 0x88, 0x03, 0x00,
      0x30, 0x14, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08,
      0x00, 0x8c, 0x03, 0x00, 0x30, 0x02, 0x00, 0x00,
      0x00, 0x20, 0x00, 0x08, 0x00, 0x90, 0x03, 0x00,
      0x30, 0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08,
      0x00, 0x94, 0x03, 0x00, 0x30, 0x08, 0x00, 0x00,
      0x00, 0x20, 0x00, 0x08, 0x00, 0x98, 0x03, 0x00,
      0x30, 0x00, 0x00, 0xa1, 0x01, 0x20, 0x00, 0x08, //end block 5
      0x00, 0x9c, 0x03, 0x00, 0x30, 0x00, 0x00, 0xa1,
      0x01, 0x20, 0x00, 0x08, 0x00, 0xa8, 0x03, 0x00,
      0x30, 0x64, 0x01, 0x00, 0x00, 0x20, 0x00, 0x08,
      0x00, 0xac, 0x03, 0x00, 0x30, 0x64, 0x01, 0x00,
      0x00, 0x20, 0x00, 0x08, 0x00, 0xb0, 0x03, 0x00,
      0x30, 0x00, 0x01, 0x00, 0x00, 0x20, 0x00, 0x08,
      0x00, 0xb4, 0x03, 0x00, 0x30, 0x00, 0x01, 0x00,
      0x00, 0x20, 0x00, 0x08, 0x00, 0xb8, 0x03, 0x00, //end block 6
      0x30, 0x05, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08,
      0x00, 0xbc, 0x03, 0x00, 0x30, 0x05, 0x00, 0x00,
      0x00, 0x20, 0x00, 0x08, 0x00, 0xc0, 0x03, 0x00,
      0x30, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08,
      0x00, 0x84, 0x03, 0x00, 0x30, 0x3b, 0x00, 0x00,
      0x00, 0x20, 0x00, 0x08, 0x00, 0x08, 0x07, 0x00,
      0x30, 0x03, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08,
      0x00, 0x0c, 0x07, 0x00, 0x30, 0x00, 0x00, 0x00, //end block 7
      0x00, 0x20, 0x00, 0x08, 0x00, 0x14, 0x07, 0x00,
      0x30, 0x20, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08,
      0x00, 0x1c, 0x07, 0x00, 0x30, 0x1a, 0x00, 0x00,
      0x00, 0x20, 0x00, 0x08, 0x00, 0x70, 0x0d, 0x00,
      0x30, 0x01, 0x00, 0x00, 0x00, 0x25, 0x00, 0x28,
      0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //end block 8
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x02, 0x00, 0x90, 0x00, 0x00, 0x00, 0x2b,
      0xff, 0x2b, 0xff, 0x2b, 0xed, 0x00, 0x00, 0x2b,
      0xfb, 0x00, 0x00, 0x2b, 0xc5, 0x00, 0x00, 0x2b,
      0x05, 0x80, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x24, 0xd3, 0x2e, 0xc0, 0x2c, 0x3b, 0x08,
      0xf0, 0x3b, 0x09, 0x24, 0xbb, 0x3b, 0x0b, 0x24, //end block 9
      0xaa, 0x3b, 0x1f, 0xf8, 0x00, 0x3b, 0x3f, 0xf0,
      0x00, 0x3b, 0x35, 0xc0, 0x00, 0x38, 0x80, 0x2c,
      0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x38,
      0x80, 0x2c, 0x70, 0x00, 0x00, 0x00, 0x00, 0xc0,
      0x3a, 0x80, 0x2c, 0x70, 0x00, 0x00, 0x00, 0x00,
      0xc0, 0x3b, 0x0a, 0x80, 0x2e, 0x83, 0x24, 0xdb,
      0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0xc3, 0x2c,
      0x31, 0x83, 0x2c, 0x70, 0x00, 0x00, 0x00, 0x00, //end block 10
      0xcb, 0x33, 0x1b, 0x83, 0x2c, 0x70, 0x00, 0x00,
      0x00, 0x00, 0xcb, 0x31, 0x83, 0x2c, 0x70, 0x00,
      0x00, 0x00, 0x00, 0xcb, 0x00, 0x33, 0x1e, 0x83,
      0x2e, 0x25, 0xff, 0xc4, 0x00, 0x2f, 0x06, 0x84,
      0x2e, 0x00, 0x00, 0x10, 0x20, 0x29, 0x00, 0x04,
      0x00, 0x10, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00,
      0x00, 0x21, 0x00, 0x10, 0x00, 0x48, 0x03, 0x00,
      0x30, 0xff, 0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, //end block 11
      0x00, 0x00, 0x04, 0x00, 0x00, 0x21, 0x00, 0x10,
      0x00, 0x4c, 0x03, 0x00, 0x30, 0xff, 0xf0, 0xff,
      0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00,
      0x00, 0x21, 0x00, 0x10, 0x00, 0x20, 0x03, 0x00,
      0x30, 0x7f, 0x00, 0xfc, 0xff, 0x00, 0x00, 0x00,
      0x00, 0x80, 0x10, 0x00, 0x00, 0x20, 0x00, 0x08,
      0x00, 0x24, 0x03, 0x00, 0x30, 0x04, 0x00, 0x00,
      0x00, 0x20, 0x00, 0x08, 0x00, 0x1c, 0x07, 0x00, //end block 12
      0x30, 0x1a, 0x00, 0x00, 0x00, 0x21, 0x00, 0x10,
      0x00, 0x20, 0x03, 0x00, 0x30, 0xc3, 0xff, 0xff,
      0xff, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00,
      0x00, 0x20, 0x00, 0x08, 0x00, 0x80, 0x03, 0x00,
      0x30, 0x02, 0x00, 0x00, 0x00, 0x24, 0x00, 0x8c,
      0x00, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77,
      0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77,
      0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, //end block 13
      0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77,
      0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77,
      0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77,
      0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77,
      0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77,
      0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77,
      0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77,
      0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, //end block 14
      0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77,
      0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77,
      0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77,
      0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77,
      0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77,
      0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77,
      0x77, 0x77, 0x77, 0x77, 0x77, 0x26, 0x00, 0x28,
      0x00, 0xff, 0x00, 0x0f, 0x00, 0xf0, 0xf0, 0x0f, //end block 15
      0x00, 0x20, 0x00, 0x00, 0x00, 0x30, 0x01, 0x02,
      0x00, 0x2c, 0x01, 0x28, 0x00, 0x20, 0x80, 0x00,
      0x00, 0x0a, 0x00, 0x02, 0x00, 0x0b, 0x00, 0x19,
      0x00, 0x40, 0x1f, 0x10, 0x27, 0x00, 0x0f, 0x03,
      0x00};

      p = init_data4;
      pend = (char *) init_data4 + sizeof(init_data4);
      while (p < pend) {
        int to_send = pend - p;
        to_send = to_send >= 64 ? 64 : to_send;
        libusb_bulk_transfer(handle, 0x01, p, to_send, &err, 100);
        p += err; //add transfered bytes.
      }
      fprintf(stderr, "Sent init_data4\n");

      do {
        libusb_bulk_transfer(handle, 0x81, data, 64, &err, 100);
        fprintf(stderr, "Received on BULK 1: %d\n", err);
      } while(err == 64);

      if (libusb_interrupt_transfer(handle, 0x83, init_data, 8, &err, 0) == 0) {
        fprintf(stderr, "Interrupt success, data: %d\n", err);
        if (err == 5) {
          fprintf(stderr, "Interrupt data: ");
          for (i = 0; i < err; i++) {
            fprintf(stderr, "%02x ", init_data[i] & 0xff);
          }
          fprintf(stderr, "\n");
        }
      }
      fprintf(stderr, "Now waiting for fingerprint interrupt, letting us know we need to read from endpoint 2.\n");
      if (libusb_interrupt_transfer(handle, 0x83, init_data, 8, &err, 0) == 0) {
        fprintf(stderr, "Interrupt success, data 2: %d\n", err);
        if (err == 5) {
          fprintf(stderr, "Interrupt data: ");
          for (i = 0; i < err; i++) {
            fprintf(stderr, "%02x ", init_data[i] & 0xff);
          }
          fprintf(stderr, "\n");
        }
      }

    //this is it man, fingerprint data.
    line_t *lines[10000]; //not sure how many of these i'll need?
    for (i = 0; i < 10000; i++) {
      lines[i] = NULL;
    }

    int cur_line = 0;
    int cur_off = 0;
    do {
      if (lines[cur_line] == NULL) {
        lines[cur_line] = (line_t *)malloc(sizeof(line_t));
        memset(lines[cur_line], 0, sizeof(line_t));
      }
      libusb_bulk_transfer(handle, 0x82, data, 64, &err, 300);
      if (err > sizeof(line_t) - cur_off) {
        memcpy((char *)lines[cur_line] + cur_off, data, sizeof(line_t) - cur_off);
        cur_line++;
        lines[cur_line] = (line_t *) malloc(sizeof(line_t));
        memset(lines[cur_line], 0, sizeof(line_t));
        memcpy(lines[cur_line], data + (sizeof(line_t) - cur_off), err - (sizeof(line_t) - cur_off));
        cur_off = err - (sizeof(line_t) - cur_off);
      } else {
        memcpy((char *)lines[cur_line] + cur_off, data, err);
        cur_off += err;
        if (cur_off == sizeof(line_t)) {
          cur_line++;
          lines[cur_line] = (line_t *) malloc(sizeof(line_t));
          memset(lines[cur_line], 0, sizeof(line_t));
          cur_off = 0;
        }
      }

    } while(err == 64);
    fprintf(stderr, "Received fingerprint data... writing out to file.\n");
    int height = cur_line;
    char fputbuf[256];
    FILE *fp = fopen("test.pgm", "w");
    snprintf(fputbuf, 256, "140 %d\n", height);
    fwrite("P2\n", 3, 1, fp);
    fwrite(fputbuf, strlen(fputbuf), 1, fp);
    fwrite("255\n", 4, 1, fp);
    for (cur_line = 0; cur_line < height; cur_line++) {
      for (i = 0; i < 140; i++) {
        sprintf(fputbuf, "%d\t", lines[cur_line]->row[i]);
        fwrite(fputbuf, strlen(fputbuf), 1, fp);

      }
      fwrite("\n", 1, 1, fp);
    }
    fclose(fp);
    for (i = 0; i < 10000; i++) {
      if (lines[i] != NULL) {
        free(lines[i]);
      }
    }
    free(data);
    libusb_release_interface(handle, 0);
    libusb_release_interface(handle, 1);
    libusb_release_interface(handle, 129);
    libusb_release_interface(handle, 130);
    libusb_release_interface(handle, 131);
    fprintf(stderr, "Closing.\n");
    libusb_close(handle);
  }
  libusb_free_device_list(list, 1);
  libusb_exit(ctx);
  char * const paramList[] = {"/usr/bin/eog", "test.pgm", NULL};
  execv("/usr/bin/eog", paramList);
  return 0;
}

</file>

===== Voir aussi =====
  * **(en)** [[https://gist.github.com/payden/8191565|Le code-source du lecteur d'empreintes 138a:0050]] de Validity™ sensors ; source : GitHub ; Auteur : //Payden// en date de ~ juin 2013.
  * [[:fprint|Le logiciel ƒprint]] dans cette documentation
  * **(en)** [[https://launchpad.net/~fingerprint|"Fingerprint readers integration" team]] sur le Launchpad Ubuntu - liste des lecteurs pris en charge.
  * **(en)** [[https://bbs.archlinux.org/viewtopic.php?id=198971|HP Envy, Validity™ Sensors, libfprint]] - source ArchLinux.org
  * **(en)** [[https://www.youtube.com/watch?v=PKV_ZQGbeMM|Vidéo présentant un essai de rétro-ingénierie du chipset]].
  * **(en)**[[http://thinkpadmint.blogspot.fr/2014/02/getting-t440s-validity-vfs5011.html |Procédure d'installation du pilote]] pour le lecteur d'empreintes **VFS5011** de Validity™ & Swipe™ référence de chipset ID: 138a:0017 présent dans les [[https://www3.lenovo.com/be/fr/laptops/thinkpad/t-series/T440s/p/22TP2TT440S|ordinateurs de la série Lenovo Thinkpad T440s]].


==== Liste des ordinateurs compatibles ====
=== Hewlett Packard™ ====

  * **Envy 15-j104sl**
  * **Envy 15-j141nf**
  * **Envy 17-j020us**
  * **Envy TouchSmart 17-j010dx**
  * **Envy TouchSmart 17-j120dx**
  * **Envy TouchSmart 17-j141nr**
  * **Envy 17-k200nf tactile**
  * La gamme **Notebook 355 G2** (série spécifique inconnue)

----

//Contributeur [[utilisateurs:eagle08|René Stoecklin]]//