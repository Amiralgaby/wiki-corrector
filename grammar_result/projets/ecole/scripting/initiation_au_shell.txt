
6 Mot inconnu : gapz [[44:48]] => Ceci est un compte-rendu du cours donné par gapz et FiFouille sur le canal IRC #ubuntu-fr-classroom le 27 janvier 2007. Ce cours est orienté débutant et a pour but de donner de solides bases. Pour le suivre il suffit de savoir ouvrir un terminal. <|> gapz
6 Mot inconnu : FiFouille [[52:61]] => Ceci est un compte-rendu du cours donné par gapz et FiFouille sur le canal IRC #ubuntu-fr-classroom le 27 janvier 2007. Ce cours est orienté débutant et a pour but de donner de solides bases. Pour le suivre il suffit de savoir ouvrir un terminal. <|> fifouille

17 Mot inconnu : sh [[98:100]] => >Quand on parle du Shell, on fait souvent référence à l'interpréteur de commande, autrefois nommé sh (contraction de shell), et qui a ensuite donné naissance à tout un éventail d'interpréteurs tels que bash, csh, zsh, ksh... qu'il ne faut pas confondre avec un émulateur de terminal comme xterm, eterm, gnome-terminal qui est un outil graphique qui permet d'avoir accès au shell. <|> sh
17 Mot inconnu : csh [[208:211]] => >Quand on parle du Shell, on fait souvent référence à l'interpréteur de commande, autrefois nommé sh (contraction de shell), et qui a ensuite donné naissance à tout un éventail d'interpréteurs tels que bash, csh, zsh, ksh... qu'il ne faut pas confondre avec un émulateur de terminal comme xterm, eterm, gnome-terminal qui est un outil graphique qui permet d'avoir accès au shell. <|> csh
17 Mot inconnu : ksh [[218:221]] => >Quand on parle du Shell, on fait souvent référence à l'interpréteur de commande, autrefois nommé sh (contraction de shell), et qui a ensuite donné naissance à tout un éventail d'interpréteurs tels que bash, csh, zsh, ksh... qu'il ne faut pas confondre avec un émulateur de terminal comme xterm, eterm, gnome-terminal qui est un outil graphique qui permet d'avoir accès au shell. <|> ksh
17 Typographie : points de suspension. Utilisez le caractère dédié. [[221:224]] => >Quand on parle du Shell, on fait souvent référence à l'interpréteur de commande, autrefois nommé sh (contraction de shell), et qui a ensuite donné naissance à tout un éventail d'interpréteurs tels que bash, csh, zsh, ksh... qu'il ne faut pas confondre avec un émulateur de terminal comme xterm, eterm, gnome-terminal qui est un outil graphique qui permet d'avoir accès au shell. <|> ... => suggestions : …
17 Mot inconnu : xterm [[289:294]] => >Quand on parle du Shell, on fait souvent référence à l'interpréteur de commande, autrefois nommé sh (contraction de shell), et qui a ensuite donné naissance à tout un éventail d'interpréteurs tels que bash, csh, zsh, ksh... qu'il ne faut pas confondre avec un émulateur de terminal comme xterm, eterm, gnome-terminal qui est un outil graphique qui permet d'avoir accès au shell. <|> xterm
17 Mot inconnu : eterm [[296:301]] => >Quand on parle du Shell, on fait souvent référence à l'interpréteur de commande, autrefois nommé sh (contraction de shell), et qui a ensuite donné naissance à tout un éventail d'interpréteurs tels que bash, csh, zsh, ksh... qu'il ne faut pas confondre avec un émulateur de terminal comme xterm, eterm, gnome-terminal qui est un outil graphique qui permet d'avoir accès au shell. <|> eterm

19 Mot inconnu : Fx [[91:93]] => En réalité, les vrais terminaux sont accessibles via la combinaison de touche CTRL + ALT + Fx (où x est un chiffre entre 1 et 6) lorsque vous êtes dans un environnement graphique, le 7 correspondant à cette session. Si vous êtes dans un vrai Terminal, il faut théoriquement utiliser ALT + Fx. À noter également qu'un émulateur permet d'afficher une sorte de TTY (TéléTYpe) dans la session graphique. <|> fx
19 Mot inconnu : Fx [[289:291]] => En réalité, les vrais terminaux sont accessibles via la combinaison de touche CTRL + ALT + Fx (où x est un chiffre entre 1 et 6) lorsque vous êtes dans un environnement graphique, le 7 correspondant à cette session. Si vous êtes dans un vrai Terminal, il faut théoriquement utiliser ALT + Fx. À noter également qu'un émulateur permet d'afficher une sorte de TTY (TéléTYpe) dans la session graphique. <|> fx
19 Mot inconnu : TTY [[358:361]] => En réalité, les vrais terminaux sont accessibles via la combinaison de touche CTRL + ALT + Fx (où x est un chiffre entre 1 et 6) lorsque vous êtes dans un environnement graphique, le 7 correspondant à cette session. Si vous êtes dans un vrai Terminal, il faut théoriquement utiliser ALT + Fx. À noter également qu'un émulateur permet d'afficher une sorte de TTY (TéléTYpe) dans la session graphique. <|> tty
19 Mot inconnu : TéléTYpe [[363:371]] => En réalité, les vrais terminaux sont accessibles via la combinaison de touche CTRL + ALT + Fx (où x est un chiffre entre 1 et 6) lorsque vous êtes dans un environnement graphique, le 7 correspondant à cette session. Si vous êtes dans un vrai Terminal, il faut théoriquement utiliser ALT + Fx. À noter également qu'un émulateur permet d'afficher une sorte de TTY (TéléTYpe) dans la session graphique. <|> télétype

21 Il manque un trait d’union. [[120:129]] => Le Shell vous donne accès à toute une gamme d'outils très performants qui permettent d'effectuer des tâches impossibles jusque là mais aussi de les automatiser, et cela d'une manière assez simple. De nombreuses interfaces graphiques sont certes disponibles, mais le shell reste très léger, rapide, accessible, efficace... <|> jusque là => suggestions : jusque-là
21 Typographie : points de suspension. Utilisez le caractère dédié. [[318:321]] => Le Shell vous donne accès à toute une gamme d'outils très performants qui permettent d'effectuer des tâches impossibles jusque là mais aussi de les automatiser, et cela d'une manière assez simple. De nombreuses interfaces graphiques sont certes disponibles, mais le shell reste très léger, rapide, accessible, efficace... <|> ... => suggestions : …

27 Mot inconnu : stdin [[157:162]] => En général, un programme dispose d'une **entrée standard**, d'une **sortie standard**, et d'une **sortie d'erreur standard**, aussi connues sous le nom de **stdin**, **stdout**, **stderr**. Globalement stdin représente le clavier, stdout l'écran et stderr la sortie des messages d'erreur vers l'écran : ceci peut bien entendu varier suivant les programmes, il ne s'agit que d'un exemple. <|> stdin
27 Mot inconnu : stdout [[168:174]] => En général, un programme dispose d'une **entrée standard**, d'une **sortie standard**, et d'une **sortie d'erreur standard**, aussi connues sous le nom de **stdin**, **stdout**, **stderr**. Globalement stdin représente le clavier, stdout l'écran et stderr la sortie des messages d'erreur vers l'écran : ceci peut bien entendu varier suivant les programmes, il ne s'agit que d'un exemple. <|> stdout
27 Mot inconnu : stderr [[180:186]] => En général, un programme dispose d'une **entrée standard**, d'une **sortie standard**, et d'une **sortie d'erreur standard**, aussi connues sous le nom de **stdin**, **stdout**, **stderr**. Globalement stdin représente le clavier, stdout l'écran et stderr la sortie des messages d'erreur vers l'écran : ceci peut bien entendu varier suivant les programmes, il ne s'agit que d'un exemple. <|> stderr
27 Mot inconnu : stdin [[202:207]] => En général, un programme dispose d'une **entrée standard**, d'une **sortie standard**, et d'une **sortie d'erreur standard**, aussi connues sous le nom de **stdin**, **stdout**, **stderr**. Globalement stdin représente le clavier, stdout l'écran et stderr la sortie des messages d'erreur vers l'écran : ceci peut bien entendu varier suivant les programmes, il ne s'agit que d'un exemple. <|> stdin
27 Mot inconnu : stdout [[231:237]] => En général, un programme dispose d'une **entrée standard**, d'une **sortie standard**, et d'une **sortie d'erreur standard**, aussi connues sous le nom de **stdin**, **stdout**, **stderr**. Globalement stdin représente le clavier, stdout l'écran et stderr la sortie des messages d'erreur vers l'écran : ceci peut bien entendu varier suivant les programmes, il ne s'agit que d'un exemple. <|> stdout
27 Mot inconnu : stderr [[249:255]] => En général, un programme dispose d'une **entrée standard**, d'une **sortie standard**, et d'une **sortie d'erreur standard**, aussi connues sous le nom de **stdin**, **stdout**, **stderr**. Globalement stdin représente le clavier, stdout l'écran et stderr la sortie des messages d'erreur vers l'écran : ceci peut bien entendu varier suivant les programmes, il ne s'agit que d'un exemple. <|> stderr
31 Espace(s) en fin de ligne à supprimer. [[53:55]] => ^ Entrées/Sorties             ^ Nom      ^ Numéro   ^   <|>   
32 Mot inconnu : stdin [[33:38]] => | Entrée standard             |  stdin   |   0      | <|> stdin
33 Mot inconnu : stdout [[33:39]] => | Sortie standard             |  stdout  |   1      | <|> stdout
34 Mot inconnu : stderr [[33:39]] => | Sortie d'erreur standard    |  stderr  |   2      | <|> stderr

38 Guillemets typographiques ouvrants. [[30:31]] => Concrètement si vous exécutez "lfdfdfj" dans un terminal, "bash: lfdfdfj: command not found" sera retourné sur stderr. Par contre, si vous tapez ls, le résultat sera retourné sur stdout. <|> " => suggestions : « “
38 Mot inconnu : lfdfdfj [[31:38]] => Concrètement si vous exécutez "lfdfdfj" dans un terminal, "bash: lfdfdfj: command not found" sera retourné sur stderr. Par contre, si vous tapez ls, le résultat sera retourné sur stdout. <|> lfdfdfj
38 Guillemets typographiques fermants. [[38:39]] => Concrètement si vous exécutez "lfdfdfj" dans un terminal, "bash: lfdfdfj: command not found" sera retourné sur stderr. Par contre, si vous tapez ls, le résultat sera retourné sur stdout. <|> " => suggestions :  »”
38 Guillemets typographiques ouvrants. [[58:59]] => Concrètement si vous exécutez "lfdfdfj" dans un terminal, "bash: lfdfdfj: command not found" sera retourné sur stderr. Par contre, si vous tapez ls, le résultat sera retourné sur stdout. <|> " => suggestions : « “
38 Mot inconnu : lfdfdfj [[65:72]] => Concrètement si vous exécutez "lfdfdfj" dans un terminal, "bash: lfdfdfj: command not found" sera retourné sur stderr. Par contre, si vous tapez ls, le résultat sera retourné sur stdout. <|> lfdfdfj
38 Mot inconnu : command [[74:81]] => Concrètement si vous exécutez "lfdfdfj" dans un terminal, "bash: lfdfdfj: command not found" sera retourné sur stderr. Par contre, si vous tapez ls, le résultat sera retourné sur stdout. <|> command
38 Mot inconnu : not [[82:85]] => Concrètement si vous exécutez "lfdfdfj" dans un terminal, "bash: lfdfdfj: command not found" sera retourné sur stderr. Par contre, si vous tapez ls, le résultat sera retourné sur stdout. <|> not
38 Mot inconnu : found [[86:91]] => Concrètement si vous exécutez "lfdfdfj" dans un terminal, "bash: lfdfdfj: command not found" sera retourné sur stderr. Par contre, si vous tapez ls, le résultat sera retourné sur stdout. <|> found
38 Guillemets typographiques fermants. [[91:92]] => Concrètement si vous exécutez "lfdfdfj" dans un terminal, "bash: lfdfdfj: command not found" sera retourné sur stderr. Par contre, si vous tapez ls, le résultat sera retourné sur stdout. <|> " => suggestions :  »”
38 Mot inconnu : stderr [[111:117]] => Concrètement si vous exécutez "lfdfdfj" dans un terminal, "bash: lfdfdfj: command not found" sera retourné sur stderr. Par contre, si vous tapez ls, le résultat sera retourné sur stdout. <|> stderr
38 Mot inconnu : ls [[145:147]] => Concrètement si vous exécutez "lfdfdfj" dans un terminal, "bash: lfdfdfj: command not found" sera retourné sur stderr. Par contre, si vous tapez ls, le résultat sera retourné sur stdout. <|> ls
38 Mot inconnu : stdout [[179:185]] => Concrètement si vous exécutez "lfdfdfj" dans un terminal, "bash: lfdfdfj: command not found" sera retourné sur stderr. Par contre, si vous tapez ls, le résultat sera retourné sur stdout. <|> stdout
47 Typographie : points de suspension. Utilisez le caractère dédié. [[186:189]] => >Dokuwiki remplace automatiquement > >  et < <(sans l'espace entre les deux) par un guillemet comme ça >> et comme ça <<, donc jusqu'à ce qu'une solution soit trouvée (par vous peut être...) pensez à faire le changement mentalement. <|> ... => suggestions : …

53 Guillemets typographiques ouvrants. [[43:44]] => Prenons un exemple, on connaît la commande "ls" qui donne la liste des fichiers d'un répertoire et on veut enregistrer le résultat dans un fichier. Pour cela on    va rediriger le résultat de la sortie standard dans le fichier test à l'aide de la commande suivante : <|> " => suggestions : « “
53 Mot inconnu : ls [[44:46]] => Prenons un exemple, on connaît la commande "ls" qui donne la liste des fichiers d'un répertoire et on veut enregistrer le résultat dans un fichier. Pour cela on    va rediriger le résultat de la sortie standard dans le fichier test à l'aide de la commande suivante : <|> ls
53 Guillemets typographiques fermants. [[46:47]] => Prenons un exemple, on connaît la commande "ls" qui donne la liste des fichiers d'un répertoire et on veut enregistrer le résultat dans un fichier. Pour cela on    va rediriger le résultat de la sortie standard dans le fichier test à l'aide de la commande suivante : <|> " => suggestions :  »”
53 Espace(s) surnuméraire(s) à supprimer. [[160:164]] => Prenons un exemple, on connaît la commande "ls" qui donne la liste des fichiers d'un répertoire et on veut enregistrer le résultat dans un fichier. Pour cela on    va rediriger le résultat de la sortie standard dans le fichier test à l'aide de la commande suivante : <|>      => suggestions :  

57 Mot inconnu : stderr [[31:37]] => De même si on veut enregistrer stderr de la commande "lfdfdfj", on utilise : <|> stderr
57 Guillemets typographiques ouvrants. [[53:54]] => De même si on veut enregistrer stderr de la commande "lfdfdfj", on utilise : <|> " => suggestions : « “
57 Mot inconnu : lfdfdfj [[54:61]] => De même si on veut enregistrer stderr de la commande "lfdfdfj", on utilise : <|> lfdfdfj
57 Guillemets typographiques fermants. [[61:62]] => De même si on veut enregistrer stderr de la commande "lfdfdfj", on utilise : <|> " => suggestions :  »”

61 Mot inconnu : stdout [[166:172]] => Dans le premier exemple, on peut constater que l'on ne précise pas le descripteur de fichier redirigé (1), en effet le descripteur de fichier redirigé par défaut est stdout. <|> stdout

69 Il faut élider “si” et l’accoler au pronom. [[35:38]] => Si test n'existe pas il sera créé, si il existe le résultat sera ajouté à son contenu (à la fin du fichier). De la même manière, vous pouvez rediriger stderr :  <|> si  => suggestions : s’
69 Mot inconnu : stderr [[151:157]] => Si test n'existe pas il sera créé, si il existe le résultat sera ajouté à son contenu (à la fin du fichier). De la même manière, vous pouvez rediriger stderr :  <|> stderr
69 Espace(s) en fin de ligne à supprimer. [[159:160]] => Si test n'existe pas il sera créé, si il existe le résultat sera ajouté à son contenu (à la fin du fichier). De la même manière, vous pouvez rediriger stderr :  <|>  

73 Guillemets typographiques ouvrants. [[90:91]] => Mais il est également possible de rediriger une sortie vers une autre sortie, par exemple "2>&1" signifie "rediriger stderr vers ce que représente stdout". Ainsi  <|> " => suggestions : « “
73 Guillemets typographiques fermants. [[95:96]] => Mais il est également possible de rediriger une sortie vers une autre sortie, par exemple "2>&1" signifie "rediriger stderr vers ce que représente stdout". Ainsi  <|> " => suggestions :  »”
73 Guillemets typographiques ouvrants. [[106:107]] => Mais il est également possible de rediriger une sortie vers une autre sortie, par exemple "2>&1" signifie "rediriger stderr vers ce que représente stdout". Ainsi  <|> " => suggestions : « “
73 Mot inconnu : stderr [[117:123]] => Mais il est également possible de rediriger une sortie vers une autre sortie, par exemple "2>&1" signifie "rediriger stderr vers ce que représente stdout". Ainsi  <|> stderr
73 Mot inconnu : stdout [[147:153]] => Mais il est également possible de rediriger une sortie vers une autre sortie, par exemple "2>&1" signifie "rediriger stderr vers ce que représente stdout". Ainsi  <|> stdout
73 Guillemets typographiques fermants. [[153:154]] => Mais il est également possible de rediriger une sortie vers une autre sortie, par exemple "2>&1" signifie "rediriger stderr vers ce que représente stdout". Ainsi  <|> " => suggestions :  »”
73 Espace(s) en fin de ligne à supprimer. [[161:162]] => Mais il est également possible de rediriger une sortie vers une autre sortie, par exemple "2>&1" signifie "rediriger stderr vers ce que représente stdout". Ainsi  <|>  

77 Majuscule en début de phrase, sauf éventuellement lors d’une énumération. [[0:10]] => redirigera stdout et stderr dans le fichier test. Vous remarquerez que les redirections s'effectuent de droite à gauche : la sortie stderr 2 est tout d'abord redirigée vers la sortie stdout 1, puis la sortie standard de ls s'inscrit dans le fichier test. <|> redirigera => suggestions : Redirigera
77 Mot inconnu : stdout [[11:17]] => redirigera stdout et stderr dans le fichier test. Vous remarquerez que les redirections s'effectuent de droite à gauche : la sortie stderr 2 est tout d'abord redirigée vers la sortie stdout 1, puis la sortie standard de ls s'inscrit dans le fichier test. <|> stdout
77 Mot inconnu : stderr [[21:27]] => redirigera stdout et stderr dans le fichier test. Vous remarquerez que les redirections s'effectuent de droite à gauche : la sortie stderr 2 est tout d'abord redirigée vers la sortie stdout 1, puis la sortie standard de ls s'inscrit dans le fichier test. <|> stderr
77 Mot inconnu : stderr [[132:138]] => redirigera stdout et stderr dans le fichier test. Vous remarquerez que les redirections s'effectuent de droite à gauche : la sortie stderr 2 est tout d'abord redirigée vers la sortie stdout 1, puis la sortie standard de ls s'inscrit dans le fichier test. <|> stderr
77 Mot inconnu : stdout [[183:189]] => redirigera stdout et stderr dans le fichier test. Vous remarquerez que les redirections s'effectuent de droite à gauche : la sortie stderr 2 est tout d'abord redirigée vers la sortie stdout 1, puis la sortie standard de ls s'inscrit dans le fichier test. <|> stdout
77 Mot inconnu : ls [[220:222]] => redirigera stdout et stderr dans le fichier test. Vous remarquerez que les redirections s'effectuent de droite à gauche : la sortie stderr 2 est tout d'abord redirigée vers la sortie stdout 1, puis la sortie standard de ls s'inscrit dans le fichier test. <|> ls

81 Mot inconnu : stdin [[38:43]] => Pour rediriger vers l'entrée standard stdin, nous allons utiliser "<" et "<<".  <|> stdin
81 Espace(s) en fin de ligne à supprimer. [[78:79]] => Pour rediriger vers l'entrée standard stdin, nous allons utiliser "<" et "<<".  <|>  

83 Guillemets typographiques ouvrants. [[0:1]] => "wc" permet de compter le nombre de lignes (option -l) ou de mots (option -w), plus d'informations dans la page man de wc, en entrée. Pour compter le nombre de lignes d'un fichier on peut donc utiliser : <|> " => suggestions : « “
83 Mot inconnu : wc [[1:3]] => "wc" permet de compter le nombre de lignes (option -l) ou de mots (option -w), plus d'informations dans la page man de wc, en entrée. Pour compter le nombre de lignes d'un fichier on peut donc utiliser : <|> wc
83 Guillemets typographiques fermants. [[3:4]] => "wc" permet de compter le nombre de lignes (option -l) ou de mots (option -w), plus d'informations dans la page man de wc, en entrée. Pour compter le nombre de lignes d'un fichier on peut donc utiliser : <|> " => suggestions :  »”
83 Il manque un espace à côté du tiret. [[50:52]] => "wc" permet de compter le nombre de lignes (option -l) ou de mots (option -w), plus d'informations dans la page man de wc, en entrée. Pour compter le nombre de lignes d'un fichier on peut donc utiliser : <|>  - => suggestions :  –  — 
83 Il manque un espace à côté du tiret. [[73:75]] => "wc" permet de compter le nombre de lignes (option -l) ou de mots (option -w), plus d'informations dans la page man de wc, en entrée. Pour compter le nombre de lignes d'un fichier on peut donc utiliser : <|>  - => suggestions :  –  — 
83 Mot inconnu : wc [[119:121]] => "wc" permet de compter le nombre de lignes (option -l) ou de mots (option -w), plus d'informations dans la page man de wc, en entrée. Pour compter le nombre de lignes d'un fichier on peut donc utiliser : <|> wc

87 Mot inconnu : wc [[44:46]] => Cette commande donnera le même résultat car wc peut prendre un fichier comme paramètre : <|> wc

88 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). [[0:1]] =>   <|>  

91 Mot inconnu : stdin [[35:40]] => "<<" permet lui aussi de rediriger stdin mais jusqu'à une chaîne de caractère que l'on précisera : littéralement on pourrait dire que << transmet notre entrée standard (clavier) au programme à sa gauche, et cela jusqu'à ce qu'il rencontre une ligne EOF ((End of File : Fin de fichier)). <|> stdin
91 Mot inconnu : EOF [[249:252]] => "<<" permet lui aussi de rediriger stdin mais jusqu'à une chaîne de caractère que l'on précisera : littéralement on pourrait dire que << transmet notre entrée standard (clavier) au programme à sa gauche, et cela jusqu'à ce qu'il rencontre une ligne EOF ((End of File : Fin de fichier)). <|> eof
91 Mot inconnu : End [[255:258]] => "<<" permet lui aussi de rediriger stdin mais jusqu'à une chaîne de caractère que l'on précisera : littéralement on pourrait dire que << transmet notre entrée standard (clavier) au programme à sa gauche, et cela jusqu'à ce qu'il rencontre une ligne EOF ((End of File : Fin de fichier)). <|> end
91 Mot inconnu : of [[259:261]] => "<<" permet lui aussi de rediriger stdin mais jusqu'à une chaîne de caractère que l'on précisera : littéralement on pourrait dire que << transmet notre entrée standard (clavier) au programme à sa gauche, et cela jusqu'à ce qu'il rencontre une ligne EOF ((End of File : Fin de fichier)). <|> of

93 Mot inconnu : EOF [[167:170]] => Par exemple la commande suivante vous permettra de taper un texte, d'aller à la ligne autant de fois que vous voulez en appuyant sur Entrée, puis lorsque vous taperez EOF (pour End of File, fin du fichier) et entrée, elle comptera le nombre de lignes (celle de EOF non comprise) que vous avez entrées. <|> eof
93 Mot inconnu : End [[177:180]] => Par exemple la commande suivante vous permettra de taper un texte, d'aller à la ligne autant de fois que vous voulez en appuyant sur Entrée, puis lorsque vous taperez EOF (pour End of File, fin du fichier) et entrée, elle comptera le nombre de lignes (celle de EOF non comprise) que vous avez entrées. <|> end
93 Mot inconnu : of [[181:183]] => Par exemple la commande suivante vous permettra de taper un texte, d'aller à la ligne autant de fois que vous voulez en appuyant sur Entrée, puis lorsque vous taperez EOF (pour End of File, fin du fichier) et entrée, elle comptera le nombre de lignes (celle de EOF non comprise) que vous avez entrées. <|> of
93 Mot inconnu : EOF [[261:264]] => Par exemple la commande suivante vous permettra de taper un texte, d'aller à la ligne autant de fois que vous voulez en appuyant sur Entrée, puis lorsque vous taperez EOF (pour End of File, fin du fichier) et entrée, elle comptera le nombre de lignes (celle de EOF non comprise) que vous avez entrées. <|> eof

97 Accord de genre erroné : « chaîne » est féminin. [[31:33]] => Vous pouvez bien sur spécifier un chaîne différente de EOF comme FIN, END... <|> un => suggestions : une
97 Accord de genre erroné : « un » est un déterminant masculin. [[34:40]] => Vous pouvez bien sur spécifier un chaîne différente de EOF comme FIN, END... <|> chaîne => suggestions : chaînéchêne
97 Mot inconnu : EOF [[55:58]] => Vous pouvez bien sur spécifier un chaîne différente de EOF comme FIN, END... <|> eof
97 Mot inconnu : END [[70:73]] => Vous pouvez bien sur spécifier un chaîne différente de EOF comme FIN, END... <|> end
97 Typographie : points de suspension. Utilisez le caractère dédié. [[73:76]] => Vous pouvez bien sur spécifier un chaîne différente de EOF comme FIN, END... <|> ... => suggestions : …
99 Espace(s) en fin de ligne à supprimer. [[141:142]] => En utilisant ">>" et "<<" nous pouvons facilement ajouter du texte dans un fichier de notre choix de la même manière qu'un éditeur de texte :  <|>  

103 Mot inconnu : EOF [[71:74]] => Le texte tapé sera ajouté au fichier jusqu'à ce que vous vous écriviez EOF et validiez par entrée. <|> eof

109 Dialogues et énumérations : un tiret cadratin [1] ou demi-cadratin [2], suivi d’un espace insécable, est requis. [[0:2]] => - commande (dont les stdout et stderr sont redirigées) <|> -  => suggestions : – — 
109 Mot inconnu : stdout [[21:27]] => - commande (dont les stdout et stderr sont redirigées) <|> stdout
109 Mot inconnu : stderr [[31:37]] => - commande (dont les stdout et stderr sont redirigées) <|> stderr

111 Dialogues et énumérations : un tiret cadratin [1] ou demi-cadratin [2], suivi d’un espace insécable, est requis. [[0:2]] => - stdout vers /dev/null (le trou noir) <|> -  => suggestions : – — 
111 Mot inconnu : stdout [[2:8]] => - stdout vers /dev/null (le trou noir) <|> stdout

113 Dialogues et énumérations : un tiret cadratin [1] ou demi-cadratin [2], suivi d’un espace insécable, est requis. [[0:2]] => - stderr vers stdout ... donc vers /dev/null <|> -  => suggestions : – — 
113 Mot inconnu : stderr [[2:8]] => - stderr vers stdout ... donc vers /dev/null <|> stderr
113 Mot inconnu : stdout [[14:20]] => - stderr vers stdout ... donc vers /dev/null <|> stdout
113 Typographie : points de suspension. Utilisez le caractère dédié. [[21:24]] => - stderr vers stdout ... donc vers /dev/null <|> ... => suggestions : …

121 Mot inconnu : null [[115:119]] => >Même si cela ne traite pas directement des redirections, il est important de connaitre un fichier spécial nommé **null**. Il permet de rediriger un descripteur de fichier vers un fichier qui supprimera toutes les données qui lui seront ajoutées. Il porte le nom d'**absorbeur de données**. Si par exemple vous ne voulez pas voir le résultat d'une commande, il vous suffit de rediriger stdout vers /dev/null : "ls >/dev/null". Pour plus d'information sur le fichier null voir la page man de null. <|> null
121 Mot inconnu : stdout [[386:392]] => >Même si cela ne traite pas directement des redirections, il est important de connaitre un fichier spécial nommé **null**. Il permet de rediriger un descripteur de fichier vers un fichier qui supprimera toutes les données qui lui seront ajoutées. Il porte le nom d'**absorbeur de données**. Si par exemple vous ne voulez pas voir le résultat d'une commande, il vous suffit de rediriger stdout vers /dev/null : "ls >/dev/null". Pour plus d'information sur le fichier null voir la page man de null. <|> stdout
121 Guillemets typographiques ouvrants. [[410:411]] => >Même si cela ne traite pas directement des redirections, il est important de connaitre un fichier spécial nommé **null**. Il permet de rediriger un descripteur de fichier vers un fichier qui supprimera toutes les données qui lui seront ajoutées. Il porte le nom d'**absorbeur de données**. Si par exemple vous ne voulez pas voir le résultat d'une commande, il vous suffit de rediriger stdout vers /dev/null : "ls >/dev/null". Pour plus d'information sur le fichier null voir la page man de null. <|> " => suggestions : « “
121 Mot inconnu : ls [[411:413]] => >Même si cela ne traite pas directement des redirections, il est important de connaitre un fichier spécial nommé **null**. Il permet de rediriger un descripteur de fichier vers un fichier qui supprimera toutes les données qui lui seront ajoutées. Il porte le nom d'**absorbeur de données**. Si par exemple vous ne voulez pas voir le résultat d'une commande, il vous suffit de rediriger stdout vers /dev/null : "ls >/dev/null". Pour plus d'information sur le fichier null voir la page man de null. <|> ls
121 Mot inconnu : null [[466:470]] => >Même si cela ne traite pas directement des redirections, il est important de connaitre un fichier spécial nommé **null**. Il permet de rediriger un descripteur de fichier vers un fichier qui supprimera toutes les données qui lui seront ajoutées. Il porte le nom d'**absorbeur de données**. Si par exemple vous ne voulez pas voir le résultat d'une commande, il vous suffit de rediriger stdout vers /dev/null : "ls >/dev/null". Pour plus d'information sur le fichier null voir la page man de null. <|> null
121 Mot inconnu : null [[491:495]] => >Même si cela ne traite pas directement des redirections, il est important de connaitre un fichier spécial nommé **null**. Il permet de rediriger un descripteur de fichier vers un fichier qui supprimera toutes les données qui lui seront ajoutées. Il porte le nom d'**absorbeur de données**. Si par exemple vous ne voulez pas voir le résultat d'une commande, il vous suffit de rediriger stdout vers /dev/null : "ls >/dev/null". Pour plus d'information sur le fichier null voir la page man de null. <|> null

131 Mot inconnu : fondadamentales [[99:114]] => Pour cette partie, consulter http://doc.ubuntu-fr.org/console/commandes_de_base pour les commandes fondadamentales : cp, mv, ls, cd, rm, chmod, chown et find. <|> fondadamentales
131 Mot inconnu : cp [[117:119]] => Pour cette partie, consulter http://doc.ubuntu-fr.org/console/commandes_de_base pour les commandes fondadamentales : cp, mv, ls, cd, rm, chmod, chown et find. <|> cp
131 Mot inconnu : mv [[121:123]] => Pour cette partie, consulter http://doc.ubuntu-fr.org/console/commandes_de_base pour les commandes fondadamentales : cp, mv, ls, cd, rm, chmod, chown et find. <|> mv
131 Mot inconnu : ls [[125:127]] => Pour cette partie, consulter http://doc.ubuntu-fr.org/console/commandes_de_base pour les commandes fondadamentales : cp, mv, ls, cd, rm, chmod, chown et find. <|> ls
131 Mot inconnu : rm [[133:135]] => Pour cette partie, consulter http://doc.ubuntu-fr.org/console/commandes_de_base pour les commandes fondadamentales : cp, mv, ls, cd, rm, chmod, chown et find. <|> rm
131 Mot inconnu : find [[153:157]] => Pour cette partie, consulter http://doc.ubuntu-fr.org/console/commandes_de_base pour les commandes fondadamentales : cp, mv, ls, cd, rm, chmod, chown et find. <|> find

133 Mot inconnu : Cut [[5:8]] => ==== Cut ==== <|> cut

135 Mot inconnu : cut [[25:28]] => Pour présenter l'outil **cut** nous allons par exemple considérer que nous voulons obtenir le premier mot (correspondant au nom de l'utilisateur) du fichier /etc/passwd. <|> cut

137 Mot inconnu : cut [[5:8]] => Avec cut, vous pouvez supprimer une partie de chaque ligne d'un fichier, soit en indiquant un séparateur (avec l'option -d), soit en indiquant la position (via -c).  <|> cut
137 Il manque un espace à côté du tiret. [[119:121]] => Avec cut, vous pouvez supprimer une partie de chaque ligne d'un fichier, soit en indiquant un séparateur (avec l'option -d), soit en indiquant la position (via -c).  <|>  - => suggestions :  –  — 
137 Il manque un espace à côté du tiret. [[159:161]] => Avec cut, vous pouvez supprimer une partie de chaque ligne d'un fichier, soit en indiquant un séparateur (avec l'option -d), soit en indiquant la position (via -c).  <|>  - => suggestions :  –  — 
137 Espace(s) en fin de ligne à supprimer. [[164:165]] => Avec cut, vous pouvez supprimer une partie de chaque ligne d'un fichier, soit en indiquant un séparateur (avec l'option -d), soit en indiquant la position (via -c).  <|>  
139 Espace(s) en fin de ligne à supprimer. [[33:34]] => Voyons tout de suite un exemple :  <|>  

143 Mot inconnu : f1 [[60:62]] => L'option "-d:" indique que le **séparateur** sera ":", et "-f1" indique que l'on veut récupérer seulement la **première partie**.  <|> f1
143 Guillemets typographiques fermants. [[62:63]] => L'option "-d:" indique que le **séparateur** sera ":", et "-f1" indique que l'on veut récupérer seulement la **première partie**.  <|> " => suggestions :  »”
143 Espace(s) en fin de ligne à supprimer. [[129:130]] => L'option "-d:" indique que le **séparateur** sera ":", et "-f1" indique que l'on veut récupérer seulement la **première partie**.  <|>  

146 Il manque un espace à côté du tiret. [[72:74]] => >Pour utiliser l'espace comme caractère de séparation, utilisez l'option -d" ". <|>  - => suggestions :  –  — 
146 Guillemets typographiques fermants. [[75:76]] => >Pour utiliser l'espace comme caractère de séparation, utilisez l'option -d" ". <|> " => suggestions :  »”
146 Guillemets fermants. [[76:78]] => >Pour utiliser l'espace comme caractère de séparation, utilisez l'option -d" ". <|>  " => suggestions :  »”
152 Espace(s) en fin de ligne à supprimer. [[57:58]] => Maintenant si l'on travaille en fonction de la position :  <|>  

158 Mot inconnu : Head [[5:9]] => ==== Head et Tail ==== <|> head
158 Mot inconnu : Tail [[13:17]] => ==== Head et Tail ==== <|> tail

160 Erreur de numérisation ? Virgules au lieu de points ? [[97:101]] => Il est souvent utile de ne voir que le début ou que la fin d'un texte, du résultat d'une commande,... Il existe pour cela deux outils : **head** (tête en français) et **tail** (queue en français). <|> ,... => suggestions : ….
160 Typographie : points de suspension. Utilisez le caractère dédié. [[98:101]] => Il est souvent utile de ne voir que le début ou que la fin d'un texte, du résultat d'une commande,... Il existe pour cela deux outils : **head** (tête en français) et **tail** (queue en français). <|> ... => suggestions : …
160 Mot inconnu : head [[138:142]] => Il est souvent utile de ne voir que le début ou que la fin d'un texte, du résultat d'une commande,... Il existe pour cela deux outils : **head** (tête en français) et **tail** (queue en français). <|> head
160 Mot inconnu : tail [[169:173]] => Il est souvent utile de ne voir que le début ou que la fin d'un texte, du résultat d'une commande,... Il existe pour cela deux outils : **head** (tête en français) et **tail** (queue en français). <|> tail

170 Typographie : points de suspension. Utilisez le caractère dédié. [[113:116]] => Pour récupérer le résultat d'une commande, nous allons utiliser l'opérateur | appelé **pipe** (qui signifie tuyau...), son fonctionnement sera expliqué plus bas. Pour récupérer les 5 dernières du résultat de dmesg : <|> ... => suggestions : …
170 Mot inconnu : dmesg [[208:213]] => Pour récupérer le résultat d'une commande, nous allons utiliser l'opérateur | appelé **pipe** (qui signifie tuyau...), son fonctionnement sera expliqué plus bas. Pour récupérer les 5 dernières du résultat de dmesg : <|> dmesg

174 Il manque un espace à côté du tiret. [[8:10]] => L'option -f permet d'afficher, à chaque fois qu'ils ont lieu, les ajouts au fichier, par exemple :  <|>  - => suggestions :  –  — 
174 Espace(s) en fin de ligne à supprimer. [[98:99]] => L'option -f permet d'afficher, à chaque fois qu'ils ont lieu, les ajouts au fichier, par exemple :  <|>  
184 Espace(s) en fin de ligne à supprimer. [[184:185]] => Cet opérateur permet d'envoyer la **sortie standard** d'un programme **vers** **l'entrée standard** d'un second programme, cela permet ainsi l'enchaînement des commandes. Par exemple :  <|>  

188 Guillemets typographiques ouvrants. [[22:23]] => La sortie standard de "ls" devient l'entrée standard de "wc -l". <|> " => suggestions : « “
188 Mot inconnu : ls [[23:25]] => La sortie standard de "ls" devient l'entrée standard de "wc -l". <|> ls
188 Guillemets typographiques fermants. [[25:26]] => La sortie standard de "ls" devient l'entrée standard de "wc -l". <|> " => suggestions :  »”
188 Guillemets typographiques ouvrants. [[56:57]] => La sortie standard de "ls" devient l'entrée standard de "wc -l". <|> " => suggestions : « “
188 Mot inconnu : wc [[57:59]] => La sortie standard de "ls" devient l'entrée standard de "wc -l". <|> wc
188 Il manque un espace à côté du tiret. [[59:61]] => La sortie standard de "ls" devient l'entrée standard de "wc -l". <|>  - => suggestions :  –  — 
188 Guillemets typographiques fermants. [[62:63]] => La sortie standard de "ls" devient l'entrée standard de "wc -l". <|> " => suggestions :  »”
190 Espace(s) en fin de ligne à supprimer. [[17:18]] => Autres exemples :  <|>  

197 Guillemets typographiques ouvrants. [[77:78]] => >sort permet de trier les lignes d'un fichier texte, pour plus d'information "man sort".  <|> " => suggestions : « “
197 Guillemets typographiques fermants. [[86:87]] => >sort permet de trier les lignes d'un fichier texte, pour plus d'information "man sort".  <|> " => suggestions :  »”
197 Espace(s) en fin de ligne à supprimer. [[88:89]] => >sort permet de trier les lignes d'un fichier texte, pour plus d'information "man sort".  <|>  
199 Espace(s) en fin de ligne à supprimer. [[61:62]] => Vous pouvez bien sûr étendre cela à plus de deux programmes :  <|>  
203 Espace(s) en fin de ligne à supprimer. [[63:64]] => Vous pouvez aussi utiliser les redirections vues précédemment :  <|>  

207 Guillemets typographiques ouvrants. [[15:16]] => Dans le cas de "ls -la > fichier" nous pouvons remarquer qu'il n'y a rien sur stdout ou stderr. Pour pallier à cela le programme tee permet de copier l'entrée standard sur la sortie standard et dans un fichier : "ls -la | tee fichier".  <|> " => suggestions : « “
207 Mot inconnu : ls [[16:18]] => Dans le cas de "ls -la > fichier" nous pouvons remarquer qu'il n'y a rien sur stdout ou stderr. Pour pallier à cela le programme tee permet de copier l'entrée standard sur la sortie standard et dans un fichier : "ls -la | tee fichier".  <|> ls
207 Il manque un espace à côté du tiret. [[18:20]] => Dans le cas de "ls -la > fichier" nous pouvons remarquer qu'il n'y a rien sur stdout ou stderr. Pour pallier à cela le programme tee permet de copier l'entrée standard sur la sortie standard et dans un fichier : "ls -la | tee fichier".  <|>  - => suggestions :  –  — 
207 Guillemets typographiques fermants. [[32:33]] => Dans le cas de "ls -la > fichier" nous pouvons remarquer qu'il n'y a rien sur stdout ou stderr. Pour pallier à cela le programme tee permet de copier l'entrée standard sur la sortie standard et dans un fichier : "ls -la | tee fichier".  <|> " => suggestions :  »”
207 Mot inconnu : stdout [[78:84]] => Dans le cas de "ls -la > fichier" nous pouvons remarquer qu'il n'y a rien sur stdout ou stderr. Pour pallier à cela le programme tee permet de copier l'entrée standard sur la sortie standard et dans un fichier : "ls -la | tee fichier".  <|> stdout
207 Mot inconnu : stderr [[88:94]] => Dans le cas de "ls -la > fichier" nous pouvons remarquer qu'il n'y a rien sur stdout ou stderr. Pour pallier à cela le programme tee permet de copier l'entrée standard sur la sortie standard et dans un fichier : "ls -la | tee fichier".  <|> stderr
207 Guillemets typographiques ouvrants. [[212:213]] => Dans le cas de "ls -la > fichier" nous pouvons remarquer qu'il n'y a rien sur stdout ou stderr. Pour pallier à cela le programme tee permet de copier l'entrée standard sur la sortie standard et dans un fichier : "ls -la | tee fichier".  <|> " => suggestions : « “
207 Mot inconnu : ls [[213:215]] => Dans le cas de "ls -la > fichier" nous pouvons remarquer qu'il n'y a rien sur stdout ou stderr. Pour pallier à cela le programme tee permet de copier l'entrée standard sur la sortie standard et dans un fichier : "ls -la | tee fichier".  <|> ls
207 Il manque un espace à côté du tiret. [[215:217]] => Dans le cas de "ls -la > fichier" nous pouvons remarquer qu'il n'y a rien sur stdout ou stderr. Pour pallier à cela le programme tee permet de copier l'entrée standard sur la sortie standard et dans un fichier : "ls -la | tee fichier".  <|>  - => suggestions :  –  — 
207 Guillemets typographiques fermants. [[233:234]] => Dans le cas de "ls -la > fichier" nous pouvons remarquer qu'il n'y a rien sur stdout ou stderr. Pour pallier à cela le programme tee permet de copier l'entrée standard sur la sortie standard et dans un fichier : "ls -la | tee fichier".  <|> " => suggestions :  »”
207 Espace(s) en fin de ligne à supprimer. [[235:236]] => Dans le cas de "ls -la > fichier" nous pouvons remarquer qu'il n'y a rien sur stdout ou stderr. Pour pallier à cela le programme tee permet de copier l'entrée standard sur la sortie standard et dans un fichier : "ls -la | tee fichier".  <|>  
220 Guillemets typographiques ouvrants. [[72:73]] => Vous pouvez aussi l'utiliser pour mettre un programme en arrière plan : "ed &". Pour reprendre la main sur ce programme il faut utiliser la commande fg. <|> " => suggestions : « “
220 Mot inconnu : ed [[73:75]] => Vous pouvez aussi l'utiliser pour mettre un programme en arrière plan : "ed &". Pour reprendre la main sur ce programme il faut utiliser la commande fg. <|> ed
225 Guillemets typographiques ouvrants. [[207:208]] => Pour pouvoir bien comprendre ce que fait cet opérateur il faut d'abord parler rapidement des **codes de retour** : quand vous lancez une commande, si elle se termine correctement alors le code de retour est "0", ce qui correspond à un succès, dans le cas contraire le code de retour est différent de 0 (bien entendu les codes de retour différents de 0 ont une signification qui ne sera pas expliquée ici).  <|> " => suggestions : « “
225 Guillemets typographiques fermants. [[209:210]] => Pour pouvoir bien comprendre ce que fait cet opérateur il faut d'abord parler rapidement des **codes de retour** : quand vous lancez une commande, si elle se termine correctement alors le code de retour est "0", ce qui correspond à un succès, dans le cas contraire le code de retour est différent de 0 (bien entendu les codes de retour différents de 0 ont une signification qui ne sera pas expliquée ici).  <|> " => suggestions :  »”
225 Espace(s) en fin de ligne à supprimer. [[405:406]] => Pour pouvoir bien comprendre ce que fait cet opérateur il faut d'abord parler rapidement des **codes de retour** : quand vous lancez une commande, si elle se termine correctement alors le code de retour est "0", ce qui correspond à un succès, dans le cas contraire le code de retour est différent de 0 (bien entendu les codes de retour différents de 0 ont une signification qui ne sera pas expliquée ici).  <|>  
227 Guillemets typographiques ouvrants. [[90:91]] => Si par exemple vous rentrez une commande erronée, le code de retour sera différent de 0 : "fgsfdg".  <|> " => suggestions : « “
227 Mot inconnu : fgsfdg [[91:97]] => Si par exemple vous rentrez une commande erronée, le code de retour sera différent de 0 : "fgsfdg".  <|> fgsfdg
227 Guillemets typographiques fermants. [[97:98]] => Si par exemple vous rentrez une commande erronée, le code de retour sera différent de 0 : "fgsfdg".  <|> " => suggestions :  »”
227 Espace(s) en fin de ligne à supprimer. [[99:100]] => Si par exemple vous rentrez une commande erronée, le code de retour sera différent de 0 : "fgsfdg".  <|>  
229 Espace(s) en fin de ligne à supprimer. [[60:61]] => Pour voir le code de retour de la dernière commande lancée :  <|>  
233 Espace(s) en fin de ligne à supprimer. [[139:140]] => L'opérateur "&&" permet de lancer une commande si et seulement si la première (celle à gauche de l'opérateur) s'est correctement terminée :  <|>  

237 Guillemets typographiques ouvrants. [[15:16]] => Si la commande "ls" se termine correctement alors "ls /" sera exécutée. Un second exemple :  <|> " => suggestions : « “
237 Mot inconnu : ls [[16:18]] => Si la commande "ls" se termine correctement alors "ls /" sera exécutée. Un second exemple :  <|> ls
237 Guillemets typographiques fermants. [[18:19]] => Si la commande "ls" se termine correctement alors "ls /" sera exécutée. Un second exemple :  <|> " => suggestions :  »”
237 Guillemets typographiques ouvrants. [[50:51]] => Si la commande "ls" se termine correctement alors "ls /" sera exécutée. Un second exemple :  <|> " => suggestions : « “
237 Mot inconnu : ls [[51:53]] => Si la commande "ls" se termine correctement alors "ls /" sera exécutée. Un second exemple :  <|> ls
237 Espace(s) en fin de ligne à supprimer. [[91:92]] => Si la commande "ls" se termine correctement alors "ls /" sera exécutée. Un second exemple :  <|>  

247 Guillemets typographiques ouvrants. [[12:13]] => Dans ce cas "ls" sera exécuté. <|> " => suggestions : « “
247 Mot inconnu : ls [[13:15]] => Dans ce cas "ls" sera exécuté. <|> ls
247 Guillemets typographiques fermants. [[15:16]] => Dans ce cas "ls" sera exécuté. <|> " => suggestions :  »”

249 Guillemets fermants. [[20:22]] => ==== Présentation de ";" ==== <|>  " => suggestions :  »”

251 Il manque les traits d’union. [[53:65]] => Cet opérateur est équivalent à un retour à la ligne, c'est à dire que "ls; ls -l" exécutera "ls" dans un premier temps puis, une fois la première commande finie et quel que soit son code de retour, "ls -l" sera exécuté. <|> c'est à dire => suggestions : c’est-à-dire
251 Guillemets typographiques ouvrants. [[70:71]] => Cet opérateur est équivalent à un retour à la ligne, c'est à dire que "ls; ls -l" exécutera "ls" dans un premier temps puis, une fois la première commande finie et quel que soit son code de retour, "ls -l" sera exécuté. <|> " => suggestions : « “
251 Mot inconnu : ls [[71:73]] => Cet opérateur est équivalent à un retour à la ligne, c'est à dire que "ls; ls -l" exécutera "ls" dans un premier temps puis, une fois la première commande finie et quel que soit son code de retour, "ls -l" sera exécuté. <|> ls
251 Mot inconnu : ls [[75:77]] => Cet opérateur est équivalent à un retour à la ligne, c'est à dire que "ls; ls -l" exécutera "ls" dans un premier temps puis, une fois la première commande finie et quel que soit son code de retour, "ls -l" sera exécuté. <|> ls
251 Il manque un espace à côté du tiret. [[77:79]] => Cet opérateur est équivalent à un retour à la ligne, c'est à dire que "ls; ls -l" exécutera "ls" dans un premier temps puis, une fois la première commande finie et quel que soit son code de retour, "ls -l" sera exécuté. <|>  - => suggestions :  –  — 
251 Guillemets typographiques fermants. [[80:81]] => Cet opérateur est équivalent à un retour à la ligne, c'est à dire que "ls; ls -l" exécutera "ls" dans un premier temps puis, une fois la première commande finie et quel que soit son code de retour, "ls -l" sera exécuté. <|> " => suggestions :  »”
251 Guillemets typographiques ouvrants. [[92:93]] => Cet opérateur est équivalent à un retour à la ligne, c'est à dire que "ls; ls -l" exécutera "ls" dans un premier temps puis, une fois la première commande finie et quel que soit son code de retour, "ls -l" sera exécuté. <|> " => suggestions : « “
251 Mot inconnu : ls [[93:95]] => Cet opérateur est équivalent à un retour à la ligne, c'est à dire que "ls; ls -l" exécutera "ls" dans un premier temps puis, une fois la première commande finie et quel que soit son code de retour, "ls -l" sera exécuté. <|> ls
251 Guillemets typographiques fermants. [[95:96]] => Cet opérateur est équivalent à un retour à la ligne, c'est à dire que "ls; ls -l" exécutera "ls" dans un premier temps puis, une fois la première commande finie et quel que soit son code de retour, "ls -l" sera exécuté. <|> " => suggestions :  »”
251 Guillemets typographiques ouvrants. [[198:199]] => Cet opérateur est équivalent à un retour à la ligne, c'est à dire que "ls; ls -l" exécutera "ls" dans un premier temps puis, une fois la première commande finie et quel que soit son code de retour, "ls -l" sera exécuté. <|> " => suggestions : « “
251 Mot inconnu : ls [[199:201]] => Cet opérateur est équivalent à un retour à la ligne, c'est à dire que "ls; ls -l" exécutera "ls" dans un premier temps puis, une fois la première commande finie et quel que soit son code de retour, "ls -l" sera exécuté. <|> ls
251 Il manque un espace à côté du tiret. [[201:203]] => Cet opérateur est équivalent à un retour à la ligne, c'est à dire que "ls; ls -l" exécutera "ls" dans un premier temps puis, une fois la première commande finie et quel que soit son code de retour, "ls -l" sera exécuté. <|>  - => suggestions :  –  — 
251 Guillemets typographiques fermants. [[204:205]] => Cet opérateur est équivalent à un retour à la ligne, c'est à dire que "ls; ls -l" exécutera "ls" dans un premier temps puis, une fois la première commande finie et quel que soit son code de retour, "ls -l" sera exécuté. <|> " => suggestions :  »”

258 Mot inconnu : regex [[81:86]] => Les **expressions rationnelles**, souvent appelées **expressions régulières**, **regex** ou **regular expressions** sont des notations qui permettent de décrire des chaînes de caractères, d'en reconnaître, d'en manipuler. <|> regex
258 Mot inconnu : regular [[94:101]] => Les **expressions rationnelles**, souvent appelées **expressions régulières**, **regex** ou **regular expressions** sont des notations qui permettent de décrire des chaînes de caractères, d'en reconnaître, d'en manipuler. <|> regular

264 Mot inconnu : iconv [[29:34]] => Pour plus d'informations sur iconv, voir la page du manuel. Maintenant notre dictionnaire est /tmp/french.utf8 . <|> iconv

266 Il manque un espace à côté du tiret. [[47:49]] => Nous allons chercher les mots qui finissent par -er, pour cela on parcourt le fichier avec grep et on ne sort que les lignes finissant par -er : <|>  - => suggestions :  –  — 
266 Mot inconnu : er [[49:51]] => Nous allons chercher les mots qui finissent par -er, pour cela on parcourt le fichier avec grep et on ne sort que les lignes finissant par -er : <|> er
266 Il manque un espace à côté du tiret. [[138:140]] => Nous allons chercher les mots qui finissent par -er, pour cela on parcourt le fichier avec grep et on ne sort que les lignes finissant par -er : <|>  - => suggestions :  –  — 
266 Mot inconnu : er [[140:142]] => Nous allons chercher les mots qui finissent par -er, pour cela on parcourt le fichier avec grep et on ne sort que les lignes finissant par -er : <|> er

272 Mot inconnu : absol [[54:59]] => Maintenant on désire chercher les mots commençant par absol- : <|> absol

278 Mot inconnu : wildcard [[185:193]] => On cherche maintenant les mots de 4 caractères commençant et finissant par un t, pour cela on utilise l'opérateur "**.**" qui remplace n'importe quel caractère, il est parfois appelé **wildcard** :  <|> wildcard
278 Espace(s) en fin de ligne à supprimer. [[197:198]] => On cherche maintenant les mots de 4 caractères commençant et finissant par un t, pour cela on utilise l'opérateur "**.**" qui remplace n'importe quel caractère, il est parfois appelé **wildcard** :  <|>  

282 Guillemets typographiques ouvrants. [[41:42]] => Pour avoir exactement la ligne contenant "coucou", qui doit donc commencer et finir par coucou :  <|> " => suggestions : « “
282 Guillemets typographiques fermants. [[48:49]] => Pour avoir exactement la ligne contenant "coucou", qui doit donc commencer et finir par coucou :  <|> " => suggestions :  »”
282 Espace(s) en fin de ligne à supprimer. [[96:97]] => Pour avoir exactement la ligne contenant "coucou", qui doit donc commencer et finir par coucou :  <|>  
288 Guillemets typographiques ouvrants. [[73:74]] =>   * * représente **0 ou plus** caractères. Exemple : d* = 0 ou plus fois "d". <|> " => suggestions : « “
288 Guillemets typographiques fermants. [[75:76]] =>   * * représente **0 ou plus** caractères. Exemple : d* = 0 ou plus fois "d". <|> " => suggestions :  »”
289 Espace(s) en fin de ligne à supprimer. [[42:44]] =>   * + représente **1 ou plus** caractères.   <|>   

292 Guillemets typographiques ouvrants. [[52:53]] => Par exemple si l'on cherche les mots commençant par "t" et finissant par "tant" :  <|> " => suggestions : « “
292 Guillemets typographiques fermants. [[54:55]] => Par exemple si l'on cherche les mots commençant par "t" et finissant par "tant" :  <|> " => suggestions :  »”
292 Guillemets typographiques ouvrants. [[73:74]] => Par exemple si l'on cherche les mots commençant par "t" et finissant par "tant" :  <|> " => suggestions : « “
292 Guillemets typographiques fermants. [[78:79]] => Par exemple si l'on cherche les mots commençant par "t" et finissant par "tant" :  <|> " => suggestions :  »”
292 Espace(s) en fin de ligne à supprimer. [[81:82]] => Par exemple si l'on cherche les mots commençant par "t" et finissant par "tant" :  <|>  

296 Guillemets typographiques fermants. [[3:4]] => "^t" nous donne les mots commençant par "t", "tant$" prends ceux finissant par "tant" et au milieu on veut 0 ou plus fois n'importe quel caractère, donc le ".". <|> " => suggestions :  »”
296 Guillemets typographiques ouvrants. [[40:41]] => "^t" nous donne les mots commençant par "t", "tant$" prends ceux finissant par "tant" et au milieu on veut 0 ou plus fois n'importe quel caractère, donc le ".". <|> " => suggestions : « “
296 Guillemets typographiques fermants. [[42:43]] => "^t" nous donne les mots commençant par "t", "tant$" prends ceux finissant par "tant" et au milieu on veut 0 ou plus fois n'importe quel caractère, donc le ".". <|> " => suggestions :  »”
296 Guillemets typographiques ouvrants. [[45:46]] => "^t" nous donne les mots commençant par "t", "tant$" prends ceux finissant par "tant" et au milieu on veut 0 ou plus fois n'importe quel caractère, donc le ".". <|> " => suggestions : « “
296 Guillemets typographiques ouvrants. [[79:80]] => "^t" nous donne les mots commençant par "t", "tant$" prends ceux finissant par "tant" et au milieu on veut 0 ou plus fois n'importe quel caractère, donc le ".". <|> " => suggestions : « “
296 Guillemets typographiques fermants. [[84:85]] => "^t" nous donne les mots commençant par "t", "tant$" prends ceux finissant par "tant" et au milieu on veut 0 ou plus fois n'importe quel caractère, donc le ".". <|> " => suggestions :  »”
296 Guillemets fermants. [[155:157]] => "^t" nous donne les mots commençant par "t", "tant$" prends ceux finissant par "tant" et au milieu on veut 0 ou plus fois n'importe quel caractère, donc le ".". <|>  " => suggestions :  »”
296 Guillemets typographiques fermants. [[158:159]] => "^t" nous donne les mots commençant par "t", "tant$" prends ceux finissant par "tant" et au milieu on veut 0 ou plus fois n'importe quel caractère, donc le ".". <|> " => suggestions :  »”

298 Guillemets typographiques ouvrants. [[47:48]] => On veut maintenant chercher les mots contenant "m" ou "mm", pour cela on va utiliser une expression régulière étendue, il faudra donc utiliser l'option "-E" de grep :  <|> " => suggestions : « “
298 Guillemets typographiques fermants. [[49:50]] => On veut maintenant chercher les mots contenant "m" ou "mm", pour cela on va utiliser une expression régulière étendue, il faudra donc utiliser l'option "-E" de grep :  <|> " => suggestions :  »”
298 Guillemets typographiques ouvrants. [[54:55]] => On veut maintenant chercher les mots contenant "m" ou "mm", pour cela on va utiliser une expression régulière étendue, il faudra donc utiliser l'option "-E" de grep :  <|> " => suggestions : « “
298 Guillemets typographiques fermants. [[57:58]] => On veut maintenant chercher les mots contenant "m" ou "mm", pour cela on va utiliser une expression régulière étendue, il faudra donc utiliser l'option "-E" de grep :  <|> " => suggestions :  »”
298 Guillemets typographiques fermants. [[155:156]] => On veut maintenant chercher les mots contenant "m" ou "mm", pour cela on va utiliser une expression régulière étendue, il faudra donc utiliser l'option "-E" de grep :  <|> " => suggestions :  »”
298 Espace(s) en fin de ligne à supprimer. [[166:167]] => On veut maintenant chercher les mots contenant "m" ou "mm", pour cela on va utiliser une expression régulière étendue, il faudra donc utiliser l'option "-E" de grep :  <|>  

305 Il manque un espace à côté du tiret. [[156:158]] => >Les expressions régulières étendues se calculent moins rapidement que celles de bases, pour alléger les programmes elles sont regroupées et accessibles via -E. <|>  - => suggestions :  –  — 

307 Guillemets typographiques ouvrants. [[84:85]] => Pour être toujours plus fou, on veut maintenant trouver tous les noms finissant par "eux" ou "eut" pour créer des noms de domaines en ".eu". Pour cela on prend les mots qui commencent par n'importe quoi grâce à "^.*", puis qui terminent par "x" ou "t" grâce à "[xt]", tout ça avec "eu" au milieu bien sûr : <|> " => suggestions : « “
307 Guillemets typographiques fermants. [[88:89]] => Pour être toujours plus fou, on veut maintenant trouver tous les noms finissant par "eux" ou "eut" pour créer des noms de domaines en ".eu". Pour cela on prend les mots qui commencent par n'importe quoi grâce à "^.*", puis qui terminent par "x" ou "t" grâce à "[xt]", tout ça avec "eu" au milieu bien sûr : <|> " => suggestions :  »”
307 Guillemets typographiques ouvrants. [[93:94]] => Pour être toujours plus fou, on veut maintenant trouver tous les noms finissant par "eux" ou "eut" pour créer des noms de domaines en ".eu". Pour cela on prend les mots qui commencent par n'importe quoi grâce à "^.*", puis qui terminent par "x" ou "t" grâce à "[xt]", tout ça avec "eu" au milieu bien sûr : <|> " => suggestions : « “
307 Guillemets typographiques fermants. [[97:98]] => Pour être toujours plus fou, on veut maintenant trouver tous les noms finissant par "eux" ou "eut" pour créer des noms de domaines en ".eu". Pour cela on prend les mots qui commencent par n'importe quoi grâce à "^.*", puis qui terminent par "x" ou "t" grâce à "[xt]", tout ça avec "eu" au milieu bien sûr : <|> " => suggestions :  »”
307 Guillemets fermants. [[133:135]] => Pour être toujours plus fou, on veut maintenant trouver tous les noms finissant par "eux" ou "eut" pour créer des noms de domaines en ".eu". Pour cela on prend les mots qui commencent par n'importe quoi grâce à "^.*", puis qui terminent par "x" ou "t" grâce à "[xt]", tout ça avec "eu" au milieu bien sûr : <|>  " => suggestions :  »”
307 Guillemets typographiques fermants. [[138:139]] => Pour être toujours plus fou, on veut maintenant trouver tous les noms finissant par "eux" ou "eut" pour créer des noms de domaines en ".eu". Pour cela on prend les mots qui commencent par n'importe quoi grâce à "^.*", puis qui terminent par "x" ou "t" grâce à "[xt]", tout ça avec "eu" au milieu bien sûr : <|> " => suggestions :  »”
307 Guillemets typographiques ouvrants. [[241:242]] => Pour être toujours plus fou, on veut maintenant trouver tous les noms finissant par "eux" ou "eut" pour créer des noms de domaines en ".eu". Pour cela on prend les mots qui commencent par n'importe quoi grâce à "^.*", puis qui terminent par "x" ou "t" grâce à "[xt]", tout ça avec "eu" au milieu bien sûr : <|> " => suggestions : « “
307 Guillemets typographiques fermants. [[243:244]] => Pour être toujours plus fou, on veut maintenant trouver tous les noms finissant par "eux" ou "eut" pour créer des noms de domaines en ".eu". Pour cela on prend les mots qui commencent par n'importe quoi grâce à "^.*", puis qui terminent par "x" ou "t" grâce à "[xt]", tout ça avec "eu" au milieu bien sûr : <|> " => suggestions :  »”
307 Guillemets typographiques ouvrants. [[248:249]] => Pour être toujours plus fou, on veut maintenant trouver tous les noms finissant par "eux" ou "eut" pour créer des noms de domaines en ".eu". Pour cela on prend les mots qui commencent par n'importe quoi grâce à "^.*", puis qui terminent par "x" ou "t" grâce à "[xt]", tout ça avec "eu" au milieu bien sûr : <|> " => suggestions : « “
307 Guillemets typographiques fermants. [[250:251]] => Pour être toujours plus fou, on veut maintenant trouver tous les noms finissant par "eux" ou "eut" pour créer des noms de domaines en ".eu". Pour cela on prend les mots qui commencent par n'importe quoi grâce à "^.*", puis qui terminent par "x" ou "t" grâce à "[xt]", tout ça avec "eu" au milieu bien sûr : <|> " => suggestions :  »”
307 Mot inconnu : xt [[262:264]] => Pour être toujours plus fou, on veut maintenant trouver tous les noms finissant par "eux" ou "eut" pour créer des noms de domaines en ".eu". Pour cela on prend les mots qui commencent par n'importe quoi grâce à "^.*", puis qui terminent par "x" ou "t" grâce à "[xt]", tout ça avec "eu" au milieu bien sûr : <|> xt
307 Guillemets typographiques ouvrants. [[281:282]] => Pour être toujours plus fou, on veut maintenant trouver tous les noms finissant par "eux" ou "eut" pour créer des noms de domaines en ".eu". Pour cela on prend les mots qui commencent par n'importe quoi grâce à "^.*", puis qui terminent par "x" ou "t" grâce à "[xt]", tout ça avec "eu" au milieu bien sûr : <|> " => suggestions : « “
307 Guillemets typographiques fermants. [[284:285]] => Pour être toujours plus fou, on veut maintenant trouver tous les noms finissant par "eux" ou "eut" pour créer des noms de domaines en ".eu". Pour cela on prend les mots qui commencent par n'importe quoi grâce à "^.*", puis qui terminent par "x" ou "t" grâce à "[xt]", tout ça avec "eu" au milieu bien sûr : <|> " => suggestions :  »”
311 Guillemets typographiques ouvrants. [[123:124]] => On peut ainsi chercher les jeux pour KDE et pour GNOME, en supposant que tout jeu pour KDE qui se respecte commence par un "k" et par "g" pour GNOME. Pour cela on cherche tous les jeux, et on ne garde que ceux qui commencent par "k" ou "g" : <|> " => suggestions : « “
311 Guillemets typographiques fermants. [[125:126]] => On peut ainsi chercher les jeux pour KDE et pour GNOME, en supposant que tout jeu pour KDE qui se respecte commence par un "k" et par "g" pour GNOME. Pour cela on cherche tous les jeux, et on ne garde que ceux qui commencent par "k" ou "g" : <|> " => suggestions :  »”
311 Guillemets typographiques ouvrants. [[134:135]] => On peut ainsi chercher les jeux pour KDE et pour GNOME, en supposant que tout jeu pour KDE qui se respecte commence par un "k" et par "g" pour GNOME. Pour cela on cherche tous les jeux, et on ne garde que ceux qui commencent par "k" ou "g" : <|> " => suggestions : « “
311 Guillemets typographiques fermants. [[136:137]] => On peut ainsi chercher les jeux pour KDE et pour GNOME, en supposant que tout jeu pour KDE qui se respecte commence par un "k" et par "g" pour GNOME. Pour cela on cherche tous les jeux, et on ne garde que ceux qui commencent par "k" ou "g" : <|> " => suggestions :  »”
311 Guillemets typographiques ouvrants. [[229:230]] => On peut ainsi chercher les jeux pour KDE et pour GNOME, en supposant que tout jeu pour KDE qui se respecte commence par un "k" et par "g" pour GNOME. Pour cela on cherche tous les jeux, et on ne garde que ceux qui commencent par "k" ou "g" : <|> " => suggestions : « “
311 Guillemets typographiques fermants. [[231:232]] => On peut ainsi chercher les jeux pour KDE et pour GNOME, en supposant que tout jeu pour KDE qui se respecte commence par un "k" et par "g" pour GNOME. Pour cela on cherche tous les jeux, et on ne garde que ceux qui commencent par "k" ou "g" : <|> " => suggestions :  »”
311 Guillemets typographiques ouvrants. [[236:237]] => On peut ainsi chercher les jeux pour KDE et pour GNOME, en supposant que tout jeu pour KDE qui se respecte commence par un "k" et par "g" pour GNOME. Pour cela on cherche tous les jeux, et on ne garde que ceux qui commencent par "k" ou "g" : <|> " => suggestions : « “
311 Guillemets typographiques fermants. [[238:239]] => On peut ainsi chercher les jeux pour KDE et pour GNOME, en supposant que tout jeu pour KDE qui se respecte commence par un "k" et par "g" pour GNOME. Pour cela on cherche tous les jeux, et on ne garde que ceux qui commencent par "k" ou "g" : <|> " => suggestions :  »”

315 Guillemets typographiques ouvrants. [[62:63]] => Maintenant on veut chercher les jeux qui ne commencent ni par "g" ni par "k" : <|> " => suggestions : « “
315 Guillemets typographiques fermants. [[64:65]] => Maintenant on veut chercher les jeux qui ne commencent ni par "g" ni par "k" : <|> " => suggestions :  »”
315 Guillemets typographiques ouvrants. [[73:74]] => Maintenant on veut chercher les jeux qui ne commencent ni par "g" ni par "k" : <|> " => suggestions : « “
315 Guillemets typographiques fermants. [[75:76]] => Maintenant on veut chercher les jeux qui ne commencent ni par "g" ni par "k" : <|> " => suggestions :  »”

319 Mot inconnu : gk [[23:25]] => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition. <|> gk
319 Guillemets typographiques ouvrants. [[59:60]] => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition. <|> " => suggestions : « “
319 Guillemets typographiques fermants. [[61:62]] => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition. <|> " => suggestions :  »”
319 Guillemets typographiques ouvrants. [[69:70]] => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition. <|> " => suggestions : « “
319 Guillemets typographiques fermants. [[71:72]] => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition. <|> " => suggestions :  »”
319 Conjugaison erronée. Accord avec “on”. Le verbe devrait être à la 3ᵉ personne du singulier. [[142:148]] => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition. <|> prends => suggestions : prend
319 Guillemets typographiques ouvrants. [[179:180]] => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition. <|> " => suggestions : « “
319 Guillemets typographiques fermants. [[181:182]] => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition. <|> " => suggestions :  »”
319 Guillemets typographiques ouvrants. [[190:191]] => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition. <|> " => suggestions : « “
319 Guillemets typographiques fermants. [[192:193]] => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition. <|> " => suggestions :  »”
319 Guillemets fermants. [[207:209]] => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition. <|>  " => suggestions :  »”
319 Guillemets typographiques ouvrants. [[376:377]] => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition. <|> " => suggestions : « “
319 Mot inconnu : lib [[377:380]] => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition. <|> lib
319 Guillemets typographiques fermants. [[380:381]] => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition. <|> " => suggestions :  »”
319 Il manque un espace à côté du tiret. [[398:400]] => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition. <|>  - => suggestions :  –  — 

325 Guillemets typographiques ouvrants. [[74:75]] => Les parenthèses permettent d'isoler un regroupement, et le | correspond à "où". Ceci renvoie donc les fichiers/dossiers à la racine commençant par media ou mroot. <|> " => suggestions : « “
325 Guillemets typographiques fermants. [[77:78]] => Les parenthèses permettent d'isoler un regroupement, et le | correspond à "où". Ceci renvoie donc les fichiers/dossiers à la racine commençant par media ou mroot. <|> " => suggestions :  »”
325 Mot inconnu : mroot [[156:161]] => Les parenthèses permettent d'isoler un regroupement, et le | correspond à "où". Ceci renvoie donc les fichiers/dossiers à la racine commençant par media ou mroot. <|> mroot
327 Espace(s) en fin de ligne à supprimer. [[11:12]] => Alors que :  <|>  

333 Mot inconnu : Sed [[5:8]] => ==== Sed ==== <|> sed
338 Mot inconnu : premiere [[23:31]] => Ex : Pour remplacer la premiere occurence : <|> premiere
338 Mot inconnu : occurence [[32:41]] => Ex : Pour remplacer la premiere occurence : <|> occurence

346 Guillemets fermants. [[14:16]] => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".".  <|>  " => suggestions :  »”
346 Guillemets typographiques fermants. [[17:18]] => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".".  <|> " => suggestions :  »”
346 Guillemets isolés. [[22:25]] => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".".  <|>  "  => suggestions :  «  “ » ” 
346 Mot inconnu : pOiNt [[25:30]] => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".".  <|> point
346 Guillemets isolés. [[30:33]] => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".".  <|>  "  => suggestions :  «  “ » ” 
346 Guillemets isolés. [[46:49]] => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".".  <|>  "  => suggestions :  «  “ » ” 
346 Mot inconnu : at [[49:51]] => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".".  <|> at
346 Guillemets fermants. [[51:53]] => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".".  <|>  " => suggestions :  »”
346 Guillemets fermants. [[95:97]] => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".".  <|>  " => suggestions :  »”
346 Guillemets typographiques fermants. [[98:99]] => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".".  <|> " => suggestions :  »”
346 Guillemets fermants. [[143:145]] => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".".  <|>  " => suggestions :  »”
346 Guillemets typographiques fermants. [[146:147]] => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".".  <|> " => suggestions :  »”
346 Guillemets fermants. [[186:188]] => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".".  <|>  " => suggestions :  »”
346 Guillemets typographiques fermants. [[189:190]] => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".".  <|> " => suggestions :  »”
346 Espace(s) en fin de ligne à supprimer. [[191:192]] => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".".  <|>  

348 Guillemets typographiques ouvrants. [[37:38]] => De même si on veut remplacer "/" par "slash", on utiliserait <|> " => suggestions : « “
348 Guillemets typographiques fermants. [[43:44]] => De même si on veut remplacer "/" par "slash", on utiliserait <|> " => suggestions :  »”

352 Mot inconnu : sed [[74:77]] => On peut faire la même chose en moins long en utilisant l'autre version de sed: <|> sed

356 Erreur d’accord probable avec “les”. [[5:10]] => Pour toute les occurrences ,on peut aussi utiliser : <|> toute => suggestions : toutes
356 Pas d’espace avant une virgule. Un espace après. [[26:28]] => Pour toute les occurrences ,on peut aussi utiliser : <|>  , => suggestions : , 

358 Mot inconnu : oû [[0:2]] => oû : <|> oû

367 Guillemets typographiques ouvrants. [[34:35]] => Ceci remplace toute occurrence de "kikoo" par "#kikoolol" dans le fichier /etc/config.txt mais ne le modifie pas, le résultat est donné sur la sortie standard. Pour modifier le fichier il faut ajouter l'option -i à sed. <|> " => suggestions : « “
367 Mot inconnu : kikoo [[35:40]] => Ceci remplace toute occurrence de "kikoo" par "#kikoolol" dans le fichier /etc/config.txt mais ne le modifie pas, le résultat est donné sur la sortie standard. Pour modifier le fichier il faut ajouter l'option -i à sed. <|> kikoo
367 Guillemets typographiques fermants. [[40:41]] => Ceci remplace toute occurrence de "kikoo" par "#kikoolol" dans le fichier /etc/config.txt mais ne le modifie pas, le résultat est donné sur la sortie standard. Pour modifier le fichier il faut ajouter l'option -i à sed. <|> " => suggestions :  »”
367 Guillemets typographiques fermants. [[56:57]] => Ceci remplace toute occurrence de "kikoo" par "#kikoolol" dans le fichier /etc/config.txt mais ne le modifie pas, le résultat est donné sur la sortie standard. Pour modifier le fichier il faut ajouter l'option -i à sed. <|> " => suggestions :  »”
367 Il manque un espace à côté du tiret. [[209:211]] => Ceci remplace toute occurrence de "kikoo" par "#kikoolol" dans le fichier /etc/config.txt mais ne le modifie pas, le résultat est donné sur la sortie standard. Pour modifier le fichier il faut ajouter l'option -i à sed. <|>  - => suggestions :  –  — 
367 Mot inconnu : sed [[215:218]] => Ceci remplace toute occurrence de "kikoo" par "#kikoolol" dans le fichier /etc/config.txt mais ne le modifie pas, le résultat est donné sur la sortie standard. Pour modifier le fichier il faut ajouter l'option -i à sed. <|> sed
373 Espace(s) en fin de ligne à supprimer. [[7:8]] => Donne :  <|>  

377 Typographie : points de suspension. Utilisez le caractère dédié. [[46:49]] => <note warning>l'action de l'option /n (n=1,2,3...) et /g sur un fichier n'est pas identique <|> ... => suggestions : …
381 Espace(s) en fin de ligne à supprimer. [[28:30]] => c'est pas clair : un exemple   <|>   

383 Mot inconnu : fichier1 [[3:11]] => le fichier1 contient 3 lignes identiques kikoo <|> fichier1
383 Mot inconnu : kikoo [[41:46]] => le fichier1 contient 3 lignes identiques kikoo <|> kikoo

385 Mot inconnu : fichier2 [[3:11]] => le fichier2 contient kikookikookikoo et 2 lignes kikoo <|> fichier2
385 Mot inconnu : kikookikookikoo [[21:36]] => le fichier2 contient kikookikookikoo et 2 lignes kikoo <|> kikookikookikoo
385 Mot inconnu : kikoo [[49:54]] => le fichier2 contient kikookikookikoo et 2 lignes kikoo <|> kikoo

388 Mot inconnu : sed [[0:3]] => sed -i 's/kikoo/#kikoo/2 : <|> sed
388 Il manque un espace à côté du tiret. [[3:5]] => sed -i 's/kikoo/#kikoo/2 : <|>  - => suggestions :  –  — 
388 Guillemets typographiques ouvrants. [[7:8]] => sed -i 's/kikoo/#kikoo/2 : <|> ' => suggestions : ‘“‹
388 Mot inconnu : kikoo [[10:15]] => sed -i 's/kikoo/#kikoo/2 : <|> kikoo

390 Mot inconnu : fichier1 [[3:11]] => le fichier1 n'est pas modifié ! <|> fichier1

391 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). [[0:1]] =>   <|>  

392 Mot inconnu : kikoo [[21:26]] => le fichier 2 devient kikoo#kikookikoo les 2 autres lignes ne sont pas modifiées              <|> kikoo
392 Espace(s) en fin de ligne à supprimer. [[79:92]] => le fichier 2 devient kikoo#kikookikoo les 2 autres lignes ne sont pas modifiées              <|>              

395 Espace(s) en fin de ligne à supprimer. [[11:12]] => résultat de  <|>  

396 Mot inconnu : sed [[0:3]] => sed -i 's/kikoo/#kikoo/g  : les deux fichiers sont modifiés   <|> sed
396 Il manque un espace à côté du tiret. [[3:5]] => sed -i 's/kikoo/#kikoo/g  : les deux fichiers sont modifiés   <|>  - => suggestions :  –  — 
396 Guillemets typographiques ouvrants. [[7:8]] => sed -i 's/kikoo/#kikoo/g  : les deux fichiers sont modifiés   <|> ' => suggestions : ‘“‹
396 Mot inconnu : kikoo [[10:15]] => sed -i 's/kikoo/#kikoo/g  : les deux fichiers sont modifiés   <|> kikoo
396 Espace(s) surnuméraire(s) à supprimer. [[24:26]] => sed -i 's/kikoo/#kikoo/g  : les deux fichiers sont modifiés   <|>    => suggestions :  
396 Espace(s) en fin de ligne à supprimer. [[59:61]] => sed -i 's/kikoo/#kikoo/g  : les deux fichiers sont modifiés   <|>   

398 Mot inconnu : kikoo [[9:14]] => tous les kikoo deviennent #kikoo  <|> kikoo
398 Espace(s) en fin de ligne à supprimer. [[32:33]] => tous les kikoo deviennent #kikoo  <|>  

403 Mot inconnu : sed [[60:63]] => Nous allons maintenant voir l'utilisation de variables avec sed ce qui permet d'échanger, de déplacer des parties d'une chaîne de caractères. Exemple :  <|> sed
403 Espace(s) en fin de ligne à supprimer. [[151:152]] => Nous allons maintenant voir l'utilisation de variables avec sed ce qui permet d'échanger, de déplacer des parties d'une chaîne de caractères. Exemple :  <|>  

407 Guillemets typographiques fermants. [[118:119]] => (.*) représente l'affectation des variables et \n la n-ième variable, ici on met donc ce qu'il y a avant le point ("\.") dans \1 et ce qu'il y a après dans \2 puis on met \2 devant \1, on obtient : <|> " => suggestions :  »”
411 Mot inconnu : Knoklezout_au_taquet-Jamendo-David_TMX [[134:172]] => Pour terminer nous allons voir un exemple pratique : nous avons de nombreux dossiers contenant de nombreux mp3 nommés selon le schéma Knoklezout_au_taquet-Jamendo-David_TMX.mp3 et on désire avoir le nom d'artiste avant le titre de la chanson tout en enlevant la publicité pour Jamendo.  <|> knoklezout_au_taquet-jamendo-david_tmx
411 Espace(s) en fin de ligne à supprimer. [[285:286]] => Pour terminer nous allons voir un exemple pratique : nous avons de nombreux dossiers contenant de nombreux mp3 nommés selon le schéma Knoklezout_au_taquet-Jamendo-David_TMX.mp3 et on désire avoir le nom d'artiste avant le titre de la chanson tout en enlevant la publicité pour Jamendo.  <|>  

413 Mot inconnu : rename [[33:39]] => Pour cela nous allons utiliser **rename** (qui vient avec perl) et nos chères expressions régulières : <|> rename
413 Mot inconnu : perl [[58:62]] => Pour cela nous allons utiliser **rename** (qui vient avec perl) et nos chères expressions régulières : <|> perl

417 Mot inconnu : sed [[32:35]] => Le principe est le même qu'avec sed sauf que les variables sont notées $n et non plus \n : on met ce qu'il y a avant "-Jamendo-" dans $1 et ce qu'il y a après (".mp3" non compris) dans $2 puis on formate comme on le veut. <|> sed
417 Guillemets typographiques fermants. [[165:166]] => Le principe est le même qu'avec sed sauf que les variables sont notées $n et non plus \n : on met ce qu'il y a avant "-Jamendo-" dans $1 et ce qu'il y a après (".mp3" non compris) dans $2 puis on formate comme on le veut. <|> " => suggestions :  »”

419 Mot inconnu : rename [[2:8]] => **rename** renomme les fichiers dans le dossier courant, pour plus de sécurité on peut utiliser ** rename -n 's/'** qui nous affiche les changements sans les effectuer, puis les effectuer une fois que l'on est sûr. <|> rename
419 Mot inconnu : rename [[99:105]] => **rename** renomme les fichiers dans le dossier courant, pour plus de sécurité on peut utiliser ** rename -n 's/'** qui nous affiche les changements sans les effectuer, puis les effectuer une fois que l'on est sûr. <|> rename
419 Il manque un espace à côté du tiret. [[105:107]] => **rename** renomme les fichiers dans le dossier courant, pour plus de sécurité on peut utiliser ** rename -n 's/'** qui nous affiche les changements sans les effectuer, puis les effectuer une fois que l'on est sûr. <|>  - => suggestions :  –  — 
419 Guillemets typographiques ouvrants. [[109:110]] => **rename** renomme les fichiers dans le dossier courant, pour plus de sécurité on peut utiliser ** rename -n 's/'** qui nous affiche les changements sans les effectuer, puis les effectuer une fois que l'on est sûr. <|> ' => suggestions : ‘“‹

423 Mot inconnu : regexp [[47:53]] => Une introduction à Perl et une introduction au regexp : <|> regexp

426 Mot inconnu : regexp [[73:79]] => Le livre de référence (édition 1) de Ruby avec une petite partie sur les regexp <|> regexp

429 Mot inconnu : FSUG [[44:48]] => Une introduction rapide réalisée dans notre FSUG (merci à Krunch) : <|> fsug
429 Mot inconnu : Krunch [[58:64]] => Une introduction rapide réalisée dans notre FSUG (merci à Krunch) : <|> krunch

436 Pas d’espace avant une virgule. [[57:59]] => >Les expressions régulières sont utilisés en Python, Perl , Ruby, PHP, Java, C, C++, par des programmes comme sed, awk, grep, vim, rename, ou encore des filtres dans apache et lighttpd ( mod_rewrite, vhosts ...), adblock dans firefox... Cette liste est bien sûr non exhaustive.     <|>  , => suggestions : ,
436 Mot inconnu : sed [[110:113]] => >Les expressions régulières sont utilisés en Python, Perl , Ruby, PHP, Java, C, C++, par des programmes comme sed, awk, grep, vim, rename, ou encore des filtres dans apache et lighttpd ( mod_rewrite, vhosts ...), adblock dans firefox... Cette liste est bien sûr non exhaustive.     <|> sed
436 Mot inconnu : awk [[115:118]] => >Les expressions régulières sont utilisés en Python, Perl , Ruby, PHP, Java, C, C++, par des programmes comme sed, awk, grep, vim, rename, ou encore des filtres dans apache et lighttpd ( mod_rewrite, vhosts ...), adblock dans firefox... Cette liste est bien sûr non exhaustive.     <|> awk
436 Mot inconnu : rename [[131:137]] => >Les expressions régulières sont utilisés en Python, Perl , Ruby, PHP, Java, C, C++, par des programmes comme sed, awk, grep, vim, rename, ou encore des filtres dans apache et lighttpd ( mod_rewrite, vhosts ...), adblock dans firefox... Cette liste est bien sûr non exhaustive.     <|> rename
436 Mot inconnu : lighttpd [[176:184]] => >Les expressions régulières sont utilisés en Python, Perl , Ruby, PHP, Java, C, C++, par des programmes comme sed, awk, grep, vim, rename, ou encore des filtres dans apache et lighttpd ( mod_rewrite, vhosts ...), adblock dans firefox... Cette liste est bien sûr non exhaustive.     <|> lighttpd
436 Pas d’espace après ce signe. [[185:187]] => >Les expressions régulières sont utilisés en Python, Perl , Ruby, PHP, Java, C, C++, par des programmes comme sed, awk, grep, vim, rename, ou encore des filtres dans apache et lighttpd ( mod_rewrite, vhosts ...), adblock dans firefox... Cette liste est bien sûr non exhaustive.     <|> (  => suggestions : (
436 Mot inconnu : mod_rewrite [[187:198]] => >Les expressions régulières sont utilisés en Python, Perl , Ruby, PHP, Java, C, C++, par des programmes comme sed, awk, grep, vim, rename, ou encore des filtres dans apache et lighttpd ( mod_rewrite, vhosts ...), adblock dans firefox... Cette liste est bien sûr non exhaustive.     <|> mod_rewrite
436 Mot inconnu : vhosts [[200:206]] => >Les expressions régulières sont utilisés en Python, Perl , Ruby, PHP, Java, C, C++, par des programmes comme sed, awk, grep, vim, rename, ou encore des filtres dans apache et lighttpd ( mod_rewrite, vhosts ...), adblock dans firefox... Cette liste est bien sûr non exhaustive.     <|> vhosts
436 Typographie : points de suspension. Utilisez le caractère dédié. [[207:210]] => >Les expressions régulières sont utilisés en Python, Perl , Ruby, PHP, Java, C, C++, par des programmes comme sed, awk, grep, vim, rename, ou encore des filtres dans apache et lighttpd ( mod_rewrite, vhosts ...), adblock dans firefox... Cette liste est bien sûr non exhaustive.     <|> ... => suggestions : …
436 Mot inconnu : adblock [[213:220]] => >Les expressions régulières sont utilisés en Python, Perl , Ruby, PHP, Java, C, C++, par des programmes comme sed, awk, grep, vim, rename, ou encore des filtres dans apache et lighttpd ( mod_rewrite, vhosts ...), adblock dans firefox... Cette liste est bien sûr non exhaustive.     <|> adblock
436 Typographie : points de suspension. Utilisez le caractère dédié. [[233:236]] => >Les expressions régulières sont utilisés en Python, Perl , Ruby, PHP, Java, C, C++, par des programmes comme sed, awk, grep, vim, rename, ou encore des filtres dans apache et lighttpd ( mod_rewrite, vhosts ...), adblock dans firefox... Cette liste est bien sûr non exhaustive.     <|> ... => suggestions : …
436 Espace(s) en fin de ligne à supprimer. [[277:281]] => >Les expressions régulières sont utilisés en Python, Perl , Ruby, PHP, Java, C, C++, par des programmes comme sed, awk, grep, vim, rename, ou encore des filtres dans apache et lighttpd ( mod_rewrite, vhosts ...), adblock dans firefox... Cette liste est bien sûr non exhaustive.     <|>     
