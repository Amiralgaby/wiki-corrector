
4 Mot inconnu : Multithreading => ====== Multithreading - Optimiser l'utilisation des ordinateurs multi-cores, multi-processeurs et Hyper Threading ====== | multithreading
4 Tiret d’incise : un tiret demi-cadratin [1] ou cadratin [2] est requis. (Ou éventuellement le signe “moins” [3], s’il s’agit d’une soustraction.) => ====== Multithreading - Optimiser l'utilisation des ordinateurs multi-cores, multi-processeurs et Hyper Threading ====== |  -  => suggestions : [' – ', ' — ', ' − ']
4 Mot inconnu : multi-cores => ====== Multithreading - Optimiser l'utilisation des ordinateurs multi-cores, multi-processeurs et Hyper Threading ====== | multi-cores
4 Mot inconnu : Threading => ====== Multithreading - Optimiser l'utilisation des ordinateurs multi-cores, multi-processeurs et Hyper Threading ====== | threading

6 S’il s’agit d’une action à accomplir, le verbe devrait être à l’infinitif. => De nos jours les ordinateurs disposent quasiment tous de la possibilité de faire tourner au moins deux threads (tâches systèmes) en même temps. La première fois que le grand public a entendu parlé de cette fonctionnalité c'était avec le Pentium 4 HT. Le Pentium 4 HT n'est pas à proprement parler un processeur optimisé pour ce genre de processus, il ne dispose d'ailleurs que d'un seul cœur d'exécution. Mais depuis les Pentium D, Core Duo, Core 2 Duo et Quad, Athlon 64 X2 ainsi que presque tous les processeurs plus récents, les processeurs sont vraiment significativement plus puissants en utilisation multithreads. | parlé => suggestions : ['parler']
6 Mot inconnu : Pentium => De nos jours les ordinateurs disposent quasiment tous de la possibilité de faire tourner au moins deux threads (tâches systèmes) en même temps. La première fois que le grand public a entendu parlé de cette fonctionnalité c'était avec le Pentium 4 HT. Le Pentium 4 HT n'est pas à proprement parler un processeur optimisé pour ce genre de processus, il ne dispose d'ailleurs que d'un seul cœur d'exécution. Mais depuis les Pentium D, Core Duo, Core 2 Duo et Quad, Athlon 64 X2 ainsi que presque tous les processeurs plus récents, les processeurs sont vraiment significativement plus puissants en utilisation multithreads. | pentium
6 Mot inconnu : Pentium => De nos jours les ordinateurs disposent quasiment tous de la possibilité de faire tourner au moins deux threads (tâches systèmes) en même temps. La première fois que le grand public a entendu parlé de cette fonctionnalité c'était avec le Pentium 4 HT. Le Pentium 4 HT n'est pas à proprement parler un processeur optimisé pour ce genre de processus, il ne dispose d'ailleurs que d'un seul cœur d'exécution. Mais depuis les Pentium D, Core Duo, Core 2 Duo et Quad, Athlon 64 X2 ainsi que presque tous les processeurs plus récents, les processeurs sont vraiment significativement plus puissants en utilisation multithreads. | pentium
6 Mot inconnu : Pentium => De nos jours les ordinateurs disposent quasiment tous de la possibilité de faire tourner au moins deux threads (tâches systèmes) en même temps. La première fois que le grand public a entendu parlé de cette fonctionnalité c'était avec le Pentium 4 HT. Le Pentium 4 HT n'est pas à proprement parler un processeur optimisé pour ce genre de processus, il ne dispose d'ailleurs que d'un seul cœur d'exécution. Mais depuis les Pentium D, Core Duo, Core 2 Duo et Quad, Athlon 64 X2 ainsi que presque tous les processeurs plus récents, les processeurs sont vraiment significativement plus puissants en utilisation multithreads. | pentium
6 Mot inconnu : Core => De nos jours les ordinateurs disposent quasiment tous de la possibilité de faire tourner au moins deux threads (tâches systèmes) en même temps. La première fois que le grand public a entendu parlé de cette fonctionnalité c'était avec le Pentium 4 HT. Le Pentium 4 HT n'est pas à proprement parler un processeur optimisé pour ce genre de processus, il ne dispose d'ailleurs que d'un seul cœur d'exécution. Mais depuis les Pentium D, Core Duo, Core 2 Duo et Quad, Athlon 64 X2 ainsi que presque tous les processeurs plus récents, les processeurs sont vraiment significativement plus puissants en utilisation multithreads. | core
6 Mot inconnu : Core => De nos jours les ordinateurs disposent quasiment tous de la possibilité de faire tourner au moins deux threads (tâches systèmes) en même temps. La première fois que le grand public a entendu parlé de cette fonctionnalité c'était avec le Pentium 4 HT. Le Pentium 4 HT n'est pas à proprement parler un processeur optimisé pour ce genre de processus, il ne dispose d'ailleurs que d'un seul cœur d'exécution. Mais depuis les Pentium D, Core Duo, Core 2 Duo et Quad, Athlon 64 X2 ainsi que presque tous les processeurs plus récents, les processeurs sont vraiment significativement plus puissants en utilisation multithreads. | core
6 Accord de nombre erroné avec « 2 » : « Duo » devrait être au pluriel. => De nos jours les ordinateurs disposent quasiment tous de la possibilité de faire tourner au moins deux threads (tâches systèmes) en même temps. La première fois que le grand public a entendu parlé de cette fonctionnalité c'était avec le Pentium 4 HT. Le Pentium 4 HT n'est pas à proprement parler un processeur optimisé pour ce genre de processus, il ne dispose d'ailleurs que d'un seul cœur d'exécution. Mais depuis les Pentium D, Core Duo, Core 2 Duo et Quad, Athlon 64 X2 ainsi que presque tous les processeurs plus récents, les processeurs sont vraiment significativement plus puissants en utilisation multithreads. | duo => suggestions : ['Duos']
6 Mot inconnu : Athlon => De nos jours les ordinateurs disposent quasiment tous de la possibilité de faire tourner au moins deux threads (tâches systèmes) en même temps. La première fois que le grand public a entendu parlé de cette fonctionnalité c'était avec le Pentium 4 HT. Le Pentium 4 HT n'est pas à proprement parler un processeur optimisé pour ce genre de processus, il ne dispose d'ailleurs que d'un seul cœur d'exécution. Mais depuis les Pentium D, Core Duo, Core 2 Duo et Quad, Athlon 64 X2 ainsi que presque tous les processeurs plus récents, les processeurs sont vraiment significativement plus puissants en utilisation multithreads. | athlon
6 Mot inconnu : X2 => De nos jours les ordinateurs disposent quasiment tous de la possibilité de faire tourner au moins deux threads (tâches systèmes) en même temps. La première fois que le grand public a entendu parlé de cette fonctionnalité c'était avec le Pentium 4 HT. Le Pentium 4 HT n'est pas à proprement parler un processeur optimisé pour ce genre de processus, il ne dispose d'ailleurs que d'un seul cœur d'exécution. Mais depuis les Pentium D, Core Duo, Core 2 Duo et Quad, Athlon 64 X2 ainsi que presque tous les processeurs plus récents, les processeurs sont vraiment significativement plus puissants en utilisation multithreads. | x2
6 Mot inconnu : multithreads => De nos jours les ordinateurs disposent quasiment tous de la possibilité de faire tourner au moins deux threads (tâches systèmes) en même temps. La première fois que le grand public a entendu parlé de cette fonctionnalité c'était avec le Pentium 4 HT. Le Pentium 4 HT n'est pas à proprement parler un processeur optimisé pour ce genre de processus, il ne dispose d'ailleurs que d'un seul cœur d'exécution. Mais depuis les Pentium D, Core Duo, Core 2 Duo et Quad, Athlon 64 X2 ainsi que presque tous les processeurs plus récents, les processeurs sont vraiment significativement plus puissants en utilisation multithreads. | multithreads

10 Espace(s) en fin de ligne à supprimer. => Il existe deux types de cœurs d'exécution dans les processeurs actuels, les cœurs physiques et virtuels.  |   => suggestions : ['']

14 Mot inconnu : multithreads => Cette page se fera un plaisir de recenser les différents programmes à préférer si vous utilisez un processeur multithreads pour obtenir les meilleurs performances. Elle regroupera aussi quelques trucs et astuces à connaitre pour améliorer les performances de programmes qui n'utilisent pas à l'origine plusieurs threads mais dont vous pouvez activer la fonctionnalité par une légère modification. | multithreads
14 Accord de genre erroné avec « performances ». => Cette page se fera un plaisir de recenser les différents programmes à préférer si vous utilisez un processeur multithreads pour obtenir les meilleurs performances. Elle regroupera aussi quelques trucs et astuces à connaitre pour améliorer les performances de programmes qui n'utilisent pas à l'origine plusieurs threads mais dont vous pouvez activer la fonctionnalité par une légère modification. | meilleurs => suggestions : ['meilleures']
14 Accord de genre erroné entre « meilleurs » et « performances ». => Cette page se fera un plaisir de recenser les différents programmes à préférer si vous utilisez un processeur multithreads pour obtenir les meilleurs performances. Elle regroupera aussi quelques trucs et astuces à connaitre pour améliorer les performances de programmes qui n'utilisent pas à l'origine plusieurs threads mais dont vous pouvez activer la fonctionnalité par une légère modification. | performances => suggestions : []

16 Mot inconnu : multithreading => Si le programme doit être configuré pour utiliser le multithreading, la méthode est disponible sur la page du programme de ce wiki. La liste vous indiquera si oui on non il y a besoin d'une intervention de votre part. | multithreading
16 Incohérence avec “on” : “non” devrait être un verbe, un pronom objet, un adverbe de négation, etc. => Si le programme doit être configuré pour utiliser le multithreading, la méthode est disponible sur la page du programme de ce wiki. La liste vous indiquera si oui on non il y a besoin d'une intervention de votre part. | non => suggestions : []

18 Mot inconnu : multithreads => ===== Programmes multithreads ===== | multithreads

31 Mot inconnu : Make => === Make === | make

33 Mot inconnu : Make => Make permet la compilation en multithreads, il suffit d'exprimer votre commande comme ceci: | make
33 Mot inconnu : multithreads => Make permet la compilation en multithreads, il suffit d'exprimer votre commande comme ceci: | multithreads

38 Mot inconnu : make => Attention toutefois à bien préciser le nombre de threads, sans quoi make considèrera le nombre de ces derniers comme illimité et votre ordinateur se mettra alors rapidement à ne plus répondre.  | make
38 Espace(s) en fin de ligne à supprimer. => Attention toutefois à bien préciser le nombre de threads, sans quoi make considèrera le nombre de ces derniers comme illimité et votre ordinateur se mettra alors rapidement à ne plus répondre.  |   => suggestions : ['']

51 Mot inconnu : Handbrake => <note>[[Handbrake]] semble utiliser le multithreading puisque, avec 4 coeurs, il les utilise tous à 100% sans activation manuelle.</note> | handbrake
51 Mot inconnu : multithreading => <note>[[Handbrake]] semble utiliser le multithreading puisque, avec 4 coeurs, il les utilise tous à 100% sans activation manuelle.</note> | multithreading
51 Mot inconnu : coeurs => <note>[[Handbrake]] semble utiliser le multithreading puisque, avec 4 coeurs, il les utilise tous à 100% sans activation manuelle.</note> | coeurs

62 Pléonasme. => Je suppose quand même au vu des architectures utilisées dans les serveurs web que la très grande majorité des serveurs comme [[Apache]] par exemple sont parfaitement bien optimisés. | comme [[apache]] par exemple => suggestions : ['comme', 'par exemple']

63 Guillemets typographiques ouvrants. => <note tip>Le "moteur" d'apache s'appelle le MPM. Il en existe 2 versions //worker// et //pre-fork//. Les deux créent plusieurs processus fils (donc les coeurs sont exploités) mais worker est, en plus, multi-threadé ; donc plus performant. La contrepartie c'est qu'il n'est plus compatible avec les librairies non thread-safe... comme le célèbre **module PHP**. Vous devrez utiliser un //cluster// interpréteurs en remplacement, comme PHP-FPM. Si vous faites la course à l'optimisation, regardez carrément l'étoile montante : **nginx**</note> | " => suggestions : ['«\xa0', '“']
63 Guillemets typographiques fermants. => <note tip>Le "moteur" d'apache s'appelle le MPM. Il en existe 2 versions //worker// et //pre-fork//. Les deux créent plusieurs processus fils (donc les coeurs sont exploités) mais worker est, en plus, multi-threadé ; donc plus performant. La contrepartie c'est qu'il n'est plus compatible avec les librairies non thread-safe... comme le célèbre **module PHP**. Vous devrez utiliser un //cluster// interpréteurs en remplacement, comme PHP-FPM. Si vous faites la course à l'optimisation, regardez carrément l'étoile montante : **nginx**</note> | " => suggestions : ['\xa0»', '”']
63 Mot inconnu : MPM => <note tip>Le "moteur" d'apache s'appelle le MPM. Il en existe 2 versions //worker// et //pre-fork//. Les deux créent plusieurs processus fils (donc les coeurs sont exploités) mais worker est, en plus, multi-threadé ; donc plus performant. La contrepartie c'est qu'il n'est plus compatible avec les librairies non thread-safe... comme le célèbre **module PHP**. Vous devrez utiliser un //cluster// interpréteurs en remplacement, comme PHP-FPM. Si vous faites la course à l'optimisation, regardez carrément l'étoile montante : **nginx**</note> | mpm
63 Mot inconnu : worker => <note tip>Le "moteur" d'apache s'appelle le MPM. Il en existe 2 versions //worker// et //pre-fork//. Les deux créent plusieurs processus fils (donc les coeurs sont exploités) mais worker est, en plus, multi-threadé ; donc plus performant. La contrepartie c'est qu'il n'est plus compatible avec les librairies non thread-safe... comme le célèbre **module PHP**. Vous devrez utiliser un //cluster// interpréteurs en remplacement, comme PHP-FPM. Si vous faites la course à l'optimisation, regardez carrément l'étoile montante : **nginx**</note> | worker
63 Mot inconnu : pre-fork => <note tip>Le "moteur" d'apache s'appelle le MPM. Il en existe 2 versions //worker// et //pre-fork//. Les deux créent plusieurs processus fils (donc les coeurs sont exploités) mais worker est, en plus, multi-threadé ; donc plus performant. La contrepartie c'est qu'il n'est plus compatible avec les librairies non thread-safe... comme le célèbre **module PHP**. Vous devrez utiliser un //cluster// interpréteurs en remplacement, comme PHP-FPM. Si vous faites la course à l'optimisation, regardez carrément l'étoile montante : **nginx**</note> | pre-fork
63 Mot inconnu : coeurs => <note tip>Le "moteur" d'apache s'appelle le MPM. Il en existe 2 versions //worker// et //pre-fork//. Les deux créent plusieurs processus fils (donc les coeurs sont exploités) mais worker est, en plus, multi-threadé ; donc plus performant. La contrepartie c'est qu'il n'est plus compatible avec les librairies non thread-safe... comme le célèbre **module PHP**. Vous devrez utiliser un //cluster// interpréteurs en remplacement, comme PHP-FPM. Si vous faites la course à l'optimisation, regardez carrément l'étoile montante : **nginx**</note> | coeurs
63 Mot inconnu : worker => <note tip>Le "moteur" d'apache s'appelle le MPM. Il en existe 2 versions //worker// et //pre-fork//. Les deux créent plusieurs processus fils (donc les coeurs sont exploités) mais worker est, en plus, multi-threadé ; donc plus performant. La contrepartie c'est qu'il n'est plus compatible avec les librairies non thread-safe... comme le célèbre **module PHP**. Vous devrez utiliser un //cluster// interpréteurs en remplacement, comme PHP-FPM. Si vous faites la course à l'optimisation, regardez carrément l'étoile montante : **nginx**</note> | worker
63 Mot inconnu : multi-threadé => <note tip>Le "moteur" d'apache s'appelle le MPM. Il en existe 2 versions //worker// et //pre-fork//. Les deux créent plusieurs processus fils (donc les coeurs sont exploités) mais worker est, en plus, multi-threadé ; donc plus performant. La contrepartie c'est qu'il n'est plus compatible avec les librairies non thread-safe... comme le célèbre **module PHP**. Vous devrez utiliser un //cluster// interpréteurs en remplacement, comme PHP-FPM. Si vous faites la course à l'optimisation, regardez carrément l'étoile montante : **nginx**</note> | multi-threadé
63 Mot inconnu : thread-safe => <note tip>Le "moteur" d'apache s'appelle le MPM. Il en existe 2 versions //worker// et //pre-fork//. Les deux créent plusieurs processus fils (donc les coeurs sont exploités) mais worker est, en plus, multi-threadé ; donc plus performant. La contrepartie c'est qu'il n'est plus compatible avec les librairies non thread-safe... comme le célèbre **module PHP**. Vous devrez utiliser un //cluster// interpréteurs en remplacement, comme PHP-FPM. Si vous faites la course à l'optimisation, regardez carrément l'étoile montante : **nginx**</note> | thread-safe
63 Typographie : points de suspension. Utilisez le caractère dédié. => <note tip>Le "moteur" d'apache s'appelle le MPM. Il en existe 2 versions //worker// et //pre-fork//. Les deux créent plusieurs processus fils (donc les coeurs sont exploités) mais worker est, en plus, multi-threadé ; donc plus performant. La contrepartie c'est qu'il n'est plus compatible avec les librairies non thread-safe... comme le célèbre **module PHP**. Vous devrez utiliser un //cluster// interpréteurs en remplacement, comme PHP-FPM. Si vous faites la course à l'optimisation, regardez carrément l'étoile montante : **nginx**</note> | ... => suggestions : ['…']
63 Mot inconnu : PHP-FPM => <note tip>Le "moteur" d'apache s'appelle le MPM. Il en existe 2 versions //worker// et //pre-fork//. Les deux créent plusieurs processus fils (donc les coeurs sont exploités) mais worker est, en plus, multi-threadé ; donc plus performant. La contrepartie c'est qu'il n'est plus compatible avec les librairies non thread-safe... comme le célèbre **module PHP**. Vous devrez utiliser un //cluster// interpréteurs en remplacement, comme PHP-FPM. Si vous faites la course à l'optimisation, regardez carrément l'étoile montante : **nginx**</note> | php-fpm
63 Mot inconnu : nginx => <note tip>Le "moteur" d'apache s'appelle le MPM. Il en existe 2 versions //worker// et //pre-fork//. Les deux créent plusieurs processus fils (donc les coeurs sont exploités) mais worker est, en plus, multi-threadé ; donc plus performant. La contrepartie c'est qu'il n'est plus compatible avec les librairies non thread-safe... comme le célèbre **module PHP**. Vous devrez utiliser un //cluster// interpréteurs en remplacement, comme PHP-FPM. Si vous faites la course à l'optimisation, regardez carrément l'étoile montante : **nginx**</note> | nginx

69 Il manque un trait d’union. => Pour savoir si un programme est optimisé, regardez dans le moniteur système (Système->Administration->Moniteur Système) si votre programme passe significativement au dessus de 100% dans la liste des processus. | au dessus => suggestions : ['au-dessus']

73 Accord avec “leurs nombres”. Utilisez le pluriel. => Un programme optimisé utilisera donc tous les cœurs quel que soit leurs nombres, tant que la bande passante système (communication entre les cœurs/bande passante RAM) ne sera pas saturée. | quel => suggestions : ['quels']
73 Conjugaison erronée. Mettez “être” à la 3ᵉ personne du pluriel. => Un programme optimisé utilisera donc tous les cœurs quel que soit leurs nombres, tant que la bande passante système (communication entre les cœurs/bande passante RAM) ne sera pas saturée. | soit => suggestions : ['soient']
73 Accord de nombre erroné avec « les cœurs/bande » : « passante » devrait être au pluriel. => Un programme optimisé utilisera donc tous les cœurs quel que soit leurs nombres, tant que la bande passante système (communication entre les cœurs/bande passante RAM) ne sera pas saturée. | passante => suggestions : ['passantes']
