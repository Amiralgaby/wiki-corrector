
4 Mot inconnu : Multithreading [[7:21]] => ====== Multithreading - Optimiser l'utilisation des ordinateurs multi-cores, multi-processeurs et Hyper Threading ====== <|> multithreading
4 Tiret d’incise : un tiret demi-cadratin [1] ou cadratin [2] est requis. (Ou éventuellement le signe “moins” [3], s’il s’agit d’une soustraction.) [[21:24]] => ====== Multithreading - Optimiser l'utilisation des ordinateurs multi-cores, multi-processeurs et Hyper Threading ====== <|>  -  => suggestions : [' – ', ' — ', ' − ']
4 Mot inconnu : multi-cores [[64:75]] => ====== Multithreading - Optimiser l'utilisation des ordinateurs multi-cores, multi-processeurs et Hyper Threading ====== <|> multi-cores
4 Mot inconnu : Threading [[104:113]] => ====== Multithreading - Optimiser l'utilisation des ordinateurs multi-cores, multi-processeurs et Hyper Threading ====== <|> threading

6 S’il s’agit d’une action à accomplir, le verbe devrait être à l’infinitif. [[191:196]] => De nos jours les ordinateurs disposent quasiment tous de la possibilité de faire tourner au moins deux threads (tâches systèmes) en même temps. La première fois que le grand public a entendu parlé de cette fonctionnalité c'était avec le Pentium 4 HT. Le Pentium 4 HT n'est pas à proprement parler un processeur optimisé pour ce genre de processus, il ne dispose d'ailleurs que d'un seul cœur d'exécution. Mais depuis les Pentium D, Core Duo, Core 2 Duo et Quad, Athlon 64 X2 ainsi que presque tous les processeurs plus récents, les processeurs sont vraiment significativement plus puissants en utilisation multithreads. <|> parlé => suggestions : ['parler']
6 Mot inconnu : Core [[432:436]] => De nos jours les ordinateurs disposent quasiment tous de la possibilité de faire tourner au moins deux threads (tâches systèmes) en même temps. La première fois que le grand public a entendu parlé de cette fonctionnalité c'était avec le Pentium 4 HT. Le Pentium 4 HT n'est pas à proprement parler un processeur optimisé pour ce genre de processus, il ne dispose d'ailleurs que d'un seul cœur d'exécution. Mais depuis les Pentium D, Core Duo, Core 2 Duo et Quad, Athlon 64 X2 ainsi que presque tous les processeurs plus récents, les processeurs sont vraiment significativement plus puissants en utilisation multithreads. <|> core
6 Mot inconnu : Core [[442:446]] => De nos jours les ordinateurs disposent quasiment tous de la possibilité de faire tourner au moins deux threads (tâches systèmes) en même temps. La première fois que le grand public a entendu parlé de cette fonctionnalité c'était avec le Pentium 4 HT. Le Pentium 4 HT n'est pas à proprement parler un processeur optimisé pour ce genre de processus, il ne dispose d'ailleurs que d'un seul cœur d'exécution. Mais depuis les Pentium D, Core Duo, Core 2 Duo et Quad, Athlon 64 X2 ainsi que presque tous les processeurs plus récents, les processeurs sont vraiment significativement plus puissants en utilisation multithreads. <|> core
6 Accord de nombre erroné avec « 2 » : « Duo » devrait être au pluriel. [[449:452]] => De nos jours les ordinateurs disposent quasiment tous de la possibilité de faire tourner au moins deux threads (tâches systèmes) en même temps. La première fois que le grand public a entendu parlé de cette fonctionnalité c'était avec le Pentium 4 HT. Le Pentium 4 HT n'est pas à proprement parler un processeur optimisé pour ce genre de processus, il ne dispose d'ailleurs que d'un seul cœur d'exécution. Mais depuis les Pentium D, Core Duo, Core 2 Duo et Quad, Athlon 64 X2 ainsi que presque tous les processeurs plus récents, les processeurs sont vraiment significativement plus puissants en utilisation multithreads. <|> duo => suggestions : ['Duos']
6 Mot inconnu : Athlon [[462:468]] => De nos jours les ordinateurs disposent quasiment tous de la possibilité de faire tourner au moins deux threads (tâches systèmes) en même temps. La première fois que le grand public a entendu parlé de cette fonctionnalité c'était avec le Pentium 4 HT. Le Pentium 4 HT n'est pas à proprement parler un processeur optimisé pour ce genre de processus, il ne dispose d'ailleurs que d'un seul cœur d'exécution. Mais depuis les Pentium D, Core Duo, Core 2 Duo et Quad, Athlon 64 X2 ainsi que presque tous les processeurs plus récents, les processeurs sont vraiment significativement plus puissants en utilisation multithreads. <|> athlon
6 Mot inconnu : X2 [[472:474]] => De nos jours les ordinateurs disposent quasiment tous de la possibilité de faire tourner au moins deux threads (tâches systèmes) en même temps. La première fois que le grand public a entendu parlé de cette fonctionnalité c'était avec le Pentium 4 HT. Le Pentium 4 HT n'est pas à proprement parler un processeur optimisé pour ce genre de processus, il ne dispose d'ailleurs que d'un seul cœur d'exécution. Mais depuis les Pentium D, Core Duo, Core 2 Duo et Quad, Athlon 64 X2 ainsi que presque tous les processeurs plus récents, les processeurs sont vraiment significativement plus puissants en utilisation multithreads. <|> x2
6 Mot inconnu : multithreads [[606:618]] => De nos jours les ordinateurs disposent quasiment tous de la possibilité de faire tourner au moins deux threads (tâches systèmes) en même temps. La première fois que le grand public a entendu parlé de cette fonctionnalité c'était avec le Pentium 4 HT. Le Pentium 4 HT n'est pas à proprement parler un processeur optimisé pour ce genre de processus, il ne dispose d'ailleurs que d'un seul cœur d'exécution. Mais depuis les Pentium D, Core Duo, Core 2 Duo et Quad, Athlon 64 X2 ainsi que presque tous les processeurs plus récents, les processeurs sont vraiment significativement plus puissants en utilisation multithreads. <|> multithreads

10 Espace(s) en fin de ligne à supprimer. [[104:105]] => Il existe deux types de cœurs d'exécution dans les processeurs actuels, les cœurs physiques et virtuels.  <|>   => suggestions : ['']
12 Mot inconnu : Threading [[62:71]] =>   * Un cœur virtuel est un cœur créé par la technologie Hyper Threading d'Intel, il permet des augmentations de performances théoriques d'environ 30%. Un processeur HT dispose d'un ou plusieurs cœurs physiques qui sont séparés en deux cœurs virtuels, doublant ainsi le nombre de cœurs visibles par le système. <|> threading

14 Mot inconnu : multithreads [[110:122]] => Cette page se fera un plaisir de recenser les différents programmes à préférer si vous utilisez un processeur multithreads pour obtenir les meilleurs performances. Elle regroupera aussi quelques trucs et astuces à connaitre pour améliorer les performances de programmes qui n'utilisent pas à l'origine plusieurs threads mais dont vous pouvez activer la fonctionnalité par une légère modification. <|> multithreads
14 Accord de genre erroné avec « performances ». [[140:149]] => Cette page se fera un plaisir de recenser les différents programmes à préférer si vous utilisez un processeur multithreads pour obtenir les meilleurs performances. Elle regroupera aussi quelques trucs et astuces à connaitre pour améliorer les performances de programmes qui n'utilisent pas à l'origine plusieurs threads mais dont vous pouvez activer la fonctionnalité par une légère modification. <|> meilleurs => suggestions : ['meilleures']
14 Accord de genre erroné entre « meilleurs » et « performances ». [[150:162]] => Cette page se fera un plaisir de recenser les différents programmes à préférer si vous utilisez un processeur multithreads pour obtenir les meilleurs performances. Elle regroupera aussi quelques trucs et astuces à connaitre pour améliorer les performances de programmes qui n'utilisent pas à l'origine plusieurs threads mais dont vous pouvez activer la fonctionnalité par une légère modification. <|> performances => suggestions : []

16 Mot inconnu : multithreading [[53:67]] => Si le programme doit être configuré pour utiliser le multithreading, la méthode est disponible sur la page du programme de ce wiki. La liste vous indiquera si oui on non il y a besoin d'une intervention de votre part. <|> multithreading
16 Incohérence avec “on” : “non” devrait être un verbe, un pronom objet, un adverbe de négation, etc. [[166:169]] => Si le programme doit être configuré pour utiliser le multithreading, la méthode est disponible sur la page du programme de ce wiki. La liste vous indiquera si oui on non il y a besoin d'une intervention de votre part. <|> non => suggestions : []

18 Mot inconnu : multithreads [[17:29]] => ===== Programmes multithreads ===== <|> multithreads

31 Mot inconnu : Make [[4:8]] => === Make === <|> make

33 Mot inconnu : Make [[0:4]] => Make permet la compilation en multithreads, il suffit d'exprimer votre commande comme ceci: <|> make
33 Mot inconnu : multithreads [[30:42]] => Make permet la compilation en multithreads, il suffit d'exprimer votre commande comme ceci: <|> multithreads

38 Mot inconnu : make [[68:72]] => Attention toutefois à bien préciser le nombre de threads, sans quoi make considèrera le nombre de ces derniers comme illimité et votre ordinateur se mettra alors rapidement à ne plus répondre.  <|> make
38 Espace(s) en fin de ligne à supprimer. [[192:193]] => Attention toutefois à bien préciser le nombre de threads, sans quoi make considèrera le nombre de ces derniers comme illimité et votre ordinateur se mettra alors rapidement à ne plus répondre.  <|>   => suggestions : ['']
55 Mot inconnu : Xvid [[4:8]] =>   * Xvid dans ses versions récentes (à partir d'ubuntu 10.04) <|> xvid
56 Mot inconnu : x264 [[4:8]] =>   * x264 <|> x264

63 Guillemets typographiques ouvrants. [[13:14]] => <note tip>Le "moteur" d'apache s'appelle le MPM. Il en existe 2 versions //worker// et //pre-fork//. Les deux créent plusieurs processus fils (donc les coeurs sont exploités) mais worker est, en plus, multi-threadé ; donc plus performant. La contrepartie c'est qu'il n'est plus compatible avec les librairies non thread-safe... comme le célèbre **module PHP**. Vous devrez utiliser un //cluster// interpréteurs en remplacement, comme PHP-FPM. Si vous faites la course à l'optimisation, regardez carrément l'étoile montante : **nginx**</note> <|> " => suggestions : ['«\xa0', '“']
63 Guillemets typographiques fermants. [[20:21]] => <note tip>Le "moteur" d'apache s'appelle le MPM. Il en existe 2 versions //worker// et //pre-fork//. Les deux créent plusieurs processus fils (donc les coeurs sont exploités) mais worker est, en plus, multi-threadé ; donc plus performant. La contrepartie c'est qu'il n'est plus compatible avec les librairies non thread-safe... comme le célèbre **module PHP**. Vous devrez utiliser un //cluster// interpréteurs en remplacement, comme PHP-FPM. Si vous faites la course à l'optimisation, regardez carrément l'étoile montante : **nginx**</note> <|> " => suggestions : ['\xa0»', '”']
63 Mot inconnu : MPM [[44:47]] => <note tip>Le "moteur" d'apache s'appelle le MPM. Il en existe 2 versions //worker// et //pre-fork//. Les deux créent plusieurs processus fils (donc les coeurs sont exploités) mais worker est, en plus, multi-threadé ; donc plus performant. La contrepartie c'est qu'il n'est plus compatible avec les librairies non thread-safe... comme le célèbre **module PHP**. Vous devrez utiliser un //cluster// interpréteurs en remplacement, comme PHP-FPM. Si vous faites la course à l'optimisation, regardez carrément l'étoile montante : **nginx**</note> <|> mpm
63 Mot inconnu : worker [[75:81]] => <note tip>Le "moteur" d'apache s'appelle le MPM. Il en existe 2 versions //worker// et //pre-fork//. Les deux créent plusieurs processus fils (donc les coeurs sont exploités) mais worker est, en plus, multi-threadé ; donc plus performant. La contrepartie c'est qu'il n'est plus compatible avec les librairies non thread-safe... comme le célèbre **module PHP**. Vous devrez utiliser un //cluster// interpréteurs en remplacement, comme PHP-FPM. Si vous faites la course à l'optimisation, regardez carrément l'étoile montante : **nginx**</note> <|> worker
63 Mot inconnu : pre-fork [[89:97]] => <note tip>Le "moteur" d'apache s'appelle le MPM. Il en existe 2 versions //worker// et //pre-fork//. Les deux créent plusieurs processus fils (donc les coeurs sont exploités) mais worker est, en plus, multi-threadé ; donc plus performant. La contrepartie c'est qu'il n'est plus compatible avec les librairies non thread-safe... comme le célèbre **module PHP**. Vous devrez utiliser un //cluster// interpréteurs en remplacement, comme PHP-FPM. Si vous faites la course à l'optimisation, regardez carrément l'étoile montante : **nginx**</note> <|> pre-fork
63 Mot inconnu : coeurs [[152:158]] => <note tip>Le "moteur" d'apache s'appelle le MPM. Il en existe 2 versions //worker// et //pre-fork//. Les deux créent plusieurs processus fils (donc les coeurs sont exploités) mais worker est, en plus, multi-threadé ; donc plus performant. La contrepartie c'est qu'il n'est plus compatible avec les librairies non thread-safe... comme le célèbre **module PHP**. Vous devrez utiliser un //cluster// interpréteurs en remplacement, comme PHP-FPM. Si vous faites la course à l'optimisation, regardez carrément l'étoile montante : **nginx**</note> <|> coeurs
63 Mot inconnu : worker [[180:186]] => <note tip>Le "moteur" d'apache s'appelle le MPM. Il en existe 2 versions //worker// et //pre-fork//. Les deux créent plusieurs processus fils (donc les coeurs sont exploités) mais worker est, en plus, multi-threadé ; donc plus performant. La contrepartie c'est qu'il n'est plus compatible avec les librairies non thread-safe... comme le célèbre **module PHP**. Vous devrez utiliser un //cluster// interpréteurs en remplacement, comme PHP-FPM. Si vous faites la course à l'optimisation, regardez carrément l'étoile montante : **nginx**</note> <|> worker
63 Mot inconnu : multi-threadé [[201:214]] => <note tip>Le "moteur" d'apache s'appelle le MPM. Il en existe 2 versions //worker// et //pre-fork//. Les deux créent plusieurs processus fils (donc les coeurs sont exploités) mais worker est, en plus, multi-threadé ; donc plus performant. La contrepartie c'est qu'il n'est plus compatible avec les librairies non thread-safe... comme le célèbre **module PHP**. Vous devrez utiliser un //cluster// interpréteurs en remplacement, comme PHP-FPM. Si vous faites la course à l'optimisation, regardez carrément l'étoile montante : **nginx**</note> <|> multi-threadé
63 Mot inconnu : thread-safe [[313:324]] => <note tip>Le "moteur" d'apache s'appelle le MPM. Il en existe 2 versions //worker// et //pre-fork//. Les deux créent plusieurs processus fils (donc les coeurs sont exploités) mais worker est, en plus, multi-threadé ; donc plus performant. La contrepartie c'est qu'il n'est plus compatible avec les librairies non thread-safe... comme le célèbre **module PHP**. Vous devrez utiliser un //cluster// interpréteurs en remplacement, comme PHP-FPM. Si vous faites la course à l'optimisation, regardez carrément l'étoile montante : **nginx**</note> <|> thread-safe
63 Typographie : points de suspension. Utilisez le caractère dédié. [[324:327]] => <note tip>Le "moteur" d'apache s'appelle le MPM. Il en existe 2 versions //worker// et //pre-fork//. Les deux créent plusieurs processus fils (donc les coeurs sont exploités) mais worker est, en plus, multi-threadé ; donc plus performant. La contrepartie c'est qu'il n'est plus compatible avec les librairies non thread-safe... comme le célèbre **module PHP**. Vous devrez utiliser un //cluster// interpréteurs en remplacement, comme PHP-FPM. Si vous faites la course à l'optimisation, regardez carrément l'étoile montante : **nginx**</note> <|> ... => suggestions : ['…']
63 Mot inconnu : PHP-FPM [[434:441]] => <note tip>Le "moteur" d'apache s'appelle le MPM. Il en existe 2 versions //worker// et //pre-fork//. Les deux créent plusieurs processus fils (donc les coeurs sont exploités) mais worker est, en plus, multi-threadé ; donc plus performant. La contrepartie c'est qu'il n'est plus compatible avec les librairies non thread-safe... comme le célèbre **module PHP**. Vous devrez utiliser un //cluster// interpréteurs en remplacement, comme PHP-FPM. Si vous faites la course à l'optimisation, regardez carrément l'étoile montante : **nginx**</note> <|> php-fpm
63 Mot inconnu : nginx [[527:532]] => <note tip>Le "moteur" d'apache s'appelle le MPM. Il en existe 2 versions //worker// et //pre-fork//. Les deux créent plusieurs processus fils (donc les coeurs sont exploités) mais worker est, en plus, multi-threadé ; donc plus performant. La contrepartie c'est qu'il n'est plus compatible avec les librairies non thread-safe... comme le célèbre **module PHP**. Vous devrez utiliser un //cluster// interpréteurs en remplacement, comme PHP-FPM. Si vous faites la course à l'optimisation, regardez carrément l'étoile montante : **nginx**</note> <|> nginx

69 Il manque un trait d’union. [[163:172]] => Pour savoir si un programme est optimisé, regardez dans le moniteur système (Système->Administration->Moniteur Système) si votre programme passe significativement au dessus de 100% dans la liste des processus. <|> au dessus => suggestions : ['au-dessus']

73 Accord avec “leurs nombres”. Utilisez le pluriel. [[52:56]] => Un programme optimisé utilisera donc tous les cœurs quel que soit leurs nombres, tant que la bande passante système (communication entre les cœurs/bande passante RAM) ne sera pas saturée. <|> quel => suggestions : ['quels']
73 Conjugaison erronée. Mettez “être” à la 3ᵉ personne du pluriel. [[61:65]] => Un programme optimisé utilisera donc tous les cœurs quel que soit leurs nombres, tant que la bande passante système (communication entre les cœurs/bande passante RAM) ne sera pas saturée. <|> soit => suggestions : ['soient']
73 Accord de nombre erroné avec « les cœurs/bande » : « passante » devrait être au pluriel. [[153:161]] => Un programme optimisé utilisera donc tous les cœurs quel que soit leurs nombres, tant que la bande passante système (communication entre les cœurs/bande passante RAM) ne sera pas saturée. <|> passante => suggestions : ['passantes']
