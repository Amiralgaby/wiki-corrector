
3 Mot inconnu : Common [[32:38]] => ====== Langage de programmation Common Lisp ====== <|> common

7 Mot inconnu : Common [[0:6]] => Common Lisp est une spécification standardisée par l'ANSI en 1984, et compte plusieurs implémentations. SBCL (Steel Bank Common Lisp) est l'implémentation open-source la plus populaire. SBCL dérive des travaux de la Carnegie Melon University et de tous les financements institutionnels et privés ayant abondé dans les années 80. SBCL produit du code machine efficient, qui la place, dans les tests comparatifs, souvent dans le même groupe que Rust ou Java. <|> common
7 Mot inconnu : ANSI [[53:57]] => Common Lisp est une spécification standardisée par l'ANSI en 1984, et compte plusieurs implémentations. SBCL (Steel Bank Common Lisp) est l'implémentation open-source la plus populaire. SBCL dérive des travaux de la Carnegie Melon University et de tous les financements institutionnels et privés ayant abondé dans les années 80. SBCL produit du code machine efficient, qui la place, dans les tests comparatifs, souvent dans le même groupe que Rust ou Java. <|> ansi
7 Mot inconnu : SBCL [[104:108]] => Common Lisp est une spécification standardisée par l'ANSI en 1984, et compte plusieurs implémentations. SBCL (Steel Bank Common Lisp) est l'implémentation open-source la plus populaire. SBCL dérive des travaux de la Carnegie Melon University et de tous les financements institutionnels et privés ayant abondé dans les années 80. SBCL produit du code machine efficient, qui la place, dans les tests comparatifs, souvent dans le même groupe que Rust ou Java. <|> sbcl
7 Mot inconnu : Steel [[110:115]] => Common Lisp est une spécification standardisée par l'ANSI en 1984, et compte plusieurs implémentations. SBCL (Steel Bank Common Lisp) est l'implémentation open-source la plus populaire. SBCL dérive des travaux de la Carnegie Melon University et de tous les financements institutionnels et privés ayant abondé dans les années 80. SBCL produit du code machine efficient, qui la place, dans les tests comparatifs, souvent dans le même groupe que Rust ou Java. <|> steel
7 Mot inconnu : Bank [[116:120]] => Common Lisp est une spécification standardisée par l'ANSI en 1984, et compte plusieurs implémentations. SBCL (Steel Bank Common Lisp) est l'implémentation open-source la plus populaire. SBCL dérive des travaux de la Carnegie Melon University et de tous les financements institutionnels et privés ayant abondé dans les années 80. SBCL produit du code machine efficient, qui la place, dans les tests comparatifs, souvent dans le même groupe que Rust ou Java. <|> bank
7 Mot inconnu : Common [[121:127]] => Common Lisp est une spécification standardisée par l'ANSI en 1984, et compte plusieurs implémentations. SBCL (Steel Bank Common Lisp) est l'implémentation open-source la plus populaire. SBCL dérive des travaux de la Carnegie Melon University et de tous les financements institutionnels et privés ayant abondé dans les années 80. SBCL produit du code machine efficient, qui la place, dans les tests comparatifs, souvent dans le même groupe que Rust ou Java. <|> common
7 Mot inconnu : SBCL [[186:190]] => Common Lisp est une spécification standardisée par l'ANSI en 1984, et compte plusieurs implémentations. SBCL (Steel Bank Common Lisp) est l'implémentation open-source la plus populaire. SBCL dérive des travaux de la Carnegie Melon University et de tous les financements institutionnels et privés ayant abondé dans les années 80. SBCL produit du code machine efficient, qui la place, dans les tests comparatifs, souvent dans le même groupe que Rust ou Java. <|> sbcl
7 Mot inconnu : Carnegie [[216:224]] => Common Lisp est une spécification standardisée par l'ANSI en 1984, et compte plusieurs implémentations. SBCL (Steel Bank Common Lisp) est l'implémentation open-source la plus populaire. SBCL dérive des travaux de la Carnegie Melon University et de tous les financements institutionnels et privés ayant abondé dans les années 80. SBCL produit du code machine efficient, qui la place, dans les tests comparatifs, souvent dans le même groupe que Rust ou Java. <|> carnegie
7 Mot inconnu : University [[231:241]] => Common Lisp est une spécification standardisée par l'ANSI en 1984, et compte plusieurs implémentations. SBCL (Steel Bank Common Lisp) est l'implémentation open-source la plus populaire. SBCL dérive des travaux de la Carnegie Melon University et de tous les financements institutionnels et privés ayant abondé dans les années 80. SBCL produit du code machine efficient, qui la place, dans les tests comparatifs, souvent dans le même groupe que Rust ou Java. <|> university
7 Mot inconnu : SBCL [[329:333]] => Common Lisp est une spécification standardisée par l'ANSI en 1984, et compte plusieurs implémentations. SBCL (Steel Bank Common Lisp) est l'implémentation open-source la plus populaire. SBCL dérive des travaux de la Carnegie Melon University et de tous les financements institutionnels et privés ayant abondé dans les années 80. SBCL produit du code machine efficient, qui la place, dans les tests comparatifs, souvent dans le même groupe que Rust ou Java. <|> sbcl

9 Mot inconnu : Common [[13:19]] => Aujourd'hui, Common Lisp est toujours utilisé dans l'industrie dans beaucoup de domaines: informatique quantique, analyses financières, systèmes de planification, logiciels de modélisation, musique assistée par ordinateur, assistants de preuves, applications web… <|> common

11 Mot inconnu : McCarthy [[93:101]] => Les premières origines des langages Lisp remontent aux années 60 suivant les travaux de John McCarthy.  <|> mccarthy
11 Espace(s) en fin de ligne à supprimer. [[102:103]] => Les premières origines des langages Lisp remontent aux années 60 suivant les travaux de John McCarthy.  <|>  
13 Mot inconnu : Common [[59:65]] => On distinguera plusieurs dialectes de la famille des Lisp: Common Lisp, la famille des Scheme, Clojure, les langages spécialisés (Emacs Lisp, AutoCAD) et les langages avec une syntaxe Lisp qui transpilent dans un autre langage hôte (tels que LFE pour "Lisp-Flavored Erlang" ou Fennel sur la plateforme Lua). <|> common
13 Mot inconnu : Scheme [[87:93]] => On distinguera plusieurs dialectes de la famille des Lisp: Common Lisp, la famille des Scheme, Clojure, les langages spécialisés (Emacs Lisp, AutoCAD) et les langages avec une syntaxe Lisp qui transpilent dans un autre langage hôte (tels que LFE pour "Lisp-Flavored Erlang" ou Fennel sur la plateforme Lua). <|> scheme
13 Mot inconnu : Clojure [[95:102]] => On distinguera plusieurs dialectes de la famille des Lisp: Common Lisp, la famille des Scheme, Clojure, les langages spécialisés (Emacs Lisp, AutoCAD) et les langages avec une syntaxe Lisp qui transpilent dans un autre langage hôte (tels que LFE pour "Lisp-Flavored Erlang" ou Fennel sur la plateforme Lua). <|> clojure
13 Mot inconnu : AutoCAD [[142:149]] => On distinguera plusieurs dialectes de la famille des Lisp: Common Lisp, la famille des Scheme, Clojure, les langages spécialisés (Emacs Lisp, AutoCAD) et les langages avec une syntaxe Lisp qui transpilent dans un autre langage hôte (tels que LFE pour "Lisp-Flavored Erlang" ou Fennel sur la plateforme Lua). <|> autocad
13 Mot inconnu : transpilent [[193:204]] => On distinguera plusieurs dialectes de la famille des Lisp: Common Lisp, la famille des Scheme, Clojure, les langages spécialisés (Emacs Lisp, AutoCAD) et les langages avec une syntaxe Lisp qui transpilent dans un autre langage hôte (tels que LFE pour "Lisp-Flavored Erlang" ou Fennel sur la plateforme Lua). <|> transpilent
13 Mot inconnu : LFE [[242:245]] => On distinguera plusieurs dialectes de la famille des Lisp: Common Lisp, la famille des Scheme, Clojure, les langages spécialisés (Emacs Lisp, AutoCAD) et les langages avec une syntaxe Lisp qui transpilent dans un autre langage hôte (tels que LFE pour "Lisp-Flavored Erlang" ou Fennel sur la plateforme Lua). <|> lfe
13 Guillemets typographiques ouvrants. [[251:252]] => On distinguera plusieurs dialectes de la famille des Lisp: Common Lisp, la famille des Scheme, Clojure, les langages spécialisés (Emacs Lisp, AutoCAD) et les langages avec une syntaxe Lisp qui transpilent dans un autre langage hôte (tels que LFE pour "Lisp-Flavored Erlang" ou Fennel sur la plateforme Lua). <|> " => suggestions : « “
13 Mot inconnu : Lisp-Flavored [[252:265]] => On distinguera plusieurs dialectes de la famille des Lisp: Common Lisp, la famille des Scheme, Clojure, les langages spécialisés (Emacs Lisp, AutoCAD) et les langages avec une syntaxe Lisp qui transpilent dans un autre langage hôte (tels que LFE pour "Lisp-Flavored Erlang" ou Fennel sur la plateforme Lua). <|> lisp-flavored
13 Mot inconnu : Erlang [[266:272]] => On distinguera plusieurs dialectes de la famille des Lisp: Common Lisp, la famille des Scheme, Clojure, les langages spécialisés (Emacs Lisp, AutoCAD) et les langages avec une syntaxe Lisp qui transpilent dans un autre langage hôte (tels que LFE pour "Lisp-Flavored Erlang" ou Fennel sur la plateforme Lua). <|> erlang
13 Guillemets typographiques fermants. [[272:273]] => On distinguera plusieurs dialectes de la famille des Lisp: Common Lisp, la famille des Scheme, Clojure, les langages spécialisés (Emacs Lisp, AutoCAD) et les langages avec une syntaxe Lisp qui transpilent dans un autre langage hôte (tels que LFE pour "Lisp-Flavored Erlang" ou Fennel sur la plateforme Lua). <|> " => suggestions :  »”
13 Mot inconnu : Fennel [[277:283]] => On distinguera plusieurs dialectes de la famille des Lisp: Common Lisp, la famille des Scheme, Clojure, les langages spécialisés (Emacs Lisp, AutoCAD) et les langages avec une syntaxe Lisp qui transpilent dans un autre langage hôte (tels que LFE pour "Lisp-Flavored Erlang" ou Fennel sur la plateforme Lua). <|> fennel

15 Mot inconnu : Common [[20:26]] => ===== Programmer en Common Lisp ===== <|> common

19 Mot inconnu : sbcl [[106:110]] => Il vous faut installer une implémentation. Sous Ubuntu, plusieurs sont disponibles, mais nous utiliserons sbcl: <|> sbcl
59 Guillemets typographiques ouvrants. [[58:59]] =>   * Lisp utilise une notation préfixée. Au lieu d'appeler "2 + 2", soit une opérande, une fonction, une opérande, on appelle la fonction d'abord et les opérandes à la suite, soit "(+ 2 2)". <|> " => suggestions : « “
59 Guillemets typographiques fermants. [[64:65]] =>   * Lisp utilise une notation préfixée. Au lieu d'appeler "2 + 2", soit une opérande, une fonction, une opérande, on appelle la fonction d'abord et les opérandes à la suite, soit "(+ 2 2)". <|> " => suggestions :  »”
59 Accord de genre erroné : « opérande » est masculin. [[72:75]] =>   * Lisp utilise une notation préfixée. Au lieu d'appeler "2 + 2", soit une opérande, une fonction, une opérande, on appelle la fonction d'abord et les opérandes à la suite, soit "(+ 2 2)". <|> une => suggestions : un
59 Accord de genre erroné : « opérande » est masculin. [[100:103]] =>   * Lisp utilise une notation préfixée. Au lieu d'appeler "2 + 2", soit une opérande, une fonction, une opérande, on appelle la fonction d'abord et les opérandes à la suite, soit "(+ 2 2)". <|> une => suggestions : un

73 Mot inconnu : Common [[19:25]] => La grande force de Common Lisp est son environnement de développement dynamique, mais on peut commencer de la manière la plus simple possible, en écrivant du code dans un fichier texte (extension .lisp) avec n'importe quel éditeur. S'il indente automatiquement la ligne et s'il permet de visualiser les parenthèses ouvrantes et fermantes, tant mieux. <|> common
73 L’espace se place après le point, et non avant (ou bien sert de liant entre deux lettres). [[195:197]] => La grande force de Common Lisp est son environnement de développement dynamique, mais on peut commencer de la manière la plus simple possible, en écrivant du code dans un fichier texte (extension .lisp) avec n'importe quel éditeur. S'il indente automatiquement la ligne et s'il permet de visualiser les parenthèses ouvrantes et fermantes, tant mieux. <|>  . => suggestions : .. 
73 Mot inconnu : lisp [[197:201]] => La grande force de Common Lisp est son environnement de développement dynamique, mais on peut commencer de la manière la plus simple possible, en écrivant du code dans un fichier texte (extension .lisp) avec n'importe quel éditeur. S'il indente automatiquement la ligne et s'il permet de visualiser les parenthèses ouvrantes et fermantes, tant mieux. <|> lisp

75 Guillemets typographiques ouvrants. [[17:18]] => Créez un fichier "hello.lisp" avec votre éditeur de texte préféré et lancez SBCL. <|> " => suggestions : « “
75 Mot inconnu : lisp [[24:28]] => Créez un fichier "hello.lisp" avec votre éditeur de texte préféré et lancez SBCL. <|> lisp
75 Guillemets typographiques fermants. [[28:29]] => Créez un fichier "hello.lisp" avec votre éditeur de texte préféré et lancez SBCL. <|> " => suggestions :  »”
75 Mot inconnu : SBCL [[76:80]] => Créez un fichier "hello.lisp" avec votre éditeur de texte préféré et lancez SBCL. <|> sbcl

97 Mot inconnu : SBCL [[41:45]] => Presque toutes les implémentations, dont SBCL, permettent de créer un fichier binaire exécutable. Mais nous pouvons également lancer notre programme sans cette étape, simplement à partir des sources. <|> sbcl

99 Guillemets typographiques ouvrants. [[19:20]] => Dans votre fichier "hello.lisp", ajoutez quelques commandes qui produisent un résultat. Par exemple: <|> " => suggestions : « “
99 Mot inconnu : lisp [[26:30]] => Dans votre fichier "hello.lisp", ajoutez quelques commandes qui produisent un résultat. Par exemple: <|> lisp
99 Guillemets typographiques fermants. [[30:31]] => Dans votre fichier "hello.lisp", ajoutez quelques commandes qui produisent un résultat. Par exemple: <|> " => suggestions :  »”

128 Guillemets typographiques ouvrants. [[21:22]] => Beaucoup de langages "modernes" proposent un "REPL", une invite de commande interactive, qui permet d'écrire du code et d'obtenir un résultat sans passer par une étape supplémentaire de compilation. Par exemple, Python. Mais aucun, à ma connaissance, à part Smalltalk, n'a été pensé pour une utilisation interactive autant que Common Lisp. Ce n'est pas évident à expliquer en quelques phrases, mais voici quand même quelques pistes. Nous vous renvoyons à quelques vidéos (cf la section des liens). <|> " => suggestions : « “
128 Guillemets typographiques fermants. [[30:31]] => Beaucoup de langages "modernes" proposent un "REPL", une invite de commande interactive, qui permet d'écrire du code et d'obtenir un résultat sans passer par une étape supplémentaire de compilation. Par exemple, Python. Mais aucun, à ma connaissance, à part Smalltalk, n'a été pensé pour une utilisation interactive autant que Common Lisp. Ce n'est pas évident à expliquer en quelques phrases, mais voici quand même quelques pistes. Nous vous renvoyons à quelques vidéos (cf la section des liens). <|> " => suggestions :  »”
128 Guillemets typographiques ouvrants. [[45:46]] => Beaucoup de langages "modernes" proposent un "REPL", une invite de commande interactive, qui permet d'écrire du code et d'obtenir un résultat sans passer par une étape supplémentaire de compilation. Par exemple, Python. Mais aucun, à ma connaissance, à part Smalltalk, n'a été pensé pour une utilisation interactive autant que Common Lisp. Ce n'est pas évident à expliquer en quelques phrases, mais voici quand même quelques pistes. Nous vous renvoyons à quelques vidéos (cf la section des liens). <|> " => suggestions : « “
128 Mot inconnu : REPL [[46:50]] => Beaucoup de langages "modernes" proposent un "REPL", une invite de commande interactive, qui permet d'écrire du code et d'obtenir un résultat sans passer par une étape supplémentaire de compilation. Par exemple, Python. Mais aucun, à ma connaissance, à part Smalltalk, n'a été pensé pour une utilisation interactive autant que Common Lisp. Ce n'est pas évident à expliquer en quelques phrases, mais voici quand même quelques pistes. Nous vous renvoyons à quelques vidéos (cf la section des liens). <|> repl
128 Guillemets typographiques fermants. [[50:51]] => Beaucoup de langages "modernes" proposent un "REPL", une invite de commande interactive, qui permet d'écrire du code et d'obtenir un résultat sans passer par une étape supplémentaire de compilation. Par exemple, Python. Mais aucun, à ma connaissance, à part Smalltalk, n'a été pensé pour une utilisation interactive autant que Common Lisp. Ce n'est pas évident à expliquer en quelques phrases, mais voici quand même quelques pistes. Nous vous renvoyons à quelques vidéos (cf la section des liens). <|> " => suggestions :  »”
128 Mot inconnu : Smalltalk [[258:267]] => Beaucoup de langages "modernes" proposent un "REPL", une invite de commande interactive, qui permet d'écrire du code et d'obtenir un résultat sans passer par une étape supplémentaire de compilation. Par exemple, Python. Mais aucun, à ma connaissance, à part Smalltalk, n'a été pensé pour une utilisation interactive autant que Common Lisp. Ce n'est pas évident à expliquer en quelques phrases, mais voici quand même quelques pistes. Nous vous renvoyons à quelques vidéos (cf la section des liens). <|> smalltalk
128 Mot inconnu : Common [[327:333]] => Beaucoup de langages "modernes" proposent un "REPL", une invite de commande interactive, qui permet d'écrire du code et d'obtenir un résultat sans passer par une étape supplémentaire de compilation. Par exemple, Python. Mais aucun, à ma connaissance, à part Smalltalk, n'a été pensé pour une utilisation interactive autant que Common Lisp. Ce n'est pas évident à expliquer en quelques phrases, mais voici quand même quelques pistes. Nous vous renvoyons à quelques vidéos (cf la section des liens). <|> common
130 Mot inconnu : Slime [[46:51]] => Avec un bon IDE pour CL (typiquement Emacs et Slime, mais aussi SLIMA pour Atom et d'autres), on peut développer son programme interactivement de A à Z, sans avoir besoin de redémarrer le processus Lisp sous-jacent. Toutes les modifications sont ajoutées au fil de l'eau, les tests peuvent être lancés depuis la même image au fil de l'eau. Un cas d'usage classique est:  <|> slime
130 Mot inconnu : SLIMA [[64:69]] => Avec un bon IDE pour CL (typiquement Emacs et Slime, mais aussi SLIMA pour Atom et d'autres), on peut développer son programme interactivement de A à Z, sans avoir besoin de redémarrer le processus Lisp sous-jacent. Toutes les modifications sont ajoutées au fil de l'eau, les tests peuvent être lancés depuis la même image au fil de l'eau. Un cas d'usage classique est:  <|> slima
130 Mot inconnu : Atom [[75:79]] => Avec un bon IDE pour CL (typiquement Emacs et Slime, mais aussi SLIMA pour Atom et d'autres), on peut développer son programme interactivement de A à Z, sans avoir besoin de redémarrer le processus Lisp sous-jacent. Toutes les modifications sont ajoutées au fil de l'eau, les tests peuvent être lancés depuis la même image au fil de l'eau. Un cas d'usage classique est:  <|> atom
130 Espace(s) en fin de ligne à supprimer. [[369:370]] => Avec un bon IDE pour CL (typiquement Emacs et Slime, mais aussi SLIMA pour Atom et d'autres), on peut développer son programme interactivement de A à Z, sans avoir besoin de redémarrer le processus Lisp sous-jacent. Toutes les modifications sont ajoutées au fil de l'eau, les tests peuvent être lancés depuis la même image au fil de l'eau. Un cas d'usage classique est:  <|>  

135 Mot inconnu : Common [[10:16]] => <note tip>Common Lisp permet (mais n'impose pas) une différence de travail fondamentale, où l'on agit de manière interactive et incrémentielle avec l'image Lisp: au lieu d'un cycle typique édition / compilation / attente / test, on obtient un cycle édition / test beaucoup plus court. </note> <|> common
137 Mot inconnu : REPL [[67:71]] =>   * on peut **installer de nouvelles librairies en restant dans le REPL**, il n'y a pas besoin de redémarrer l'interpréteur. <|> repl

143 Mot inconnu : Common [[23:29]] => ===== Logiciels liés à Common Lisp ===== <|> common

145 Mot inconnu : Common [[89:95]] => On ne sait pas toujours quand une entreprise, un service web ou un logiciel est basé sur Common Lisp. Voici quelques exemples. <|> common
