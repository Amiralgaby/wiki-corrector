#!/usr/bin/env python3

import sys
import os
from pathlib import Path
from os.path import join, isfile
from datetime import datetime

import fnmatch

from scrapy.selector import Selector
from pygrammalecte import grammalecte_text
from pygrammalecte.pygrammalecte import GrammalecteSpellingMessage

from wiki_c.state import State

DIR_ORIGIN = 'cache'
DIR_DESTINATION = 'result'

class FakeMessage:
    def __init__(self, line, message):
        self.line = line
        self.message = message

class GrammalecteChecker:
    def __init__(self):
        self.personal_dict: Set[str] = set()
        self.code_open = False
        self.first_warn = False
        lines = Path('dict').read_text(encoding='UTF-8')

        for line in lines.splitlines():
            word = line.strip()
            self.personal_dict.add(word.lower())
            self.personal_dict.add(word.title().lower())

    def get(self, content):
        warnings = ''
        content_list = content.splitlines()
        self.last_line = 0

        g_lines = grammalecte_text(content)
        warn = next(g_lines)
        for key, line in enumerate(content_list):
            if warn.line == key + 1:
                warnings += self._set_warn(warn, content_list)
                try:
                    warn = next(g_lines)
                except StopIteration:
                    continue
                while warn.line == key + 1:
                    warnings += self._set_warn(warn, content_list)
                    try:
                        warn = next(g_lines)
                    except StopIteration:
                        break
                continue
            message = FakeMessage(key, line)
            warnings += self._set_warn(message, content_list)
        return warnings

    def _set_warn(self, message, content_list):
        cr = ''
        target_line = content_list[message.line - 1]
        if type(message) == FakeMessage:
            target_line = content_list[message.line]

        elif self.first_warn and self.last_line != 0 and self.last_line != message.line:
            print('aie', message.line)
            cr = '\n'
        self.last_line = message.line

        if target_line.find('<code') != -1:
            self.code_open = True
        if target_line.find('</code>') != -1:
            self.code_open = False
        if self.code_open:
            return ''

        if type(message) == FakeMessage:
            return ''

        if type(message) == GrammalecteSpellingMessage:
            word = str(message.word)
            word_l = word.lower()
            if word_l in self.personal_dict:
                return ''
            if '[[utilisateurs:{0}'.format(word) in target_line:
                return ''
            if '[[:utilisateurs:{0}'.format(word) in target_line:
                return ''
            if '[[:tutoriel:{0}'.format(word) in target_line:
                return ''
            if '[[{0}>'.format(word) in target_line:
                return ''
            if '[[:{0}'.format(word) in target_line:
                return ''
            if '[[apt>{0}|'.format(word) in target_line:
                return ''
            if '|{0}]]'.format(word) in target_line:
                return ''
            if ':{0}]]'.format(word) in target_line:
                return ''
            index_start = target_line.find('<code')
            index_end = target_line.find('</code>')
            if index_start != -1 and index_end != -1:
                sub_str = target_line[index_start + 6:index_end]
                if word in sub_str:
                    return ''

        self.first_warn = True
        warning = "{0}{1} {2} => {3}\n".format(
            cr,
            message.line,
            message.message,
            target_line
        )
        return warning


def create_file(warnings, path):
    content = Path(path).read_text(encoding="UTF-8")
    if content == warnings:
        return
    if isfile(path):
        print(path, '[updated]')
    else:
        print(path, '[created]')
    with open(path, 'w') as f:
        f.write(warnings)


def detect_redirection(content):
    if content.startswith('\n~~REDIRECT>'):
        return True
    return False


def write_error(path, e, content):
    error = 'path: {0}'.format(path)
    error += 'exception: {0}'.format(e)
    error += 'content : {0}'.format(content)
    with open(join(DIR_ORIGIN, 'crash.log'), 'a') as f:
        f.write(error)


def analyse_file(root, _file, full=False):
    if not _file.endswith('.dokuwiki'):
        return

    with open(join(root, _file), 'r') as f:
        content = f.read()

    if detect_redirection(content):
        return

    path = DIR_DESTINATION + root[len_dir_cache:] + '/' + _file.replace('.dokuwiki', '.txt')
    
    g_checker = GrammalecteChecker()

    try:
        warnings = g_checker.get(content)
    except Exception as e:
        write_error(path, e, content)
        return

    os.makedirs(
        DIR_DESTINATION + '/' + root[len_dir_cache:],
        exist_ok=True
    )

    if not isfile(path):
        create_file(warnings, path)
        return

    file_date = datetime.fromtimestamp(os.path.getmtime(path))
    if not full and index and index['last_date'] > file_date:
        print(path, '[exist]')
        return

    create_file(warnings, path)


def walk(full=False):
    for root, _dir, files in os.walk(DIR_ORIGIN):
        for _file in fnmatch.filter(files, '*'):
            analyse_file(root, _file, full)


if __name__ == '__main__':
    full = False
    len_dir_cache = len(DIR_ORIGIN)
    state = State(DIR_DESTINATION)
    index = state.get_index()

    if '-f' in sys.argv or '--full' in sys.argv:
        full = True

    state.create_index(full)

    walk(full)
