8 Espace(s) surnuméraire(s) à supprimer. => Un script shell permet d'automatiser une série d'opérations. Il se présente sous la forme d'un fichier contenant une ou plusieurs commandes qui  seront exécutées de manière séquentielle. 
8 Espace(s) en fin de ligne à supprimer. => Un script shell permet d'automatiser une série d'opérations. Il se présente sous la forme d'un fichier contenant une ou plusieurs commandes qui  seront exécutées de manière séquentielle. 

10 Il manque un espace insécable. => #!/bin/bash

11 Mot inconnu : This => # This script will take an animated GIF and delete every other frame
11 Mot inconnu : will => # This script will take an animated GIF and delete every other frame
11 Mot inconnu : take => # This script will take an animated GIF and delete every other frame
11 Mot inconnu : animated => # This script will take an animated GIF and delete every other frame
11 Mot inconnu : and => # This script will take an animated GIF and delete every other frame
11 Mot inconnu : delete => # This script will take an animated GIF and delete every other frame
11 Mot inconnu : every => # This script will take an animated GIF and delete every other frame
11 Mot inconnu : other => # This script will take an animated GIF and delete every other frame
11 Mot inconnu : frame => # This script will take an animated GIF and delete every other frame

12 Mot inconnu : Accepts => # Accepts two parameters: input file and output file
12 Mot inconnu : two => # Accepts two parameters: input file and output file
12 Mot inconnu : parameters => # Accepts two parameters: input file and output file
12 Il manque un espace insécable. => # Accepts two parameters: input file and output file
12 Mot inconnu : and => # Accepts two parameters: input file and output file

13 Il manque un espace insécable. => # Usage: ./<scriptfilename> input.gif output.gif

15 Mot inconnu : Make => # Make a copy of the file
15 Mot inconnu : copy => # Make a copy of the file
15 Mot inconnu : of => # Make a copy of the file
15 Mot inconnu : the => # Make a copy of the file

16 Mot inconnu : cp => cp "$1" "$2"
16 Guillemets typographiques fermants. => cp "$1" "$2"
16 Guillemets typographiques fermants. => cp "$1" "$2"

18 Mot inconnu : Get => # Get the number of frames
18 Mot inconnu : the => # Get the number of frames
18 Mot inconnu : number => # Get the number of frames
18 Mot inconnu : of => # Get the number of frames
18 Mot inconnu : frames => # Get the number of frames

19 Mot inconnu : numframes => numframes=$(gifsicle --info "$1" \
19 Mot inconnu : gifsicle => numframes=$(gifsicle --info "$1" \
19 Guillemets typographiques fermants. => numframes=$(gifsicle --info "$1" \

20 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>               | grep --perl-regexp --only-matching '\d+ images' \
20 Mot inconnu : grep =>               | grep --perl-regexp --only-matching '\d+ images' \
20 Mot inconnu : perl-regexp =>               | grep --perl-regexp --only-matching '\d+ images' \
20 Mot inconnu : only-matching =>               | grep --perl-regexp --only-matching '\d+ images' \
20 Guillemets typographiques fermants. =>               | grep --perl-regexp --only-matching '\d+ images' \

21 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>               | grep --perl-regexp --only-matching '\d+')
21 Mot inconnu : grep =>               | grep --perl-regexp --only-matching '\d+')
21 Mot inconnu : perl-regexp =>               | grep --perl-regexp --only-matching '\d+')
21 Mot inconnu : only-matching =>               | grep --perl-regexp --only-matching '\d+')

23 Mot inconnu : Deletion => # Deletion

25 Mot inconnu : while => while test $i -lt $numframes
25 Il manque un espace à côté du tiret. => while test $i -lt $numframes
25 Mot inconnu : lt => while test $i -lt $numframes
25 Mot inconnu : numframes => while test $i -lt $numframes

27 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     rem=$(( $i % 2 ))
27 Pas d’espace après ce signe. =>     rem=$(( $i % 2 ))
27 Pas d’espace avant ce signe. =>     rem=$(( $i % 2 ))

29 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     if test $rem -eq 0
29 Il manque un espace à côté du tiret. =>     if test $rem -eq 0
29 Mot inconnu : eq =>     if test $rem -eq 0

30 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     then
30 Mot inconnu : then =>     then

31 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>         gifsicle "$2" --delete "#"$(($i/2)) -o "$2"
31 Mot inconnu : gifsicle =>         gifsicle "$2" --delete "#"$(($i/2)) -o "$2"
31 Guillemets typographiques fermants. =>         gifsicle "$2" --delete "#"$(($i/2)) -o "$2"
31 Mot inconnu : delete =>         gifsicle "$2" --delete "#"$(($i/2)) -o "$2"
31 Guillemets typographiques fermants. =>         gifsicle "$2" --delete "#"$(($i/2)) -o "$2"

32 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     fi

34 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     let i=i+1 
34 Espace(s) en fin de ligne à supprimer. =>     let i=i+1 

35 Mot inconnu : done => done

41 Il manque un espace insécable. => Votre script est un simple fichier texte, par défaut il s'ouvre donc avec l'éditeur de texte défini par défaut (ex : [[:gedit|Gedit]] dans une session Unity ou Gnome).\\
41 Mot inconnu : Unity => Votre script est un simple fichier texte, par défaut il s'ouvre donc avec l'éditeur de texte défini par défaut (ex : [[:gedit|Gedit]] dans une session Unity ou Gnome).\\

42 Espace(s) en fin de ligne à supprimer. => Pour qu'il soit autorisé à se lancer en tant que programme, il faut modifier ses propriétés.\\ 

43 Guillemets typographiques ouvrants. => Pour cela faites un clic droit sur son icône, et dans l'onglet "Permissions" des "Propriétés", cocher la case //"autoriser l'exécution du fichier comme un programme"//.
43 Guillemets typographiques fermants. => Pour cela faites un clic droit sur son icône, et dans l'onglet "Permissions" des "Propriétés", cocher la case //"autoriser l'exécution du fichier comme un programme"//.
43 Guillemets typographiques ouvrants. => Pour cela faites un clic droit sur son icône, et dans l'onglet "Permissions" des "Propriétés", cocher la case //"autoriser l'exécution du fichier comme un programme"//.
43 Guillemets typographiques fermants. => Pour cela faites un clic droit sur son icône, et dans l'onglet "Permissions" des "Propriétés", cocher la case //"autoriser l'exécution du fichier comme un programme"//.
43 Guillemets typographiques ouvrants. => Pour cela faites un clic droit sur son icône, et dans l'onglet "Permissions" des "Propriétés", cocher la case //"autoriser l'exécution du fichier comme un programme"//.
43 Guillemets typographiques fermants. => Pour cela faites un clic droit sur son icône, et dans l'onglet "Permissions" des "Propriétés", cocher la case //"autoriser l'exécution du fichier comme un programme"//.

50 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>  
51 Il manque un espace insécable. => Sous [[:Lubuntu]], si cette méthode ne fonctionne pas, vous devez d'abord effectuer l'opération suivante :\\

52 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   - Dans le menu principal, allez sur //Outils système// et faites un //clic droit -> Propriétés// sur le raccourci vers le terminal. Notez le contenu du champ //Commande// et annulez.
52 Tiret d’incise : un tiret demi-cadratin [1] ou cadratin [2] est requis. (Ou éventuellement le signe “moins” [3], s’il s’agit d’une soustraction.) =>   - Dans le menu principal, allez sur //Outils système// et faites un //clic droit -> Propriétés// sur le raccourci vers le terminal. Notez le contenu du champ //Commande// et annulez.

53 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   - Ouvrez votre gestionnaire de fichier [[:pcmanfm|PCManFM]] et allez dans le menu supérieur sur //éditer -> Préférences// puis dans la fenêtre qui s'ouvre sélectionnez //Avancé//.
53 Tiret d’incise : un tiret demi-cadratin [1] ou cadratin [2] est requis. (Ou éventuellement le signe “moins” [3], s’il s’agit d’une soustraction.) =>   - Ouvrez votre gestionnaire de fichier [[:pcmanfm|PCManFM]] et allez dans le menu supérieur sur //éditer -> Préférences// puis dans la fenêtre qui s'ouvre sélectionnez //Avancé//.

54 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   - Remplacez le contenu du champ //Terminal emulator// par le contenu du champ //Commande// que vous avez pris soin de noter à la première étape.
54 Tiret d’incise : un tiret demi-cadratin [1] ou cadratin [2] est requis. (Ou éventuellement le signe “moins” [3], s’il s’agit d’une soustraction.) =>   - Remplacez le contenu du champ //Terminal emulator// par le contenu du champ //Commande// que vous avez pris soin de noter à la première étape.
54 Mot inconnu : emulator =>   - Remplacez le contenu du champ //Terminal emulator// par le contenu du champ //Commande// que vous avez pris soin de noter à la première étape.

55 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   - Vous pouvez ensuite suivre la méthode graphique indiquée ci-dessus pour exécuter vos scripts shell.
55 Tiret d’incise : un tiret demi-cadratin [1] ou cadratin [2] est requis. (Ou éventuellement le signe “moins” [3], s’il s’agit d’une soustraction.) =>   - Vous pouvez ensuite suivre la méthode graphique indiquée ci-dessus pour exécuter vos scripts shell.

59 Mot inconnu : bash => Il suffit de se placer dans le dossier où est le script, et de lancer : <code bash>bash nom_du_script</code>
59 Mot inconnu : nom_du_script => Il suffit de se placer dans le dossier où est le script, et de lancer : <code bash>bash nom_du_script</code>

60 Mot inconnu : bash => mais pas toujours bash ( dépend du langage du script )
60 Pas d’espace après ce signe. => mais pas toujours bash ( dépend du langage du script )
60 Pas d’espace avant ce signe. => mais pas toujours bash ( dépend du langage du script )

62 Espace(s) surnuméraire(s) à supprimer. => ou si vous voulez l'exécuter par son  nom , il faut le rendre exécutable avec ''chmod''. Pour ceci tapez la commande qui suit : <code bash>chmod +x nom_du_script</code>
62 Pas d’espace avant une virgule. => ou si vous voulez l'exécuter par son  nom , il faut le rendre exécutable avec ''chmod''. Pour ceci tapez la commande qui suit : <code bash>chmod +x nom_du_script</code>
62 Guillemets typographiques ouvrants. => ou si vous voulez l'exécuter par son  nom , il faut le rendre exécutable avec ''chmod''. Pour ceci tapez la commande qui suit : <code bash>chmod +x nom_du_script</code>
62 Mot inconnu : chmod => ou si vous voulez l'exécuter par son  nom , il faut le rendre exécutable avec ''chmod''. Pour ceci tapez la commande qui suit : <code bash>chmod +x nom_du_script</code>
62 Guillemets typographiques fermants. => ou si vous voulez l'exécuter par son  nom , il faut le rendre exécutable avec ''chmod''. Pour ceci tapez la commande qui suit : <code bash>chmod +x nom_du_script</code>
62 Mot inconnu : chmod => ou si vous voulez l'exécuter par son  nom , il faut le rendre exécutable avec ''chmod''. Pour ceci tapez la commande qui suit : <code bash>chmod +x nom_du_script</code>
62 Mot inconnu : nom_du_script => ou si vous voulez l'exécuter par son  nom , il faut le rendre exécutable avec ''chmod''. Pour ceci tapez la commande qui suit : <code bash>chmod +x nom_du_script</code>

64 Mot inconnu : nom_du_script => Puis vous pouvez exécuter le script en faisant : <code bash>./nom_du_script</code>

65 Il manque un espace insécable. => mais pourquoi le ./ ?

69 Guillemets typographiques ouvrants. => Il peut être intéressant d'ajouter un répertoire au "PATH" pour pouvoir exécuter ses scripts sans avoir à se placer dans le bon dossier.
69 Mot inconnu : PATH => Il peut être intéressant d'ajouter un répertoire au "PATH" pour pouvoir exécuter ses scripts sans avoir à se placer dans le bon dossier.
69 Guillemets typographiques fermants. => Il peut être intéressant d'ajouter un répertoire au "PATH" pour pouvoir exécuter ses scripts sans avoir à se placer dans le bon dossier.

70 Guillemets typographiques ouvrants. => Je m'explique, quand vous tapez une commande ("ls" par exemple), le shell regarde dans le PATH qui lui indique où chercher le code de la commande.
70 Mot inconnu : ls => Je m'explique, quand vous tapez une commande ("ls" par exemple), le shell regarde dans le PATH qui lui indique où chercher le code de la commande.
70 Guillemets typographiques fermants. => Je m'explique, quand vous tapez une commande ("ls" par exemple), le shell regarde dans le PATH qui lui indique où chercher le code de la commande.
70 Mot inconnu : PATH => Je m'explique, quand vous tapez une commande ("ls" par exemple), le shell regarde dans le PATH qui lui indique où chercher le code de la commande.

72 Mot inconnu : PATH => Pour voir à quoi ressemble votre PATH, tapez dans votre console:
72 Il manque un espace insécable. => Pour voir à quoi ressemble votre PATH, tapez dans votre console:

73 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   echo $PATH
73 Mot inconnu : echo =>   echo $PATH
73 Mot inconnu : PATH =>   echo $PATH

75 Il manque un espace insécable. => Cette commande chez moi donnait initialement :

76 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   /usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games
76 Il manque un espace insécable. =>   /usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games
76 Il manque un espace insécable. =>   /usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games
76 Il manque un espace insécable. =>   /usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games
76 Il manque un espace insécable. =>   /usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games

78 Il manque les traits d’union. => C'est à dire que le shell va aller voir si la définition de la commande tapée ("ls" pour continuer sur le même exemple) se trouve dans **/usr/local/bin** puis dans **/usr/bin**... jusqu'à ce qu'il la trouve.
78 Guillemets typographiques ouvrants. => C'est à dire que le shell va aller voir si la définition de la commande tapée ("ls" pour continuer sur le même exemple) se trouve dans **/usr/local/bin** puis dans **/usr/bin**... jusqu'à ce qu'il la trouve.
78 Mot inconnu : ls => C'est à dire que le shell va aller voir si la définition de la commande tapée ("ls" pour continuer sur le même exemple) se trouve dans **/usr/local/bin** puis dans **/usr/bin**... jusqu'à ce qu'il la trouve.
78 Guillemets typographiques fermants. => C'est à dire que le shell va aller voir si la définition de la commande tapée ("ls" pour continuer sur le même exemple) se trouve dans **/usr/local/bin** puis dans **/usr/bin**... jusqu'à ce qu'il la trouve.
78 Typographie : points de suspension. Utilisez le caractère dédié. => C'est à dire que le shell va aller voir si la définition de la commande tapée ("ls" pour continuer sur le même exemple) se trouve dans **/usr/local/bin** puis dans **/usr/bin**... jusqu'à ce qu'il la trouve.

80 Mot inconnu : PATH => Ajouter un répertoire au PATH peut donc être très pratique. Par convention, ce répertoire s'appelle **bin** et se place dans votre répertoire personnel. Si votre répertoire personnel est /home/toto, ce répertoire sera donc **/home/toto/bin**.
80 Mot inconnu : bin => Ajouter un répertoire au PATH peut donc être très pratique. Par convention, ce répertoire s'appelle **bin** et se place dans votre répertoire personnel. Si votre répertoire personnel est /home/toto, ce répertoire sera donc **/home/toto/bin**.

81 Guillemets fermants. => Pour pouvoir utiliser mes scripts en tapant directement leur nom (sans le "./") depuis n'importe quel répertoire de mon ordinateur, il me suffit d'indiquer au shell de chercher aussi dans ce nouveau dossier en l'ajoutant au PATH.
81 Mot inconnu : PATH => Pour pouvoir utiliser mes scripts en tapant directement leur nom (sans le "./") depuis n'importe quel répertoire de mon ordinateur, il me suffit d'indiquer au shell de chercher aussi dans ce nouveau dossier en l'ajoutant au PATH.

82 Il manque un espace insécable. => Pour ceci, il suffit de faire :

83 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   export PATH=$PATH:$HOME/bin
83 Mot inconnu : PATH =>   export PATH=$PATH:$HOME/bin
83 Mot inconnu : PATH =>   export PATH=$PATH:$HOME/bin

86 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   echo $PATH
86 Mot inconnu : echo =>   echo $PATH
86 Mot inconnu : PATH =>   echo $PATH

88 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   /usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games:/home/toto/bin
88 Il manque un espace insécable. =>   /usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games:/home/toto/bin
88 Il manque un espace insécable. =>   /usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games:/home/toto/bin
88 Il manque un espace insécable. =>   /usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games:/home/toto/bin
88 Il manque un espace insécable. =>   /usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games:/home/toto/bin
88 Il manque un espace insécable. =>   /usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games:/home/toto/bin

90 Guillemets typographiques ouvrants. => et je peux lancer le script appelé "monScript" situé dans "/home/toto/bin" en tapant directement :  monScript
90 Mot inconnu : monScript => et je peux lancer le script appelé "monScript" situé dans "/home/toto/bin" en tapant directement :  monScript
90 Guillemets typographiques fermants. => et je peux lancer le script appelé "monScript" situé dans "/home/toto/bin" en tapant directement :  monScript
90 Il manque un espace insécable. => et je peux lancer le script appelé "monScript" situé dans "/home/toto/bin" en tapant directement :  monScript
90 Espace(s) surnuméraire(s) à supprimer. => et je peux lancer le script appelé "monScript" situé dans "/home/toto/bin" en tapant directement :  monScript
90 Mot inconnu : monScript => et je peux lancer le script appelé "monScript" situé dans "/home/toto/bin" en tapant directement :  monScript

92 Mot inconnu : PATH => <note tip>Cette procédure est pour une modification temporaire du PATH et qui sera donc effacée à la fin de la session. Pour rendre la modification permanente, ajouter la commande dans le fichier texte caché .bashrc se trouvant dans votre dossier personnel ainsi que dans le dossier /root.</note>
92 L’espace se place après le point, et non avant (ou bien sert de liant entre deux lettres). => <note tip>Cette procédure est pour une modification temporaire du PATH et qui sera donc effacée à la fin de la session. Pour rendre la modification permanente, ajouter la commande dans le fichier texte caché .bashrc se trouvant dans votre dossier personnel ainsi que dans le dossier /root.</note>
92 Mot inconnu : bashrc => <note tip>Cette procédure est pour une modification temporaire du PATH et qui sera donc effacée à la fin de la session. Pour rendre la modification permanente, ajouter la commande dans le fichier texte caché .bashrc se trouvant dans votre dossier personnel ainsi que dans le dossier /root.</note>

94 Élision de l’article devant un mot commençant par une voyelle. => <note important>Dans les dernières versions de ubuntu (12.04 +) si le dossier $HOME/bin existe il est automatiquement ajouté au PATH. La commande est incluse dans le fichier ~/.profile lancé lors de toutes sessions (graphique ou console).</note>
94 Mot inconnu : ubuntu => <note important>Dans les dernières versions de ubuntu (12.04 +) si le dossier $HOME/bin existe il est automatiquement ajouté au PATH. La commande est incluse dans le fichier ~/.profile lancé lors de toutes sessions (graphique ou console).</note>
94 Mot inconnu : PATH => <note important>Dans les dernières versions de ubuntu (12.04 +) si le dossier $HOME/bin existe il est automatiquement ajouté au PATH. La commande est incluse dans le fichier ~/.profile lancé lors de toutes sessions (graphique ou console).</note>

98 Il manque un espace insécable. => Comme vous avez sûrement dû l'entendre, il existe différents types de shells ou en bon français, interpréteurs de commandes :

100 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * [[wpfr>Debian_Almquist_shell|dash]] (//Debian Almquist shell//) : shell plus léger que bash, installé par défaut sur Ubuntu ;
100 Mot inconnu : Debian_Almquist_shell =>   * [[wpfr>Debian_Almquist_shell|dash]] (//Debian Almquist shell//) : shell plus léger que bash, installé par défaut sur Ubuntu ;
100 Mot inconnu : Almquist =>   * [[wpfr>Debian_Almquist_shell|dash]] (//Debian Almquist shell//) : shell plus léger que bash, installé par défaut sur Ubuntu ;
100 Il manque un espace insécable. =>   * [[wpfr>Debian_Almquist_shell|dash]] (//Debian Almquist shell//) : shell plus léger que bash, installé par défaut sur Ubuntu ;
100 Mot inconnu : bash =>   * [[wpfr>Debian_Almquist_shell|dash]] (//Debian Almquist shell//) : shell plus léger que bash, installé par défaut sur Ubuntu ;
100 Il manque un espace insécable. =>   * [[wpfr>Debian_Almquist_shell|dash]] (//Debian Almquist shell//) : shell plus léger que bash, installé par défaut sur Ubuntu ;

101 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * [[:bash]] (//Bourne Again SHell//) : conçu par le projet GNU, shell linux ; le shell par défaut sur Ubuntu ;
101 Mot inconnu : Bourne =>   * [[:bash]] (//Bourne Again SHell//) : conçu par le projet GNU, shell linux ; le shell par défaut sur Ubuntu ;
101 Mot inconnu : Again =>   * [[:bash]] (//Bourne Again SHell//) : conçu par le projet GNU, shell linux ; le shell par défaut sur Ubuntu ;
101 Mot inconnu : SHell =>   * [[:bash]] (//Bourne Again SHell//) : conçu par le projet GNU, shell linux ; le shell par défaut sur Ubuntu ;
101 Il manque un espace insécable. =>   * [[:bash]] (//Bourne Again SHell//) : conçu par le projet GNU, shell linux ; le shell par défaut sur Ubuntu ;
101 Mot inconnu : linux =>   * [[:bash]] (//Bourne Again SHell//) : conçu par le projet GNU, shell linux ; le shell par défaut sur Ubuntu ;
101 Il manque un espace insécable. =>   * [[:bash]] (//Bourne Again SHell//) : conçu par le projet GNU, shell linux ; le shell par défaut sur Ubuntu ;
101 Il manque un espace insécable. =>   * [[:bash]] (//Bourne Again SHell//) : conçu par le projet GNU, shell linux ; le shell par défaut sur Ubuntu ;

102 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * rbash : un shell restreint basé sur bash. Il existe de nombreuses variantes de bash ;
102 Majuscule en début de phrase, sauf éventuellement lors d’une énumération. =>   * rbash : un shell restreint basé sur bash. Il existe de nombreuses variantes de bash ;
102 Mot inconnu : rbash =>   * rbash : un shell restreint basé sur bash. Il existe de nombreuses variantes de bash ;
102 Il manque un espace insécable. =>   * rbash : un shell restreint basé sur bash. Il existe de nombreuses variantes de bash ;
102 Mot inconnu : bash =>   * rbash : un shell restreint basé sur bash. Il existe de nombreuses variantes de bash ;
102 Mot inconnu : bash =>   * rbash : un shell restreint basé sur bash. Il existe de nombreuses variantes de bash ;
102 Il manque un espace insécable. =>   * rbash : un shell restreint basé sur bash. Il existe de nombreuses variantes de bash ;

103 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * csh, tcsh : shells C, créés par Bill Joy de Berkeley ;
103 Mot inconnu : csh =>   * csh, tcsh : shells C, créés par Bill Joy de Berkeley ;
103 Mot inconnu : tcsh =>   * csh, tcsh : shells C, créés par Bill Joy de Berkeley ;
103 Il manque un espace insécable. =>   * csh, tcsh : shells C, créés par Bill Joy de Berkeley ;
103 Il manque un espace insécable. =>   * csh, tcsh : shells C, créés par Bill Joy de Berkeley ;

104 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * zsh, shell C écrit par Paul Falstad ;
104 Mot inconnu : zsh =>   * zsh, shell C écrit par Paul Falstad ;
104 Mot inconnu : Falstad =>   * zsh, shell C écrit par Paul Falstad ;
104 Il manque un espace insécable. =>   * zsh, shell C écrit par Paul Falstad ;

105 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * ksh (<=> ksh88 sur Solaris et équivaut à ksh93 sur les autres UNIX/Linux cf.[[http://en.wikipedia.org/wiki/Korn_shell#History|Korn shell History]]): shells korn écrits par David Korn, pdksh (Public Domain Korn Shell <=> ksh88) ;
105 Mot inconnu : ksh =>   * ksh (<=> ksh88 sur Solaris et équivaut à ksh93 sur les autres UNIX/Linux cf.[[http://en.wikipedia.org/wiki/Korn_shell#History|Korn shell History]]): shells korn écrits par David Korn, pdksh (Public Domain Korn Shell <=> ksh88) ;
105 Mot inconnu : ksh88 =>   * ksh (<=> ksh88 sur Solaris et équivaut à ksh93 sur les autres UNIX/Linux cf.[[http://en.wikipedia.org/wiki/Korn_shell#History|Korn shell History]]): shells korn écrits par David Korn, pdksh (Public Domain Korn Shell <=> ksh88) ;
105 Mot inconnu : Solaris =>   * ksh (<=> ksh88 sur Solaris et équivaut à ksh93 sur les autres UNIX/Linux cf.[[http://en.wikipedia.org/wiki/Korn_shell#History|Korn shell History]]): shells korn écrits par David Korn, pdksh (Public Domain Korn Shell <=> ksh88) ;
105 Mot inconnu : ksh93 =>   * ksh (<=> ksh88 sur Solaris et équivaut à ksh93 sur les autres UNIX/Linux cf.[[http://en.wikipedia.org/wiki/Korn_shell#History|Korn shell History]]): shells korn écrits par David Korn, pdksh (Public Domain Korn Shell <=> ksh88) ;
105 Mot inconnu : Korn =>   * ksh (<=> ksh88 sur Solaris et équivaut à ksh93 sur les autres UNIX/Linux cf.[[http://en.wikipedia.org/wiki/Korn_shell#History|Korn shell History]]): shells korn écrits par David Korn, pdksh (Public Domain Korn Shell <=> ksh88) ;
105 Mot inconnu : History =>   * ksh (<=> ksh88 sur Solaris et équivaut à ksh93 sur les autres UNIX/Linux cf.[[http://en.wikipedia.org/wiki/Korn_shell#History|Korn shell History]]): shells korn écrits par David Korn, pdksh (Public Domain Korn Shell <=> ksh88) ;
105 Mot inconnu : korn =>   * ksh (<=> ksh88 sur Solaris et équivaut à ksh93 sur les autres UNIX/Linux cf.[[http://en.wikipedia.org/wiki/Korn_shell#History|Korn shell History]]): shells korn écrits par David Korn, pdksh (Public Domain Korn Shell <=> ksh88) ;
105 Mot inconnu : Korn =>   * ksh (<=> ksh88 sur Solaris et équivaut à ksh93 sur les autres UNIX/Linux cf.[[http://en.wikipedia.org/wiki/Korn_shell#History|Korn shell History]]): shells korn écrits par David Korn, pdksh (Public Domain Korn Shell <=> ksh88) ;
105 Mot inconnu : pdksh =>   * ksh (<=> ksh88 sur Solaris et équivaut à ksh93 sur les autres UNIX/Linux cf.[[http://en.wikipedia.org/wiki/Korn_shell#History|Korn shell History]]): shells korn écrits par David Korn, pdksh (Public Domain Korn Shell <=> ksh88) ;
105 Mot inconnu : Domain =>   * ksh (<=> ksh88 sur Solaris et équivaut à ksh93 sur les autres UNIX/Linux cf.[[http://en.wikipedia.org/wiki/Korn_shell#History|Korn shell History]]): shells korn écrits par David Korn, pdksh (Public Domain Korn Shell <=> ksh88) ;
105 Mot inconnu : Korn =>   * ksh (<=> ksh88 sur Solaris et équivaut à ksh93 sur les autres UNIX/Linux cf.[[http://en.wikipedia.org/wiki/Korn_shell#History|Korn shell History]]): shells korn écrits par David Korn, pdksh (Public Domain Korn Shell <=> ksh88) ;
105 Mot inconnu : ksh88 =>   * ksh (<=> ksh88 sur Solaris et équivaut à ksh93 sur les autres UNIX/Linux cf.[[http://en.wikipedia.org/wiki/Korn_shell#History|Korn shell History]]): shells korn écrits par David Korn, pdksh (Public Domain Korn Shell <=> ksh88) ;
105 Il manque un espace insécable. =>   * ksh (<=> ksh88 sur Solaris et équivaut à ksh93 sur les autres UNIX/Linux cf.[[http://en.wikipedia.org/wiki/Korn_shell#History|Korn shell History]]): shells korn écrits par David Korn, pdksh (Public Domain Korn Shell <=> ksh88) ;

106 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * rc : shell C, lui aussi conçu par le projet GNU ;
106 Mot inconnu : rc =>   * rc : shell C, lui aussi conçu par le projet GNU ;
106 Il manque un espace insécable. =>   * rc : shell C, lui aussi conçu par le projet GNU ;
106 Il manque un espace insécable. =>   * rc : shell C, lui aussi conçu par le projet GNU ;

107 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * tclsh : shell utilisant Tcl ;                        
107 Mot inconnu : tclsh =>   * tclsh : shell utilisant Tcl ;                        
107 Il manque un espace insécable. =>   * tclsh : shell utilisant Tcl ;                        
107 Mot inconnu : Tcl =>   * tclsh : shell utilisant Tcl ;                        
107 Il manque un espace insécable. =>   * tclsh : shell utilisant Tcl ;                        
107 Espace(s) en fin de ligne à supprimer. =>   * tclsh : shell utilisant Tcl ;                        

108 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * wish : shell utilisant Tk .      
108 Mot inconnu : wish =>   * wish : shell utilisant Tk .      
108 Il manque un espace insécable. =>   * wish : shell utilisant Tk .      
108 Mot inconnu : Tk =>   * wish : shell utilisant Tk .      
108 Pas d’espace avant un point. =>   * wish : shell utilisant Tk .      
108 Espace(s) en fin de ligne à supprimer. =>   * wish : shell utilisant Tk .      

112 Mot inconnu : sh => La commande **sh** est en fait un lien symbolique vers l'interpréteur de commandes par défaut : **/bin/dash**.
112 Il manque un espace insécable. => La commande **sh** est en fait un lien symbolique vers l'interpréteur de commandes par défaut : **/bin/dash**.

115 Mot inconnu : bash => Il faut savoir que en bash les variables sont toutes des chaînes de caractères.\\

116 Il manque un espace insécable. => Cela dépendra de son USAGE, pour une opération arithmétique prochaine voir : let ma_variable sinon pour conserver une valeur : 
116 Mot inconnu : ma_variable => Cela dépendra de son USAGE, pour une opération arithmétique prochaine voir : let ma_variable sinon pour conserver une valeur : 
116 Il manque un espace insécable. => Cela dépendra de son USAGE, pour une opération arithmétique prochaine voir : let ma_variable sinon pour conserver une valeur : 
116 Espace(s) en fin de ligne à supprimer. => Cela dépendra de son USAGE, pour une opération arithmétique prochaine voir : let ma_variable sinon pour conserver une valeur : 

117 Il manque un espace insécable. => il suffit de lui donner un nom et une valeur avec l'affectation égale :

119 Mot inconnu : ma_variable => ma_variable=unmot
119 Mot inconnu : unmot => ma_variable=unmot

121 Espace(s) surnuméraire(s) à supprimer. => Ici  la valeur est affectée à la variable ma_variable .\\
121 Mot inconnu : ma_variable => Ici  la valeur est affectée à la variable ma_variable .\\

122 Il manque un espace insécable. => Attention: pas d'espace ni avant ni après le signe "=" .\\

123 Il manque un espace insécable. => Autre exemple avec une commande avec arguments :

124 Mot inconnu : nbre_lignes => <code bash>nbre_lignes=$(wc -l < fichier.ext)</code>
124 Mot inconnu : wc => <code bash>nbre_lignes=$(wc -l < fichier.ext)</code>
124 Il manque un espace à côté du tiret. => <code bash>nbre_lignes=$(wc -l < fichier.ext)</code>
124 Mot inconnu : ext => <code bash>nbre_lignes=$(wc -l < fichier.ext)</code>

125 Mot inconnu : nbre_lignes => //nbre_lignes// contiendra le nombre de lignes contenu dans //fichier.ext// .
125 Mot inconnu : ext => //nbre_lignes// contiendra le nombre de lignes contenu dans //fichier.ext// .

127 Mot inconnu : echo => Pour voir le contenu d'une variable, on utilisera echo (par exemple) :
127 Il manque un espace insécable. => Pour voir le contenu d'une variable, on utilisera echo (par exemple) :

128 Mot inconnu : echo => <code bash>echo $ma_variable</code>
128 Mot inconnu : ma_variable => <code bash>echo $ma_variable</code>

129 Il manque un espace insécable. => renverra : unmot .
129 Mot inconnu : unmot => renverra : unmot .

131 Il manque un espace insécable. => Pour gérer les espaces et autres caractères spéciaux du shell, on utilisera les guillemets ou bien une notation avec des apostrophes :

132 Mot inconnu : echo => <code bash>echo $ma_variable</code>
132 Mot inconnu : ma_variable => <code bash>echo $ma_variable</code>

133 Mot inconnu : echo => <code bash>echo "$ma_variable"</code>
133 Mot inconnu : ma_variable => <code bash>echo "$ma_variable"</code>
133 Guillemets typographiques fermants. => <code bash>echo "$ma_variable"</code>

134 Mot inconnu : echo => <code bash>echo ${ma_variable}</code>
134 Mot inconnu : ma_variable => <code bash>echo ${ma_variable}</code>

135 Mot inconnu : echo => <code bash>echo "${ma_variable}"</code>
135 Mot inconnu : ma_variable => <code bash>echo "${ma_variable}"</code>

136 Il manque un espace insécable. => renverront toutes la même réponse : unmot .
136 Mot inconnu : unmot => renverront toutes la même réponse : unmot .

138 Il manque un espace insécable. => Et avec des chemins de répertoires :

140 Mot inconnu : chemin_de_base => chemin_de_base="/home/username/un repertoire avec espaces"
140 Mot inconnu : repertoire => chemin_de_base="/home/username/un repertoire avec espaces"
140 Guillemets typographiques fermants. => chemin_de_base="/home/username/un repertoire avec espaces"

141 Mot inconnu : chemin_complet => chemin_complet="$chemin_de_base/repertoire"
141 Mot inconnu : chemin_de_base => chemin_complet="$chemin_de_base/repertoire"
141 Mot inconnu : repertoire => chemin_complet="$chemin_de_base/repertoire"
141 Guillemets typographiques fermants. => chemin_complet="$chemin_de_base/repertoire"

143 Mot inconnu : rsync => <note important>Comme on le voit ci-dessus si on met une chaîne de caractères avec des espaces entre guillemets, la variable la prend bien mais attention à l'utiliser aussi avec des guillemets… <code bash>rsync -av "$chemin_complet" …</code>sinon les espaces reprennent leurs rôles de séparateur!</note>
143 Il manque un espace à côté du tiret. => <note important>Comme on le voit ci-dessus si on met une chaîne de caractères avec des espaces entre guillemets, la variable la prend bien mais attention à l'utiliser aussi avec des guillemets… <code bash>rsync -av "$chemin_complet" …</code>sinon les espaces reprennent leurs rôles de séparateur!</note>
143 Mot inconnu : chemin_complet => <note important>Comme on le voit ci-dessus si on met une chaîne de caractères avec des espaces entre guillemets, la variable la prend bien mais attention à l'utiliser aussi avec des guillemets… <code bash>rsync -av "$chemin_complet" …</code>sinon les espaces reprennent leurs rôles de séparateur!</note>
143 Guillemets typographiques fermants. => <note important>Comme on le voit ci-dessus si on met une chaîne de caractères avec des espaces entre guillemets, la variable la prend bien mais attention à l'utiliser aussi avec des guillemets… <code bash>rsync -av "$chemin_complet" …</code>sinon les espaces reprennent leurs rôles de séparateur!</note>
143 Il manque un espace insécable. => <note important>Comme on le voit ci-dessus si on met une chaîne de caractères avec des espaces entre guillemets, la variable la prend bien mais attention à l'utiliser aussi avec des guillemets… <code bash>rsync -av "$chemin_complet" …</code>sinon les espaces reprennent leurs rôles de séparateur!</note>

144 Accord de nombre erroné avec « Des variables » : « système » devrait être au pluriel. => Des variables système permettent d'accélérer la saisie et la compréhension.

145 Il manque un espace insécable. => Pour voir les variables d'environnement de votre système tapez simplement :

148 Il manque un espace insécable. => Quelques variables d'environnement à connaître :

149 Mot inconnu : PATH => HOME, USER, PATH, IFS,...
149 Erreur de numérisation ? Virgules au lieu de points ? => HOME, USER, PATH, IFS,...
149 Typographie : points de suspension. Utilisez le caractère dédié. => HOME, USER, PATH, IFS,...

151 Il manque un espace insécable. => Pour appeler ou voir une variable, par exemple HOME, il suffit de mettre un $ devant, par exemple :

152 Mot inconnu : echo => <code bash>echo $HOME</code>

154 Accord de genre erroné : « la variable » est féminin, « HOME » est masculin. => Ce petit code va afficher la variable HOME à l'écran.

156 Il manque un espace insécable. => Il existe des variables un peu spéciales :

163 Mot inconnu : PID => |$!| contient le PID de la dernière commande lancée|

165 Il manque un espace insécable. => Exemple : créer le fichier arg.sh avec le contenu qui suit :
165 Mot inconnu : arg => Exemple : créer le fichier arg.sh avec le contenu qui suit :
165 Mot inconnu : sh => Exemple : créer le fichier arg.sh avec le contenu qui suit :
165 Il manque un espace insécable. => Exemple : créer le fichier arg.sh avec le contenu qui suit :

167 Il manque un espace insécable. => #!/bin/bash

168 Mot inconnu : echo => echo "Nombre d'arguments ... :  "$#
168 Guillemets typographiques ouvrants. => echo "Nombre d'arguments ... :  "$#
168 Typographie : points de suspension. Utilisez le caractère dédié. => echo "Nombre d'arguments ... :  "$#
168 Il manque un espace insécable. => echo "Nombre d'arguments ... :  "$#
168 Espace(s) surnuméraire(s) à supprimer. => echo "Nombre d'arguments ... :  "$#

169 Mot inconnu : echo => echo "Les arguments sont ... :  "$*
169 Guillemets typographiques ouvrants. => echo "Les arguments sont ... :  "$*
169 Typographie : points de suspension. Utilisez le caractère dédié. => echo "Les arguments sont ... :  "$*
169 Il manque un espace insécable. => echo "Les arguments sont ... :  "$*
169 Espace(s) surnuméraire(s) à supprimer. => echo "Les arguments sont ... :  "$*

170 Mot inconnu : echo => echo "Le second argument est :  "$2
170 Guillemets typographiques ouvrants. => echo "Le second argument est :  "$2
170 Il manque un espace insécable. => echo "Le second argument est :  "$2
170 Espace(s) surnuméraire(s) à supprimer. => echo "Le second argument est :  "$2

172 Mot inconnu : echo => echo "Et le code de retour du dernier echo est :  "$?
172 Guillemets typographiques ouvrants. => echo "Et le code de retour du dernier echo est :  "$?
172 Mot inconnu : echo => echo "Et le code de retour du dernier echo est :  "$?
172 Il manque un espace insécable. => echo "Et le code de retour du dernier echo est :  "$?
172 Espace(s) surnuméraire(s) à supprimer. => echo "Et le code de retour du dernier echo est :  "$?

174 Il manque un espace insécable. => Lancez ce script avec un ou plusieurs arguments et vous aurez :

176 Mot inconnu : arg => ./arg.sh 1 2 3
176 Mot inconnu : sh => ./arg.sh 1 2 3

177 Typographie : points de suspension. Utilisez le caractère dédié. => Nombre d'arguments ... :  3
177 Il manque un espace insécable. => Nombre d'arguments ... :  3
177 Espace(s) surnuméraire(s) à supprimer. => Nombre d'arguments ... :  3

178 Typographie : points de suspension. Utilisez le caractère dédié. => Les arguments sont ... :  1 2 3
178 Il manque un espace insécable. => Les arguments sont ... :  1 2 3
178 Espace(s) surnuméraire(s) à supprimer. => Les arguments sont ... :  1 2 3

179 Il manque un espace insécable. => Le second argument est :  2
179 Espace(s) surnuméraire(s) à supprimer. => Le second argument est :  2

180 Mot inconnu : echo => Et le code de retour du dernier echo est :  0
180 Il manque un espace insécable. => Et le code de retour du dernier echo est :  0
180 Espace(s) surnuméraire(s) à supprimer. => Et le code de retour du dernier echo est :  0

183 Il manque un espace insécable. => Exemple: un sleep interactif pour illustrer $! (Cf. [[:tutoriel:script_shell#les_fonctions|les fonctions]]).\\ 
183 Mot inconnu : sleep => Exemple: un sleep interactif pour illustrer $! (Cf. [[:tutoriel:script_shell#les_fonctions|les fonctions]]).\\ 
183 Il manque un espace. => Exemple: un sleep interactif pour illustrer $! (Cf. [[:tutoriel:script_shell#les_fonctions|les fonctions]]).\\ 
183 Espace(s) en fin de ligne à supprimer. => Exemple: un sleep interactif pour illustrer $! (Cf. [[:tutoriel:script_shell#les_fonctions|les fonctions]]).\\ 

184 Il manque un espace insécable. => Pour déclarer un tableau, plusieurs méthodes :\\ 
184 Espace(s) en fin de ligne à supprimer. => Pour déclarer un tableau, plusieurs méthodes :\\ 

185 Mot inconnu : bash => première méthode (compatible bash, zsh, et ksh93 mais pas ksh88, ni avec dash, qui est lancé par "sh") :
185 Mot inconnu : zsh => première méthode (compatible bash, zsh, et ksh93 mais pas ksh88, ni avec dash, qui est lancé par "sh") :
185 Mot inconnu : ksh93 => première méthode (compatible bash, zsh, et ksh93 mais pas ksh88, ni avec dash, qui est lancé par "sh") :
185 Mot inconnu : ksh88 => première méthode (compatible bash, zsh, et ksh93 mais pas ksh88, ni avec dash, qui est lancé par "sh") :
185 Mot inconnu : dash => première méthode (compatible bash, zsh, et ksh93 mais pas ksh88, ni avec dash, qui est lancé par "sh") :
185 Guillemets typographiques ouvrants. => première méthode (compatible bash, zsh, et ksh93 mais pas ksh88, ni avec dash, qui est lancé par "sh") :
185 Mot inconnu : sh => première méthode (compatible bash, zsh, et ksh93 mais pas ksh88, ni avec dash, qui est lancé par "sh") :
185 Guillemets typographiques fermants. => première méthode (compatible bash, zsh, et ksh93 mais pas ksh88, ni avec dash, qui est lancé par "sh") :
185 Il manque un espace insécable. => première méthode (compatible bash, zsh, et ksh93 mais pas ksh88, ni avec dash, qui est lancé par "sh") :

186 Mot inconnu : tab => <code bash>tab=("John Smith" "Jane Doe")</code>
186 Guillemets typographiques ouvrants. => <code bash>tab=("John Smith" "Jane Doe")</code>
186 Guillemets typographiques fermants. => <code bash>tab=("John Smith" "Jane Doe")</code>
186 Guillemets typographiques ouvrants. => <code bash>tab=("John Smith" "Jane Doe")</code>
186 Mot inconnu : Doe => <code bash>tab=("John Smith" "Jane Doe")</code>
186 Guillemets typographiques fermants. => <code bash>tab=("John Smith" "Jane Doe")</code>

188 Il manque un espace insécable. => ou bien :

190 Mot inconnu : tab => tab[0]='John Smith'
190 Guillemets typographiques fermants. => tab[0]='John Smith'

191 Mot inconnu : tab => tab[1]='Jane Doe'
191 Mot inconnu : Doe => tab[1]='Jane Doe'
191 Guillemets typographiques fermants. => tab[1]='Jane Doe'

194 Il manque un espace insécable. => Pour compter le nombre d'éléments du tableau :

196 Mot inconnu : len => len=${#tab[*]} ou echo ${#tab[@]}
196 Mot inconnu : echo => len=${#tab[*]} ou echo ${#tab[@]}

199 Il manque un espace insécable. => Pour afficher un élément :

201 Mot inconnu : echo => echo ${tab[1]}
201 Mot inconnu : tab => echo ${tab[1]}

204 Il manque un espace insécable. => Pour afficher tous les éléments :

205 Mot inconnu : echo => <code bash>echo ${tab[@]}</code>
205 Mot inconnu : tab => <code bash>echo ${tab[@]}</code>

206 Mot inconnu : bash => ou bien (en bash ou en ksh93 mais pas en ksh88) :
206 Mot inconnu : ksh93 => ou bien (en bash ou en ksh93 mais pas en ksh88) :
206 Mot inconnu : ksh88 => ou bien (en bash ou en ksh93 mais pas en ksh88) :
206 Il manque un espace insécable. => ou bien (en bash ou en ksh93 mais pas en ksh88) :

207 Il manque un espace. => <code bash>for i in ${!tab[@]}; do echo ${tab[i]}; done</code>
207 Mot inconnu : tab => <code bash>for i in ${!tab[@]}; do echo ${tab[i]}; done</code>
207 Mot inconnu : echo => <code bash>for i in ${!tab[@]}; do echo ${tab[i]}; done</code>
207 Mot inconnu : tab => <code bash>for i in ${!tab[@]}; do echo ${tab[i]}; done</code>
207 Mot inconnu : done => <code bash>for i in ${!tab[@]}; do echo ${tab[i]}; done</code>

208 Pas d’espace après ce signe. => ou encore ( C style ) :
208 Pas d’espace avant ce signe. => ou encore ( C style ) :
208 Il manque un espace insécable. => ou encore ( C style ) :

209 Pas d’espace après ce signe. => <code bash>for (( i=0; i < ${#tab[@]}; i++ )); do echo ${tab[i]}; done</code>
209 Il manque un espace insécable. => <code bash>for (( i=0; i < ${#tab[@]}; i++ )); do echo ${tab[i]}; done</code>
209 Pas d’espace avant ce signe. => <code bash>for (( i=0; i < ${#tab[@]}; i++ )); do echo ${tab[i]}; done</code>
209 Mot inconnu : echo => <code bash>for (( i=0; i < ${#tab[@]}; i++ )); do echo ${tab[i]}; done</code>
209 Mot inconnu : tab => <code bash>for (( i=0; i < ${#tab[@]}; i++ )); do echo ${tab[i]}; done</code>
209 Mot inconnu : done => <code bash>for (( i=0; i < ${#tab[@]}; i++ )); do echo ${tab[i]}; done</code>

212 Mot inconnu : NB => NB : toutes les variables sont des tableaux. Par défaut, c'est le premier élément qui est appelé :
212 Il manque un espace insécable. => NB : toutes les variables sont des tableaux. Par défaut, c'est le premier élément qui est appelé :
212 Il manque un espace insécable. => NB : toutes les variables sont des tableaux. Par défaut, c'est le premier élément qui est appelé :

213 Mot inconnu : echo => <code bash>echo ${tab[0]}</code>
213 Mot inconnu : tab => <code bash>echo ${tab[0]}</code>

214 Il manque un espace insécable. => et :

215 Mot inconnu : echo => <code bash>echo ${tab}</code>
215 Mot inconnu : tab => <code bash>echo ${tab}</code>

218 Mot inconnu : NB2 => NB2 : les tableaux sont séparés par un séparateur défini : l'IFS. 
218 Il manque un espace insécable. => NB2 : les tableaux sont séparés par un séparateur défini : l'IFS. 
218 Il manque un espace insécable. => NB2 : les tableaux sont séparés par un séparateur défini : l'IFS. 
218 Accord de nombre erroné : après « l’ », « IFS » devrait être au singulier. => NB2 : les tableaux sont séparés par un séparateur défini : l'IFS. 
218 Espace(s) en fin de ligne à supprimer. => NB2 : les tableaux sont séparés par un séparateur défini : l'IFS. 

219 Accord de nombre erroné : après « l’ », « IFS » devrait être au singulier. => Par défaut l'IFS est composé des trois caractères : $' \t\n' soit espace, tabulation, saut de ligne. 
219 Il manque un espace insécable. => Par défaut l'IFS est composé des trois caractères : $' \t\n' soit espace, tabulation, saut de ligne. 
219 Guillemets typographiques fermants. => Par défaut l'IFS est composé des trois caractères : $' \t\n' soit espace, tabulation, saut de ligne. 
219 Espace(s) en fin de ligne à supprimer. => Par défaut l'IFS est composé des trois caractères : $' \t\n' soit espace, tabulation, saut de ligne. 

221 Mot inconnu : SEPARATEUR => <code bash>IFS=$SEPARATEUR</code>

222 Mot inconnu : SEPARATEUR => $SEPARATEUR pourra être :
222 Il manque un espace insécable. => $SEPARATEUR pourra être :

223 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * une lettre (pe : n, i,...)
223 Mot inconnu : pe =>   * une lettre (pe : n, i,...)
223 Il manque un espace insécable. =>   * une lettre (pe : n, i,...)
223 Erreur de numérisation ? Virgules au lieu de points ? =>   * une lettre (pe : n, i,...)
223 Typographie : points de suspension. Utilisez le caractère dédié. =>   * une lettre (pe : n, i,...)

224 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * une ponctuation (pe : ',', '.', '-'...)
224 Mot inconnu : pe =>   * une ponctuation (pe : ',', '.', '-'...)
224 Il manque un espace insécable. =>   * une ponctuation (pe : ',', '.', '-'...)
224 Typographie : points de suspension. Utilisez le caractère dédié. =>   * une ponctuation (pe : ',', '.', '-'...)

225 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * un caractère spécial : ($'\t' : tabulation, $'\n' : saut de ligne,...)
225 Il manque un espace insécable. =>   * un caractère spécial : ($'\t' : tabulation, $'\n' : saut de ligne,...)
225 Guillemets typographiques fermants. =>   * un caractère spécial : ($'\t' : tabulation, $'\n' : saut de ligne,...)
225 Il manque un espace insécable. =>   * un caractère spécial : ($'\t' : tabulation, $'\n' : saut de ligne,...)
225 Guillemets typographiques fermants. =>   * un caractère spécial : ($'\t' : tabulation, $'\n' : saut de ligne,...)
225 Il manque un espace insécable. =>   * un caractère spécial : ($'\t' : tabulation, $'\n' : saut de ligne,...)
225 Erreur de numérisation ? Virgules au lieu de points ? =>   * un caractère spécial : ($'\t' : tabulation, $'\n' : saut de ligne,...)
225 Typographie : points de suspension. Utilisez le caractère dédié. =>   * un caractère spécial : ($'\t' : tabulation, $'\n' : saut de ligne,...)

229 Il manque un espace insécable. => Pour passer des arguments en ligne de commande c'est encore une fois très simple. Chaque argument est numéroté et ensuite on l'appelle par son numéro :

231 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>    ./test.sh powa noplay
231 Mot inconnu : sh =>    ./test.sh powa noplay
231 Mot inconnu : powa =>    ./test.sh powa noplay
231 Mot inconnu : noplay =>    ./test.sh powa noplay

233 Mot inconnu : sh => Voici notre test.sh

235 Il manque un espace insécable. => #!/bin/sh

236 Mot inconnu : echo => echo $3

237 Mot inconnu : echo => echo $2

242 Guillemets typographiques ouvrants. => ''shift'' est une commande très pratique lorsque vous traitez des arguments en ligne de commande. Elle permet de faire "défiler" les arguments ($0, $1, $2, …). C'est à dire que le contenu de $1 passe dans $0, celui de $2 dans $1 et ainsi de suite. Il est tout à fait possible de traiter les arguments avec ''for i in $*; do'' mais lorsque vous aurez des options du style ''–title "mon_titre"'' il sera très laborieux de récupérer la valeur ''"mon_titre"''.
242 Mot inconnu : shift => ''shift'' est une commande très pratique lorsque vous traitez des arguments en ligne de commande. Elle permet de faire "défiler" les arguments ($0, $1, $2, …). C'est à dire que le contenu de $1 passe dans $0, celui de $2 dans $1 et ainsi de suite. Il est tout à fait possible de traiter les arguments avec ''for i in $*; do'' mais lorsque vous aurez des options du style ''–title "mon_titre"'' il sera très laborieux de récupérer la valeur ''"mon_titre"''.
242 Guillemets typographiques fermants. => ''shift'' est une commande très pratique lorsque vous traitez des arguments en ligne de commande. Elle permet de faire "défiler" les arguments ($0, $1, $2, …). C'est à dire que le contenu de $1 passe dans $0, celui de $2 dans $1 et ainsi de suite. Il est tout à fait possible de traiter les arguments avec ''for i in $*; do'' mais lorsque vous aurez des options du style ''–title "mon_titre"'' il sera très laborieux de récupérer la valeur ''"mon_titre"''.
242 Guillemets typographiques ouvrants. => ''shift'' est une commande très pratique lorsque vous traitez des arguments en ligne de commande. Elle permet de faire "défiler" les arguments ($0, $1, $2, …). C'est à dire que le contenu de $1 passe dans $0, celui de $2 dans $1 et ainsi de suite. Il est tout à fait possible de traiter les arguments avec ''for i in $*; do'' mais lorsque vous aurez des options du style ''–title "mon_titre"'' il sera très laborieux de récupérer la valeur ''"mon_titre"''.
242 Guillemets typographiques fermants. => ''shift'' est une commande très pratique lorsque vous traitez des arguments en ligne de commande. Elle permet de faire "défiler" les arguments ($0, $1, $2, …). C'est à dire que le contenu de $1 passe dans $0, celui de $2 dans $1 et ainsi de suite. Il est tout à fait possible de traiter les arguments avec ''for i in $*; do'' mais lorsque vous aurez des options du style ''–title "mon_titre"'' il sera très laborieux de récupérer la valeur ''"mon_titre"''.
242 Typographie : pas de virgule avant les points de suspension. => ''shift'' est une commande très pratique lorsque vous traitez des arguments en ligne de commande. Elle permet de faire "défiler" les arguments ($0, $1, $2, …). C'est à dire que le contenu de $1 passe dans $0, celui de $2 dans $1 et ainsi de suite. Il est tout à fait possible de traiter les arguments avec ''for i in $*; do'' mais lorsque vous aurez des options du style ''–title "mon_titre"'' il sera très laborieux de récupérer la valeur ''"mon_titre"''.
242 Il manque les traits d’union. => ''shift'' est une commande très pratique lorsque vous traitez des arguments en ligne de commande. Elle permet de faire "défiler" les arguments ($0, $1, $2, …). C'est à dire que le contenu de $1 passe dans $0, celui de $2 dans $1 et ainsi de suite. Il est tout à fait possible de traiter les arguments avec ''for i in $*; do'' mais lorsque vous aurez des options du style ''–title "mon_titre"'' il sera très laborieux de récupérer la valeur ''"mon_titre"''.
242 Guillemets typographiques ouvrants. => ''shift'' est une commande très pratique lorsque vous traitez des arguments en ligne de commande. Elle permet de faire "défiler" les arguments ($0, $1, $2, …). C'est à dire que le contenu de $1 passe dans $0, celui de $2 dans $1 et ainsi de suite. Il est tout à fait possible de traiter les arguments avec ''for i in $*; do'' mais lorsque vous aurez des options du style ''–title "mon_titre"'' il sera très laborieux de récupérer la valeur ''"mon_titre"''.
242 Guillemets typographiques fermants. => ''shift'' est une commande très pratique lorsque vous traitez des arguments en ligne de commande. Elle permet de faire "défiler" les arguments ($0, $1, $2, …). C'est à dire que le contenu de $1 passe dans $0, celui de $2 dans $1 et ainsi de suite. Il est tout à fait possible de traiter les arguments avec ''for i in $*; do'' mais lorsque vous aurez des options du style ''–title "mon_titre"'' il sera très laborieux de récupérer la valeur ''"mon_titre"''.
242 Mot inconnu : title => ''shift'' est une commande très pratique lorsque vous traitez des arguments en ligne de commande. Elle permet de faire "défiler" les arguments ($0, $1, $2, …). C'est à dire que le contenu de $1 passe dans $0, celui de $2 dans $1 et ainsi de suite. Il est tout à fait possible de traiter les arguments avec ''for i in $*; do'' mais lorsque vous aurez des options du style ''–title "mon_titre"'' il sera très laborieux de récupérer la valeur ''"mon_titre"''.
242 Guillemets typographiques ouvrants. => ''shift'' est une commande très pratique lorsque vous traitez des arguments en ligne de commande. Elle permet de faire "défiler" les arguments ($0, $1, $2, …). C'est à dire que le contenu de $1 passe dans $0, celui de $2 dans $1 et ainsi de suite. Il est tout à fait possible de traiter les arguments avec ''for i in $*; do'' mais lorsque vous aurez des options du style ''–title "mon_titre"'' il sera très laborieux de récupérer la valeur ''"mon_titre"''.
242 Mot inconnu : mon_titre => ''shift'' est une commande très pratique lorsque vous traitez des arguments en ligne de commande. Elle permet de faire "défiler" les arguments ($0, $1, $2, …). C'est à dire que le contenu de $1 passe dans $0, celui de $2 dans $1 et ainsi de suite. Il est tout à fait possible de traiter les arguments avec ''for i in $*; do'' mais lorsque vous aurez des options du style ''–title "mon_titre"'' il sera très laborieux de récupérer la valeur ''"mon_titre"''.
242 Guillemets typographiques fermants. => ''shift'' est une commande très pratique lorsque vous traitez des arguments en ligne de commande. Elle permet de faire "défiler" les arguments ($0, $1, $2, …). C'est à dire que le contenu de $1 passe dans $0, celui de $2 dans $1 et ainsi de suite. Il est tout à fait possible de traiter les arguments avec ''for i in $*; do'' mais lorsque vous aurez des options du style ''–title "mon_titre"'' il sera très laborieux de récupérer la valeur ''"mon_titre"''.
242 Guillemets typographiques ouvrants. => ''shift'' est une commande très pratique lorsque vous traitez des arguments en ligne de commande. Elle permet de faire "défiler" les arguments ($0, $1, $2, …). C'est à dire que le contenu de $1 passe dans $0, celui de $2 dans $1 et ainsi de suite. Il est tout à fait possible de traiter les arguments avec ''for i in $*; do'' mais lorsque vous aurez des options du style ''–title "mon_titre"'' il sera très laborieux de récupérer la valeur ''"mon_titre"''.
242 Mot inconnu : mon_titre => ''shift'' est une commande très pratique lorsque vous traitez des arguments en ligne de commande. Elle permet de faire "défiler" les arguments ($0, $1, $2, …). C'est à dire que le contenu de $1 passe dans $0, celui de $2 dans $1 et ainsi de suite. Il est tout à fait possible de traiter les arguments avec ''for i in $*; do'' mais lorsque vous aurez des options du style ''–title "mon_titre"'' il sera très laborieux de récupérer la valeur ''"mon_titre"''.
242 Guillemets typographiques fermants. => ''shift'' est une commande très pratique lorsque vous traitez des arguments en ligne de commande. Elle permet de faire "défiler" les arguments ($0, $1, $2, …). C'est à dire que le contenu de $1 passe dans $0, celui de $2 dans $1 et ainsi de suite. Il est tout à fait possible de traiter les arguments avec ''for i in $*; do'' mais lorsque vous aurez des options du style ''–title "mon_titre"'' il sera très laborieux de récupérer la valeur ''"mon_titre"''.

244 Il manque un espace insécable. => Voici un exemple de script où vous devez vous souvenir de ce que vous avez écrit (un petit jeu de mémoire, quoi) :

245 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>  <code bash>

246 Il manque un espace insécable. => #!/bin/sh

247 Mot inconnu : clear => clear # Un peu facile si la commande reste au dessus :-)
247 Il manque un trait d’union. => clear # Un peu facile si la commande reste au dessus :-)

248 Mot inconnu : until => until [ $# = 0 ]
248 Pas d’espace après ce signe. => until [ $# = 0 ]
248 Pas d’espace avant ce signe. => until [ $# = 0 ]

250 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   echo -n "Taper l'option suivante : "
250 Mot inconnu : echo =>   echo -n "Taper l'option suivante : "
250 Il manque un espace à côté du tiret. =>   echo -n "Taper l'option suivante : "
250 Guillemets typographiques ouvrants. =>   echo -n "Taper l'option suivante : "
250 Il manque un espace insécable. =>   echo -n "Taper l'option suivante : "
250 Guillemets fermants. =>   echo -n "Taper l'option suivante : "

251 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   read Reslt
251 Mot inconnu : read =>   read Reslt
251 Mot inconnu : Reslt =>   read Reslt

252 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   if [ "$Reslt" = "$1" ]; then
252 Pas d’espace après ce signe. =>   if [ "$Reslt" = "$1" ]; then
252 Mot inconnu : Reslt =>   if [ "$Reslt" = "$1" ]; then
252 Guillemets typographiques fermants. =>   if [ "$Reslt" = "$1" ]; then
252 Guillemets typographiques fermants. =>   if [ "$Reslt" = "$1" ]; then
252 Pas d’espace avant ce signe. =>   if [ "$Reslt" = "$1" ]; then
252 Mot inconnu : then =>   if [ "$Reslt" = "$1" ]; then

253 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     echo "Bien joué !"
253 Mot inconnu : echo =>     echo "Bien joué !"
253 Guillemets typographiques ouvrants. =>     echo "Bien joué !"
253 Il manque un espace insécable. =>     echo "Bien joué !"
253 Guillemets typographiques fermants. =>     echo "Bien joué !"

254 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   else
254 Mot inconnu : else =>   else

255 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     echo "Non mais quand même !!! C'ÉTAIT $1 ET NON PAS $Reslt PETIT FRIPON !!!"
255 Mot inconnu : echo =>     echo "Non mais quand même !!! C'ÉTAIT $1 ET NON PAS $Reslt PETIT FRIPON !!!"
255 Guillemets typographiques ouvrants. =>     echo "Non mais quand même !!! C'ÉTAIT $1 ET NON PAS $Reslt PETIT FRIPON !!!"
255 Il manque un espace insécable. =>     echo "Non mais quand même !!! C'ÉTAIT $1 ET NON PAS $Reslt PETIT FRIPON !!!"
255 Mot inconnu : Reslt =>     echo "Non mais quand même !!! C'ÉTAIT $1 ET NON PAS $Reslt PETIT FRIPON !!!"
255 Il manque un espace insécable. =>     echo "Non mais quand même !!! C'ÉTAIT $1 ET NON PAS $Reslt PETIT FRIPON !!!"
255 Guillemets typographiques fermants. =>     echo "Non mais quand même !!! C'ÉTAIT $1 ET NON PAS $Reslt PETIT FRIPON !!!"

256 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     sleep 3 # Juste pour le fun du script qui rage ;-p
256 Mot inconnu : sleep =>     sleep 3 # Juste pour le fun du script qui rage ;-p
256 Il manque un espace insécable. =>     sleep 3 # Juste pour le fun du script qui rage ;-p

257 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     echo "Donc je te bannis de ubuntu-fr.org ! Et toc !! Tu ne peux rien contre moi !!!"
257 Mot inconnu : echo =>     echo "Donc je te bannis de ubuntu-fr.org ! Et toc !! Tu ne peux rien contre moi !!!"
257 Guillemets typographiques ouvrants. =>     echo "Donc je te bannis de ubuntu-fr.org ! Et toc !! Tu ne peux rien contre moi !!!"
257 Mot inconnu : ubuntu-fr =>     echo "Donc je te bannis de ubuntu-fr.org ! Et toc !! Tu ne peux rien contre moi !!!"
257 Il manque un espace insécable. =>     echo "Donc je te bannis de ubuntu-fr.org ! Et toc !! Tu ne peux rien contre moi !!!"
257 Il manque un espace insécable. =>     echo "Donc je te bannis de ubuntu-fr.org ! Et toc !! Tu ne peux rien contre moi !!!"
257 Il manque un espace insécable. =>     echo "Donc je te bannis de ubuntu-fr.org ! Et toc !! Tu ne peux rien contre moi !!!"
257 Guillemets typographiques fermants. =>     echo "Donc je te bannis de ubuntu-fr.org ! Et toc !! Tu ne peux rien contre moi !!!"

258 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     exit 1

259 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   fi

260 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   shift # On défile
260 Mot inconnu : shift =>   shift # On défile

261 Mot inconnu : done => done

262 Mot inconnu : echo => echo "Vous avez réussi !"
262 Guillemets typographiques ouvrants. => echo "Vous avez réussi !"
262 Il manque un espace insécable. => echo "Vous avez réussi !"
262 Guillemets typographiques fermants. => echo "Vous avez réussi !"

266 Pas d’espace après ce signe. => <code bash>(( variable = 2 + $autre_var * 5 ))</code>
266 Mot inconnu : autre_var => <code bash>(( variable = 2 + $autre_var * 5 ))</code>
266 Pas d’espace avant ce signe. => <code bash>(( variable = 2 + $autre_var * 5 ))</code>

267 Il manque un espace insécable. => Exemple: besoin de définir des plages de valeurs (1 à 500 puis 501 à 1000 puis 1001 à 1500…)

269 Mot inconnu : id_per_step => id_per_step = 500

270 Pas d’espace après ce signe. => for (( i=0; i<8; i++ )); do
270 Il manque un espace insécable. => for (( i=0; i<8; i++ )); do
270 Il manque un espace insécable. => for (( i=0; i<8; i++ )); do
270 Pas d’espace avant ce signe. => for (( i=0; i<8; i++ )); do

271 Pas d’espace après ce signe. => 	(( min_step_id = 1 + $i * $id_per_step ))
271 Mot inconnu : min_step_id => 	(( min_step_id = 1 + $i * $id_per_step ))
271 Mot inconnu : id_per_step => 	(( min_step_id = 1 + $i * $id_per_step ))
271 Pas d’espace avant ce signe. => 	(( min_step_id = 1 + $i * $id_per_step ))

272 Pas d’espace après ce signe. => 	(( max_step_id = (( $i + 1 )) * $id_per_step ))
272 Mot inconnu : max_step_id => 	(( max_step_id = (( $i + 1 )) * $id_per_step ))
272 Pas d’espace après ce signe. => 	(( max_step_id = (( $i + 1 )) * $id_per_step ))
272 Pas d’espace avant ce signe. => 	(( max_step_id = (( $i + 1 )) * $id_per_step ))
272 Mot inconnu : id_per_step => 	(( max_step_id = (( $i + 1 )) * $id_per_step ))
272 Pas d’espace avant ce signe. => 	(( max_step_id = (( $i + 1 )) * $id_per_step ))

273 Mot inconnu : echo => 	echo "$min_step_id to $max_step_id "
273 Mot inconnu : min_step_id => 	echo "$min_step_id to $max_step_id "
273 Mot inconnu : to => 	echo "$min_step_id to $max_step_id "
273 Mot inconnu : max_step_id => 	echo "$min_step_id to $max_step_id "
273 Guillemets fermants. => 	echo "$min_step_id to $max_step_id "

274 Mot inconnu : done => done

282 Pas d’espace avant ce signe. => En mode console, faites [[http://www.bash-linux.com/unix-man-test-francais.html| man test ]] pour connaître tous les opérateurs, en voici quelques-uns :
282 Il manque un espace insécable. => En mode console, faites [[http://www.bash-linux.com/unix-man-test-francais.html| man test ]] pour connaître tous les opérateurs, en voici quelques-uns :

287 Espace(s) surnuméraire(s) à supprimer. => | -e fichier      | renvoie 0 si fichier existe.                           |
287 Espace(s) surnuméraire(s) à supprimer. => | -e fichier      | renvoie 0 si fichier existe.                           |

288 Espace(s) surnuméraire(s) à supprimer. => | -d fichier      | renvoie 0 si fichier existe et est un répertoire.      |
288 Espace(s) surnuméraire(s) à supprimer. => | -d fichier      | renvoie 0 si fichier existe et est un répertoire.      |

289 Espace(s) surnuméraire(s) à supprimer. => | -f fichier      | renvoie 0 si fichier existe et est un fichier 'normal'.|
289 Guillemets typographiques ouvrants. => | -f fichier      | renvoie 0 si fichier existe et est un fichier 'normal'.|

290 Espace(s) surnuméraire(s) à supprimer. => | -w fichier      | renvoie 0 si fichier existe et est en écriture.        |
290 Espace(s) surnuméraire(s) à supprimer. => | -w fichier      | renvoie 0 si fichier existe et est en écriture.        |

291 Espace(s) surnuméraire(s) à supprimer. => | -x fichier      | renvoie 0 si fichier existe et est exécutable.         |
291 Espace(s) surnuméraire(s) à supprimer. => | -x fichier      | renvoie 0 si fichier existe et est exécutable.         |

292 Mot inconnu : f1 => | f1 -nt f2       | renvoie 0 si f1 est plus récent que f2.                |
292 Il manque un espace à côté du tiret. => | f1 -nt f2       | renvoie 0 si f1 est plus récent que f2.                |
292 Mot inconnu : nt => | f1 -nt f2       | renvoie 0 si f1 est plus récent que f2.                |
292 Mot inconnu : f2 => | f1 -nt f2       | renvoie 0 si f1 est plus récent que f2.                |
292 Espace(s) surnuméraire(s) à supprimer. => | f1 -nt f2       | renvoie 0 si f1 est plus récent que f2.                |
292 Mot inconnu : f1 => | f1 -nt f2       | renvoie 0 si f1 est plus récent que f2.                |
292 Mot inconnu : f2 => | f1 -nt f2       | renvoie 0 si f1 est plus récent que f2.                |
292 Espace(s) surnuméraire(s) à supprimer. => | f1 -nt f2       | renvoie 0 si f1 est plus récent que f2.                |

293 Mot inconnu : f1 => | f1 -ot f2       | renvoie 0 si f1 est plus vieux que f2.                 |
293 Il manque un espace à côté du tiret. => | f1 -ot f2       | renvoie 0 si f1 est plus vieux que f2.                 |
293 Mot inconnu : ot => | f1 -ot f2       | renvoie 0 si f1 est plus vieux que f2.                 |
293 Mot inconnu : f2 => | f1 -ot f2       | renvoie 0 si f1 est plus vieux que f2.                 |
293 Espace(s) surnuméraire(s) à supprimer. => | f1 -ot f2       | renvoie 0 si f1 est plus vieux que f2.                 |
293 Mot inconnu : f1 => | f1 -ot f2       | renvoie 0 si f1 est plus vieux que f2.                 |
293 Mot inconnu : f2 => | f1 -ot f2       | renvoie 0 si f1 est plus vieux que f2.                 |
293 Espace(s) surnuméraire(s) à supprimer. => | f1 -ot f2       | renvoie 0 si f1 est plus vieux que f2.                 |

298 Il manque un espace à côté du tiret. => | $A -lt 5         | renvoie 0 si $A est strictement inférieur à 5 |
298 Mot inconnu : lt => | $A -lt 5         | renvoie 0 si $A est strictement inférieur à 5 |
298 Espace(s) surnuméraire(s) à supprimer. => | $A -lt 5         | renvoie 0 si $A est strictement inférieur à 5 |

299 Il manque un espace à côté du tiret. => | $A -le 5         | renvoie 0 si $A est inférieur ou égal à 5 |
299 Espace(s) surnuméraire(s) à supprimer. => | $A -le 5         | renvoie 0 si $A est inférieur ou égal à 5 |

300 Il manque un espace à côté du tiret. => | $A -gt 5         | renvoie 0 si $A est strictement supérieur à 5 |
300 Mot inconnu : gt => | $A -gt 5         | renvoie 0 si $A est strictement supérieur à 5 |
300 Espace(s) surnuméraire(s) à supprimer. => | $A -gt 5         | renvoie 0 si $A est strictement supérieur à 5 |

301 Il manque un espace à côté du tiret. => | $A -ge 5         | renvoie 0 si $A est supérieur ou égal à 5 |
301 Mot inconnu : ge => | $A -ge 5         | renvoie 0 si $A est supérieur ou égal à 5 |
301 Espace(s) surnuméraire(s) à supprimer. => | $A -ge 5         | renvoie 0 si $A est supérieur ou égal à 5 |

302 Il manque un espace à côté du tiret. => | $A -eq 5         | renvoie 0 si $A est égal à 5 |
302 Mot inconnu : eq => | $A -eq 5         | renvoie 0 si $A est égal à 5 |
302 Espace(s) surnuméraire(s) à supprimer. => | $A -eq 5         | renvoie 0 si $A est égal à 5 |

303 Il manque un espace à côté du tiret. => | $A -ne 5         | renvoie 0 si $A est différent de 5 |
303 Espace(s) surnuméraire(s) à supprimer. => | $A -ne 5         | renvoie 0 si $A est différent de 5 |

307 Il manque un espace insécable. => On peut raccourcir la commande test par des crochets. Exemple :

310 Il manque un espace à côté du tiret. => test -f /etc/passwd

311 Mot inconnu : echo => echo $?

313 Pas d’espace après ce signe. => [ -f /etc/passwd ] 
313 Pas d’espace avant ce signe. => [ -f /etc/passwd ] 
313 Espace(s) en fin de ligne à supprimer. => [ -f /etc/passwd ] 

314 Mot inconnu : echo => echo $?

317 Il manque un espace insécable. => Affichera la valeur 0 : ce fichier existe, 1 dans le cas où le fichier /etc/passwd n'existe pas. Sous Unix, le code de retour est par convention et en général 0 s'il n'y a aucune erreur et différent de 0 dans les autres cas.

319 Il manque un espace insécable. => La syntaxe la plus appropriée dans de la programmation shell moderne est le double crochet :

320 Pas d’espace après ce signe. => <code bash>[[ -f /etc/passwd ]]</code>
320 Pas d’espace avant ce signe. => <code bash>[[ -f /etc/passwd ]]</code>

321 Avant « etc. », il faut mettre une virgule. => Cela gère bien mieux les problèmes d'espaces dans les noms de fichiers, les erreurs etc... C'est une structure <del>propre à</del> bash (ksh, ?) qui est le shell par défaut dans la plupart des distributions Linux, et de Ubuntu en particulier. On garde en général des simples crochets pour les scripts shell qui doivent être à tout prix POSIX ( utilisation sur des Unix sans installation préalable de bash, comme BSD, Solaris... ) .
321 Un seul point après « etc. » => Cela gère bien mieux les problèmes d'espaces dans les noms de fichiers, les erreurs etc... C'est une structure <del>propre à</del> bash (ksh, ?) qui est le shell par défaut dans la plupart des distributions Linux, et de Ubuntu en particulier. On garde en général des simples crochets pour les scripts shell qui doivent être à tout prix POSIX ( utilisation sur des Unix sans installation préalable de bash, comme BSD, Solaris... ) .
321 Mot inconnu : bash => Cela gère bien mieux les problèmes d'espaces dans les noms de fichiers, les erreurs etc... C'est une structure <del>propre à</del> bash (ksh, ?) qui est le shell par défaut dans la plupart des distributions Linux, et de Ubuntu en particulier. On garde en général des simples crochets pour les scripts shell qui doivent être à tout prix POSIX ( utilisation sur des Unix sans installation préalable de bash, comme BSD, Solaris... ) .
321 Mot inconnu : ksh => Cela gère bien mieux les problèmes d'espaces dans les noms de fichiers, les erreurs etc... C'est une structure <del>propre à</del> bash (ksh, ?) qui est le shell par défaut dans la plupart des distributions Linux, et de Ubuntu en particulier. On garde en général des simples crochets pour les scripts shell qui doivent être à tout prix POSIX ( utilisation sur des Unix sans installation préalable de bash, comme BSD, Solaris... ) .
321 Une de ces ponctuations est superflue. => Cela gère bien mieux les problèmes d'espaces dans les noms de fichiers, les erreurs etc... C'est une structure <del>propre à</del> bash (ksh, ?) qui est le shell par défaut dans la plupart des distributions Linux, et de Ubuntu en particulier. On garde en général des simples crochets pour les scripts shell qui doivent être à tout prix POSIX ( utilisation sur des Unix sans installation préalable de bash, comme BSD, Solaris... ) .
321 Il manque un espace insécable. => Cela gère bien mieux les problèmes d'espaces dans les noms de fichiers, les erreurs etc... C'est une structure <del>propre à</del> bash (ksh, ?) qui est le shell par défaut dans la plupart des distributions Linux, et de Ubuntu en particulier. On garde en général des simples crochets pour les scripts shell qui doivent être à tout prix POSIX ( utilisation sur des Unix sans installation préalable de bash, comme BSD, Solaris... ) .
321 Mot inconnu : POSIX => Cela gère bien mieux les problèmes d'espaces dans les noms de fichiers, les erreurs etc... C'est une structure <del>propre à</del> bash (ksh, ?) qui est le shell par défaut dans la plupart des distributions Linux, et de Ubuntu en particulier. On garde en général des simples crochets pour les scripts shell qui doivent être à tout prix POSIX ( utilisation sur des Unix sans installation préalable de bash, comme BSD, Solaris... ) .
321 Pas d’espace après ce signe. => Cela gère bien mieux les problèmes d'espaces dans les noms de fichiers, les erreurs etc... C'est une structure <del>propre à</del> bash (ksh, ?) qui est le shell par défaut dans la plupart des distributions Linux, et de Ubuntu en particulier. On garde en général des simples crochets pour les scripts shell qui doivent être à tout prix POSIX ( utilisation sur des Unix sans installation préalable de bash, comme BSD, Solaris... ) .
321 Mot inconnu : bash => Cela gère bien mieux les problèmes d'espaces dans les noms de fichiers, les erreurs etc... C'est une structure <del>propre à</del> bash (ksh, ?) qui est le shell par défaut dans la plupart des distributions Linux, et de Ubuntu en particulier. On garde en général des simples crochets pour les scripts shell qui doivent être à tout prix POSIX ( utilisation sur des Unix sans installation préalable de bash, comme BSD, Solaris... ) .
321 Mot inconnu : Solaris => Cela gère bien mieux les problèmes d'espaces dans les noms de fichiers, les erreurs etc... C'est une structure <del>propre à</del> bash (ksh, ?) qui est le shell par défaut dans la plupart des distributions Linux, et de Ubuntu en particulier. On garde en général des simples crochets pour les scripts shell qui doivent être à tout prix POSIX ( utilisation sur des Unix sans installation préalable de bash, comme BSD, Solaris... ) .
321 Typographie : points de suspension. Utilisez le caractère dédié. => Cela gère bien mieux les problèmes d'espaces dans les noms de fichiers, les erreurs etc... C'est une structure <del>propre à</del> bash (ksh, ?) qui est le shell par défaut dans la plupart des distributions Linux, et de Ubuntu en particulier. On garde en général des simples crochets pour les scripts shell qui doivent être à tout prix POSIX ( utilisation sur des Unix sans installation préalable de bash, comme BSD, Solaris... ) .
321 Pas d’espace avant ce signe. => Cela gère bien mieux les problèmes d'espaces dans les noms de fichiers, les erreurs etc... C'est une structure <del>propre à</del> bash (ksh, ?) qui est le shell par défaut dans la plupart des distributions Linux, et de Ubuntu en particulier. On garde en général des simples crochets pour les scripts shell qui doivent être à tout prix POSIX ( utilisation sur des Unix sans installation préalable de bash, comme BSD, Solaris... ) .

325 Il manque un espace insécable. => Il y a en 3 :

326 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * le **et** logique : -a
326 Il manque un espace insécable. =>   * le **et** logique : -a

327 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * le **ou** logique : -o
327 Il manque un espace insécable. =>   * le **ou** logique : -o

328 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * le **non** logique : !
328 Il manque un espace insécable. =>   * le **non** logique : !
328 Il manque un espace insécable. =>   * le **non** logique : !

329 Il manque un espace insécable. => Exemple :

331 Mot inconnu : echo => echo "renverra 0 si les deux expressions sont vraies"
331 Guillemets typographiques ouvrants. => echo "renverra 0 si les deux expressions sont vraies"
331 Guillemets typographiques fermants. => echo "renverra 0 si les deux expressions sont vraies"

332 Mot inconnu : expr1 => test expr1 -a expr2  
332 Il manque un espace à côté du tiret. => test expr1 -a expr2  
332 Mot inconnu : expr2 => test expr1 -a expr2  
332 Espace(s) en fin de ligne à supprimer. => test expr1 -a expr2  

333 Pas d’espace après ce signe. => [ expr1 -a expr2 ]
333 Mot inconnu : expr1 => [ expr1 -a expr2 ]
333 Il manque un espace à côté du tiret. => [ expr1 -a expr2 ]
333 Mot inconnu : expr2 => [ expr1 -a expr2 ]
333 Pas d’espace avant ce signe. => [ expr1 -a expr2 ]

336 Il manque un espace insécable. => == Table de vérité de « -a » ==
336 Il manque un espace insécable. => == Table de vérité de « -a » ==

346 Il manque un espace insécable. => == Table de vérité de « -o » ==
346 Il manque un espace insécable. => == Table de vérité de « -o » ==

356 Il manque un espace insécable. => Exemple plus complet :

358 Il manque un espace insécable. => #!/bin/sh

360 Mot inconnu : echo => echo -n "Entrez un nom de fichier: "
360 Il manque un espace à côté du tiret. => echo -n "Entrez un nom de fichier: "
360 Guillemets typographiques ouvrants. => echo -n "Entrez un nom de fichier: "
360 Il manque un espace insécable. => echo -n "Entrez un nom de fichier: "
360 Guillemets fermants. => echo -n "Entrez un nom de fichier: "

361 Mot inconnu : read => read file

362 Pas d’espace après ce signe. => if [ -e "$file" ]; then
362 Guillemets typographiques fermants. => if [ -e "$file" ]; then
362 Pas d’espace avant ce signe. => if [ -e "$file" ]; then
362 Mot inconnu : then => if [ -e "$file" ]; then

363 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>         echo "Le fichier existe!"
363 Mot inconnu : echo =>         echo "Le fichier existe!"
363 Guillemets typographiques ouvrants. =>         echo "Le fichier existe!"
363 Il manque un espace insécable. =>         echo "Le fichier existe!"
363 Guillemets typographiques fermants. =>         echo "Le fichier existe!"

364 Mot inconnu : else => else

365 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>         echo "Le fichier n'existe pas, du moins n'est pas dans le répertoire d'exécution du script"
365 Mot inconnu : echo =>         echo "Le fichier n'existe pas, du moins n'est pas dans le répertoire d'exécution du script"
365 Guillemets typographiques ouvrants. =>         echo "Le fichier n'existe pas, du moins n'est pas dans le répertoire d'exécution du script"
365 Guillemets typographiques fermants. =>         echo "Le fichier n'existe pas, du moins n'est pas dans le répertoire d'exécution du script"

369 Il manque un espace insécable. => La seule chose qui prête à confusion est que l'on vérifie seulement si le fichier « file » est dans le répertoire où le script a été exécuté.
369 Il manque un espace insécable. => La seule chose qui prête à confusion est que l'on vérifie seulement si le fichier « file » est dans le répertoire où le script a été exécuté.

371 Il manque un espace insécable. => ==== La structure : `if` ====

374 Guillemets typographiques ouvrants. => de voir comment se servir des variables, et des instructions ''if'', ''then'', ''elif'', ''else'', ''fi''. Cela permet par exemple de faire réagir le script de manière différente, selon la réponse de l'utilisateur à une question.
374 Guillemets typographiques fermants. => de voir comment se servir des variables, et des instructions ''if'', ''then'', ''elif'', ''else'', ''fi''. Cela permet par exemple de faire réagir le script de manière différente, selon la réponse de l'utilisateur à une question.
374 Guillemets typographiques ouvrants. => de voir comment se servir des variables, et des instructions ''if'', ''then'', ''elif'', ''else'', ''fi''. Cela permet par exemple de faire réagir le script de manière différente, selon la réponse de l'utilisateur à une question.
374 Mot inconnu : then => de voir comment se servir des variables, et des instructions ''if'', ''then'', ''elif'', ''else'', ''fi''. Cela permet par exemple de faire réagir le script de manière différente, selon la réponse de l'utilisateur à une question.
374 Guillemets typographiques fermants. => de voir comment se servir des variables, et des instructions ''if'', ''then'', ''elif'', ''else'', ''fi''. Cela permet par exemple de faire réagir le script de manière différente, selon la réponse de l'utilisateur à une question.
374 Guillemets typographiques ouvrants. => de voir comment se servir des variables, et des instructions ''if'', ''then'', ''elif'', ''else'', ''fi''. Cela permet par exemple de faire réagir le script de manière différente, selon la réponse de l'utilisateur à une question.
374 Mot inconnu : elif => de voir comment se servir des variables, et des instructions ''if'', ''then'', ''elif'', ''else'', ''fi''. Cela permet par exemple de faire réagir le script de manière différente, selon la réponse de l'utilisateur à une question.
374 Guillemets typographiques fermants. => de voir comment se servir des variables, et des instructions ''if'', ''then'', ''elif'', ''else'', ''fi''. Cela permet par exemple de faire réagir le script de manière différente, selon la réponse de l'utilisateur à une question.
374 Guillemets typographiques ouvrants. => de voir comment se servir des variables, et des instructions ''if'', ''then'', ''elif'', ''else'', ''fi''. Cela permet par exemple de faire réagir le script de manière différente, selon la réponse de l'utilisateur à une question.
374 Mot inconnu : else => de voir comment se servir des variables, et des instructions ''if'', ''then'', ''elif'', ''else'', ''fi''. Cela permet par exemple de faire réagir le script de manière différente, selon la réponse de l'utilisateur à une question.
374 Guillemets typographiques fermants. => de voir comment se servir des variables, et des instructions ''if'', ''then'', ''elif'', ''else'', ''fi''. Cela permet par exemple de faire réagir le script de manière différente, selon la réponse de l'utilisateur à une question.
374 Guillemets typographiques ouvrants. => de voir comment se servir des variables, et des instructions ''if'', ''then'', ''elif'', ''else'', ''fi''. Cela permet par exemple de faire réagir le script de manière différente, selon la réponse de l'utilisateur à une question.
374 Guillemets typographiques fermants. => de voir comment se servir des variables, et des instructions ''if'', ''then'', ''elif'', ''else'', ''fi''. Cela permet par exemple de faire réagir le script de manière différente, selon la réponse de l'utilisateur à une question.

376 Mot inconnu : bash => En bash, les variables ne se déclarent généralement pas avant leur utilisation, on les utilise directement et elles sont créées lors de sa première mise en œuvre.

378 Il manque un espace insécable. => Pour pouvoir voir la valeur d'une variable il faut faire précéder son nom du caractère « $ ».
378 Il manque un espace insécable. => Pour pouvoir voir la valeur d'une variable il faut faire précéder son nom du caractère « $ ».

381 Il manque un espace insécable. => #!/bin/sh

382 Mot inconnu : echo => echo -n "Voulez-vous voir la liste des fichiers Y/N : "
382 Il manque un espace à côté du tiret. => echo -n "Voulez-vous voir la liste des fichiers Y/N : "
382 Guillemets typographiques ouvrants. => echo -n "Voulez-vous voir la liste des fichiers Y/N : "
382 Il manque un espace insécable. => echo -n "Voulez-vous voir la liste des fichiers Y/N : "
382 Guillemets fermants. => echo -n "Voulez-vous voir la liste des fichiers Y/N : "

383 Mot inconnu : read => read ouinon
383 Mot inconnu : ouinon => read ouinon

384 Pas d’espace après ce signe. => if [ "$ouinon" = "y" ] || [ "$ouinon" = "Y" ]; then
384 Mot inconnu : ouinon => if [ "$ouinon" = "y" ] || [ "$ouinon" = "Y" ]; then
384 Guillemets typographiques fermants. => if [ "$ouinon" = "y" ] || [ "$ouinon" = "Y" ]; then
384 Guillemets typographiques ouvrants. => if [ "$ouinon" = "y" ] || [ "$ouinon" = "Y" ]; then
384 Guillemets typographiques fermants. => if [ "$ouinon" = "y" ] || [ "$ouinon" = "Y" ]; then
384 Pas d’espace avant ce signe. => if [ "$ouinon" = "y" ] || [ "$ouinon" = "Y" ]; then
384 Pas d’espace après ce signe. => if [ "$ouinon" = "y" ] || [ "$ouinon" = "Y" ]; then
384 Mot inconnu : ouinon => if [ "$ouinon" = "y" ] || [ "$ouinon" = "Y" ]; then
384 Guillemets typographiques fermants. => if [ "$ouinon" = "y" ] || [ "$ouinon" = "Y" ]; then
384 Guillemets typographiques ouvrants. => if [ "$ouinon" = "y" ] || [ "$ouinon" = "Y" ]; then
384 Guillemets typographiques fermants. => if [ "$ouinon" = "y" ] || [ "$ouinon" = "Y" ]; then
384 Pas d’espace avant ce signe. => if [ "$ouinon" = "y" ] || [ "$ouinon" = "Y" ]; then
384 Mot inconnu : then => if [ "$ouinon" = "y" ] || [ "$ouinon" = "Y" ]; then

385 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     echo "Liste des fichiers :"
385 Mot inconnu : echo =>     echo "Liste des fichiers :"
385 Guillemets typographiques ouvrants. =>     echo "Liste des fichiers :"

386 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     ls -la
386 Mot inconnu : ls =>     ls -la
386 Il manque un espace à côté du tiret. =>     ls -la

387 Mot inconnu : elif => elif [ "$ouinon" = "n" ] || [ "$ouinon" = "N" ]; then
387 Pas d’espace après ce signe. => elif [ "$ouinon" = "n" ] || [ "$ouinon" = "N" ]; then
387 Mot inconnu : ouinon => elif [ "$ouinon" = "n" ] || [ "$ouinon" = "N" ]; then
387 Guillemets typographiques fermants. => elif [ "$ouinon" = "n" ] || [ "$ouinon" = "N" ]; then
387 Guillemets typographiques ouvrants. => elif [ "$ouinon" = "n" ] || [ "$ouinon" = "N" ]; then
387 Guillemets typographiques fermants. => elif [ "$ouinon" = "n" ] || [ "$ouinon" = "N" ]; then
387 Pas d’espace avant ce signe. => elif [ "$ouinon" = "n" ] || [ "$ouinon" = "N" ]; then
387 Pas d’espace après ce signe. => elif [ "$ouinon" = "n" ] || [ "$ouinon" = "N" ]; then
387 Mot inconnu : ouinon => elif [ "$ouinon" = "n" ] || [ "$ouinon" = "N" ]; then
387 Guillemets typographiques fermants. => elif [ "$ouinon" = "n" ] || [ "$ouinon" = "N" ]; then
387 Guillemets typographiques ouvrants. => elif [ "$ouinon" = "n" ] || [ "$ouinon" = "N" ]; then
387 Guillemets typographiques fermants. => elif [ "$ouinon" = "n" ] || [ "$ouinon" = "N" ]; then
387 Pas d’espace avant ce signe. => elif [ "$ouinon" = "n" ] || [ "$ouinon" = "N" ]; then
387 Mot inconnu : then => elif [ "$ouinon" = "n" ] || [ "$ouinon" = "N" ]; then

388 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     echo "Ok, bye! "
388 Mot inconnu : echo =>     echo "Ok, bye! "
388 Guillemets typographiques ouvrants. =>     echo "Ok, bye! "
388 Mot inconnu : Ok =>     echo "Ok, bye! "
388 Il manque un espace insécable. =>     echo "Ok, bye! "
388 Guillemets fermants. =>     echo "Ok, bye! "

389 Mot inconnu : else => else

390 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     echo "Il faut taper Y ou N!! Pas $ouinon"
390 Mot inconnu : echo =>     echo "Il faut taper Y ou N!! Pas $ouinon"
390 Guillemets typographiques ouvrants. =>     echo "Il faut taper Y ou N!! Pas $ouinon"
390 Il manque un espace insécable. =>     echo "Il faut taper Y ou N!! Pas $ouinon"
390 Mot inconnu : ouinon =>     echo "Il faut taper Y ou N!! Pas $ouinon"
390 Guillemets typographiques fermants. =>     echo "Il faut taper Y ou N!! Pas $ouinon"

399 Mot inconnu : echo => Tout abord, le ''`echo -n`'' permet de laisser le curseur sur la même ligne, ce
399 Il manque un espace à côté du tiret. => Tout abord, le ''`echo -n`'' permet de laisser le curseur sur la même ligne, ce

403 Mot inconnu : read => L'instruction ''`read`'' permet d'affecter une valeur ou un caractère à une variable quelconque, en la demandant à l'utilisateur.

405 Mot inconnu : bash => <note>En bash, la variable est considérée comme une chaîne même si celle-ci contient une valeur numérique, et les majuscules sont considérées différentes des minuscules, $M ≠ $m.</note>

407 Il manque un espace insécable. => Ensuite vient l'instruction conditionnelle `if`. Elle est suivie d'un « [ »
407 Pas d’espace après ce signe. => Ensuite vient l'instruction conditionnelle `if`. Elle est suivie d'un « [ »
407 Il manque un espace insécable. => Ensuite vient l'instruction conditionnelle `if`. Elle est suivie d'un « [ »

408 Majuscule en début de phrase, sauf éventuellement lors d’une énumération. => pour délimiter la condition. La condition doit bien être séparée des crochets par un espace ! Attention, la variable est mise entre guillemets
408 Il manque un espace insécable. => pour délimiter la condition. La condition doit bien être séparée des crochets par un espace ! Attention, la variable est mise entre guillemets

409 Il manque un espace insécable. => car dans le cas où la variable est vide, le shell ne retourne pas d'erreur, mais en cas contraire, l'erreur produite ressemble à :

411 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   [: =: unaryoperator expected
411 Mot inconnu : unaryoperator =>   [: =: unaryoperator expected
411 Mot inconnu : expected =>   [: =: unaryoperator expected

413 Guillemets fermants. => L'opérateur ''`||`'' signifie exécuter la commande suivante si la commande précédente n'a pas renvoyé 0. Il existe aussi l'opérateur ''&&'' qui exécute la commande suivante si la commande précédente a renvoyé 0, et enfin '';'' qui exécute l'opération suivante dans tous les cas.

415 Il manque un espace insécable. => Exemple :

416 Apostrophe incorrecte. => créer le répertoire toto s'il n' existe pas
416 Guillemets typographiques fermants. => créer le répertoire toto s'il n' existe pas

418 Pas d’espace après ce signe. => [ ! -d /tmp/toto ] && mkdir /tmp/toto
418 Il manque un espace insécable. => [ ! -d /tmp/toto ] && mkdir /tmp/toto
418 Pas d’espace avant ce signe. => [ ! -d /tmp/toto ] && mkdir /tmp/toto
418 Mot inconnu : mkdir => [ ! -d /tmp/toto ] && mkdir /tmp/toto

419 Pas d’espace après ce signe. => [ -d /tmp/toto ] || mkdir /tmp/toto
419 Pas d’espace avant ce signe. => [ -d /tmp/toto ] || mkdir /tmp/toto
419 Mot inconnu : mkdir => [ -d /tmp/toto ] || mkdir /tmp/toto

420 Il manque un espace insécable. => test ! -d /tmp/toto && mkdir  /tmp/toto
420 Mot inconnu : mkdir => test ! -d /tmp/toto && mkdir  /tmp/toto
420 Espace(s) surnuméraire(s) à supprimer. => test ! -d /tmp/toto && mkdir  /tmp/toto

421 Mot inconnu : rm => rm -rf /tmp/toto;mkdir /tmp/toto
421 Il manque un espace à côté du tiret. => rm -rf /tmp/toto;mkdir /tmp/toto
421 Mot inconnu : rf => rm -rf /tmp/toto;mkdir /tmp/toto
421 Il manque un espace insécable. => rm -rf /tmp/toto;mkdir /tmp/toto
421 Il manque un espace. => rm -rf /tmp/toto;mkdir /tmp/toto
421 Mot inconnu : mkdir => rm -rf /tmp/toto;mkdir /tmp/toto

424 Il manque un espace insécable. => Les « { » servent à bien délimiter le bloc d'instructions suivant le ''`then`'', est une commande et donc si elle est sur la même ligne que le ''`if`'' les deux commandes doivent être séparées par un ''`;`''
424 Il manque un espace insécable. => Les « { » servent à bien délimiter le bloc d'instructions suivant le ''`then`'', est une commande et donc si elle est sur la même ligne que le ''`if`'' les deux commandes doivent être séparées par un ''`;`''
424 Mot inconnu : then => Les « { » servent à bien délimiter le bloc d'instructions suivant le ''`then`'', est une commande et donc si elle est sur la même ligne que le ''`if`'' les deux commandes doivent être séparées par un ''`;`''

426 Mot inconnu : elif => Ensuite, ''`elif`'' sert à exécuter une autre série d'instructions, si la condition décrite par ''`if`'' n'est pas respectée, et si celle fournie après ce ''`elif`'' l'est.
426 Mot inconnu : elif => Ensuite, ''`elif`'' sert à exécuter une autre série d'instructions, si la condition décrite par ''`if`'' n'est pas respectée, et si celle fournie après ce ''`elif`'' l'est.

428 Mot inconnu : else => Enfin, ''`else`'' sert à exécuter un bloc si les conditions précédentes ne sont pas respectées (ah les jeunes, ils respectent plus rien de nos jours :-)).

432 Il manque un espace insécable. => Quelques petites commandes pratiques :

434 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   sh -n nom_du_fichier
434 Mot inconnu : sh =>   sh -n nom_du_fichier
434 Il manque un espace à côté du tiret. =>   sh -n nom_du_fichier
434 Mot inconnu : nom_du_fichier =>   sh -n nom_du_fichier

436 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   bash -x chemin_du_fichier
436 Mot inconnu : bash =>   bash -x chemin_du_fichier
436 Il manque un espace à côté du tiret. =>   bash -x chemin_du_fichier
436 Mot inconnu : chemin_du_fichier =>   bash -x chemin_du_fichier

440 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   sh -u nom_du_fichier
440 Mot inconnu : sh =>   sh -u nom_du_fichier
440 Il manque un espace à côté du tiret. =>   sh -u nom_du_fichier
440 Mot inconnu : nom_du_fichier =>   sh -u nom_du_fichier

448 Il manque un espace insécable. => $A != $B # Vérifie si les deux chaînes sont différentes.

450 Dialogues et énumérations : il faut tiret cadratin [1] ou demi-cadratin [2] suivi d’un espace insécable. => -z $A # Vérifie si A n'existe pas (ne contient pas de chaîne).

452 Dialogues et énumérations : il faut tiret cadratin [1] ou demi-cadratin [2] suivi d’un espace insécable. => -n $A # Vérifie si A existe (contient une chaîne).

455 Mot inconnu : while => ==== Les structures while et until ====
455 Mot inconnu : until => ==== Les structures while et until ====

457 Guillemets typographiques ouvrants. => La commande ''while'' exécute ce qu'il y a dans son bloc__ tant que__ la condition
457 Mot inconnu : while => La commande ''while'' exécute ce qu'il y a dans son bloc__ tant que__ la condition
457 Guillemets typographiques fermants. => La commande ''while'' exécute ce qu'il y a dans son bloc__ tant que__ la condition
457 Mot inconnu : bloc__ => La commande ''while'' exécute ce qu'il y a dans son bloc__ tant que__ la condition
457 Mot inconnu : que__ => La commande ''while'' exécute ce qu'il y a dans son bloc__ tant que__ la condition

458 Il manque un espace insécable. => est respectée :

461 Il manque un espace insécable. => #!/bin/sh

462 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   

463 Mot inconnu : cmpt => cmpt=1

465 Mot inconnu : echo => echo -n "Mot de passe : "
465 Il manque un espace à côté du tiret. => echo -n "Mot de passe : "
465 Guillemets typographiques ouvrants. => echo -n "Mot de passe : "
465 Il manque un espace insécable. => echo -n "Mot de passe : "
465 Guillemets fermants. => echo -n "Mot de passe : "

466 Mot inconnu : read => read mdp
466 Mot inconnu : mdp => read mdp

467 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>  

468 Mot inconnu : while => while [ "$mdp" != "ubuntu" ] && [ "$cmpt" != 4 ]
468 Pas d’espace après ce signe. => while [ "$mdp" != "ubuntu" ] && [ "$cmpt" != 4 ]
468 Mot inconnu : mdp => while [ "$mdp" != "ubuntu" ] && [ "$cmpt" != 4 ]
468 Guillemets typographiques fermants. => while [ "$mdp" != "ubuntu" ] && [ "$cmpt" != 4 ]
468 Il manque un espace insécable. => while [ "$mdp" != "ubuntu" ] && [ "$cmpt" != 4 ]
468 Guillemets typographiques ouvrants. => while [ "$mdp" != "ubuntu" ] && [ "$cmpt" != 4 ]
468 Mot inconnu : ubuntu => while [ "$mdp" != "ubuntu" ] && [ "$cmpt" != 4 ]
468 Guillemets typographiques fermants. => while [ "$mdp" != "ubuntu" ] && [ "$cmpt" != 4 ]
468 Pas d’espace avant ce signe. => while [ "$mdp" != "ubuntu" ] && [ "$cmpt" != 4 ]
468 Pas d’espace après ce signe. => while [ "$mdp" != "ubuntu" ] && [ "$cmpt" != 4 ]
468 Mot inconnu : cmpt => while [ "$mdp" != "ubuntu" ] && [ "$cmpt" != 4 ]
468 Guillemets typographiques fermants. => while [ "$mdp" != "ubuntu" ] && [ "$cmpt" != 4 ]
468 Il manque un espace insécable. => while [ "$mdp" != "ubuntu" ] && [ "$cmpt" != 4 ]
468 Pas d’espace avant ce signe. => while [ "$mdp" != "ubuntu" ] && [ "$cmpt" != 4 ]

470 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>      echo -n "Mauvais mot de passe, plus que "$cm" chance(s): "
470 Mot inconnu : echo =>      echo -n "Mauvais mot de passe, plus que "$cm" chance(s): "
470 Il manque un espace à côté du tiret. =>      echo -n "Mauvais mot de passe, plus que "$cm" chance(s): "
470 Guillemets typographiques ouvrants. =>      echo -n "Mauvais mot de passe, plus que "$cm" chance(s): "
470 Guillemets typographiques fermants. =>      echo -n "Mauvais mot de passe, plus que "$cm" chance(s): "
470 Écriture invariable. Utilisez un point médian. =>      echo -n "Mauvais mot de passe, plus que "$cm" chance(s): "
470 Il manque un espace insécable. =>      echo -n "Mauvais mot de passe, plus que "$cm" chance(s): "
470 Guillemets fermants. =>      echo -n "Mauvais mot de passe, plus que "$cm" chance(s): "

471 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>      read mdp
471 Mot inconnu : read =>      read mdp
471 Mot inconnu : mdp =>      read mdp

472 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>      cmpt=$(($cmpt+1))
472 Mot inconnu : cmpt =>      cmpt=$(($cmpt+1))
472 Mot inconnu : cmpt =>      cmpt=$(($cmpt+1))

473 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>      cm=$(($cm-1))

474 Mot inconnu : done => done

475 Mot inconnu : echo => echo "Non mais, le brute-force est interdit en France !!"
475 Guillemets typographiques ouvrants. => echo "Non mais, le brute-force est interdit en France !!"
475 Il manque un espace insécable. => echo "Non mais, le brute-force est interdit en France !!"
475 Guillemets typographiques fermants. => echo "Non mais, le brute-force est interdit en France !!"

479 Guillemets typographiques ouvrants. => Le `&&` sert à symboliser un "et", cela implique que deux conditions sont
479 Guillemets typographiques fermants. => Le `&&` sert à symboliser un "et", cela implique que deux conditions sont

481 Mot inconnu : done => Si elle ne l'est pas, cela saute tout le bloc (jusqu'à `done`).

482 Il manque un espace insécable. => Vous allez dire :

483 Il manque un espace insécable. => <note help>Mais qu'est-ce que c'est ce truc avec cette syntaxe bizarre au milieu ?</note>

485 Majuscule en début de phrase, sauf éventuellement lors d’une énumération. => une opération arithmétique. A chaque passage,
485 S’il s’agit de la préposition « à », il faut accentuer la majuscule. => une opération arithmétique. A chaque passage,

486 Guillemets typographiques ouvrants. => 'cmpt = cmpt+1' et 'cm = cm-1'.
486 Mot inconnu : cmpt => 'cmpt = cmpt+1' et 'cm = cm-1'.
486 Mot inconnu : cmpt => 'cmpt = cmpt+1' et 'cm = cm-1'.
486 Guillemets typographiques fermants. => 'cmpt = cmpt+1' et 'cm = cm-1'.
486 Guillemets typographiques ouvrants. => 'cmpt = cmpt+1' et 'cm = cm-1'.

488 Mot inconnu : while => `while` permet de faire exécuter la portion de code un nombre indéterminé de fois.

489 Mot inconnu : until => La commande `until` fait la même chose que la commande `while` mais en inversant.
489 Mot inconnu : while => La commande `until` fait la même chose que la commande `while` mais en inversant.

491 Mot inconnu : while => s'emploie exactement comme la commande `while`.

493 Mot inconnu : window => Par exemple, si on a besoin d'attendre le démarrage de notre window manager pour exécuter des commandes dans notre Xsession il sera plus intéressant d'utiliser le `until`:
493 Mot inconnu : Xsession => Par exemple, si on a besoin d'attendre le démarrage de notre window manager pour exécuter des commandes dans notre Xsession il sera plus intéressant d'utiliser le `until`:
493 Mot inconnu : until => Par exemple, si on a besoin d'attendre le démarrage de notre window manager pour exécuter des commandes dans notre Xsession il sera plus intéressant d'utiliser le `until`:

495 Il manque un espace insécable. => #!/bin/sh

496 Mot inconnu : until => until pidof wmaker 
496 Mot inconnu : pidof => until pidof wmaker 
496 Mot inconnu : wmaker => until pidof wmaker 
496 Espace(s) en fin de ligne à supprimer. => until pidof wmaker 

498 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   sleep 1
498 Mot inconnu : sleep =>   sleep 1

499 Mot inconnu : done => done

500 Mot inconnu : xmessage => xmessage "Session loaded" -buttons "Continue":0,"That all":1;
500 Guillemets typographiques ouvrants. => xmessage "Session loaded" -buttons "Continue":0,"That all":1;
500 Mot inconnu : loaded => xmessage "Session loaded" -buttons "Continue":0,"That all":1;
500 Guillemets typographiques fermants. => xmessage "Session loaded" -buttons "Continue":0,"That all":1;
500 Guillemets typographiques ouvrants. => xmessage "Session loaded" -buttons "Continue":0,"That all":1;
500 Guillemets typographiques fermants. => xmessage "Session loaded" -buttons "Continue":0,"That all":1;
500 Guillemets typographiques ouvrants. => xmessage "Session loaded" -buttons "Continue":0,"That all":1;
500 Mot inconnu : That => xmessage "Session loaded" -buttons "Continue":0,"That all":1;
500 Mot inconnu : all => xmessage "Session loaded" -buttons "Continue":0,"That all":1;
500 Guillemets typographiques fermants. => xmessage "Session loaded" -buttons "Continue":0,"That all":1;
500 Il manque un espace insécable. => xmessage "Session loaded" -buttons "Continue":0,"That all":1;

501 Pas d’espace après ce signe. => [ $? -eq 0 ] && xmessage "Load more..."
501 Mot inconnu : eq => [ $? -eq 0 ] && xmessage "Load more..."
501 Pas d’espace avant ce signe. => [ $? -eq 0 ] && xmessage "Load more..."
501 Mot inconnu : xmessage => [ $? -eq 0 ] && xmessage "Load more..."
501 Guillemets typographiques ouvrants. => [ $? -eq 0 ] && xmessage "Load more..."
501 Mot inconnu : Load => [ $? -eq 0 ] && xmessage "Load more..."
501 Typographie : points de suspension. Utilisez le caractère dédié. => [ $? -eq 0 ] && xmessage "Load more..."
501 Guillemets typographiques fermants. => [ $? -eq 0 ] && xmessage "Load more..."

503 Il manque un espace insécable. => Mais on aurait pu aussi faire:

505 Il manque un espace insécable. => #!/bin/sh

506 Mot inconnu : while => while [ -z $(pidof wmaker) ]
506 Pas d’espace après ce signe. => while [ -z $(pidof wmaker) ]
506 Mot inconnu : pidof => while [ -z $(pidof wmaker) ]
506 Mot inconnu : wmaker => while [ -z $(pidof wmaker) ]
506 Pas d’espace avant ce signe. => while [ -z $(pidof wmaker) ]

508 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>  sleep 1
508 Mot inconnu : sleep =>  sleep 1

509 Mot inconnu : done => done 
509 Espace(s) en fin de ligne à supprimer. => done 

510 Typographie : points de suspension. Utilisez le caractère dédié. => #(...)

515 Il manque un espace insécable. => Regardons la syntaxe de cette commande, qui n'est pas une des plus simples :

518 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     modèle [ | modèle] ...) instructions;;
518 Pas d’espace après ce signe. =>     modèle [ | modèle] ...) instructions;;
518 Typographie : points de suspension. Utilisez le caractère dédié. =>     modèle [ | modèle] ...) instructions;;
518 Une de ces ponctuations est superflue. =>     modèle [ | modèle] ...) instructions;;

519 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     modèle [ | modèle] ...) instructions;;
519 Pas d’espace après ce signe. =>     modèle [ | modèle] ...) instructions;;
519 Typographie : points de suspension. Utilisez le caractère dédié. =>     modèle [ | modèle] ...) instructions;;
519 Une de ces ponctuations est superflue. =>     modèle [ | modèle] ...) instructions;;

520 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>       ...
520 Typographie : points de suspension. Utilisez le caractère dédié. =>       ...

521 Mot inconnu : esac => esac

524 Si « mais » est la conjonction de coordination, une virgule est souhaitable si elle introduit une nouvelle proposition. => Cela peut paraître complexe mais on s'y habitue quand on l'utilise.

525 Il manque un espace insécable. => >Mais à quoi sert cette commande ?

526 Il manque un espace insécable. => Elle sert à comparer le contenu d'une variable à des modèles différents. Les ;; sont indipensables car il est possible de placer plusieurs instructions entre un modèle et le
526 Une de ces ponctuations est superflue. => Elle sert à comparer le contenu d'une variable à des modèles différents. Les ;; sont indipensables car il est possible de placer plusieurs instructions entre un modèle et le
526 Mot inconnu : indipensables => Elle sert à comparer le contenu d'une variable à des modèles différents. Les ;; sont indipensables car il est possible de placer plusieurs instructions entre un modèle et le
526 Si « car » est la conjonction de coordination, une virgule est peut-être souhaitable. => Elle sert à comparer le contenu d'une variable à des modèles différents. Les ;; sont indipensables car il est possible de placer plusieurs instructions entre un modèle et le

527 Il manque un espace insécable. => suivant. Les ;; servent donc à identifier clairement la fin d'une instruction et
527 Une de ces ponctuations est superflue. => suivant. Les ;; servent donc à identifier clairement la fin d'une instruction et

530 Il manque un espace insécable. => Exemple :

532 Il manque un espace insécable. => #!/bin/sh

533 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   

534 Mot inconnu : echo => echo -n "Êtes-vous fatigué ? "
534 Il manque un espace à côté du tiret. => echo -n "Êtes-vous fatigué ? "
534 Guillemets typographiques ouvrants. => echo -n "Êtes-vous fatigué ? "
534 Il manque un espace insécable. => echo -n "Êtes-vous fatigué ? "
534 Guillemets fermants. => echo -n "Êtes-vous fatigué ? "

535 Mot inconnu : read => read on

536 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   

537 Guillemets typographiques fermants. => case "$on" in
537 Incohérence avec “on” : “in” devrait être un verbe, un pronom objet, un adverbe de négation, etc. => case "$on" in

538 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     oui | o | O | Oui | OUI ) echo "Allez faire du café !";;
538 Pas d’espace avant ce signe. =>     oui | o | O | Oui | OUI ) echo "Allez faire du café !";;
538 Mot inconnu : echo =>     oui | o | O | Oui | OUI ) echo "Allez faire du café !";;
538 Guillemets typographiques ouvrants. =>     oui | o | O | Oui | OUI ) echo "Allez faire du café !";;
538 Il manque un espace insécable. =>     oui | o | O | Oui | OUI ) echo "Allez faire du café !";;
538 Guillemets typographiques fermants. =>     oui | o | O | Oui | OUI ) echo "Allez faire du café !";;
538 Une de ces ponctuations est superflue. =>     oui | o | O | Oui | OUI ) echo "Allez faire du café !";;

539 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     non | n | N | Non | NON ) echo "Programmez !";;
539 Pas d’espace avant ce signe. =>     non | n | N | Non | NON ) echo "Programmez !";;
539 Mot inconnu : echo =>     non | n | N | Non | NON ) echo "Programmez !";;
539 Guillemets typographiques ouvrants. =>     non | n | N | Non | NON ) echo "Programmez !";;
539 Il manque un espace insécable. =>     non | n | N | Non | NON ) echo "Programmez !";;
539 Guillemets typographiques fermants. =>     non | n | N | Non | NON ) echo "Programmez !";;
539 Une de ces ponctuations est superflue. =>     non | n | N | Non | NON ) echo "Programmez !";;

540 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     * ) echo "Ah bon ?";;
540 Pas d’espace avant ce signe. =>     * ) echo "Ah bon ?";;
540 Mot inconnu : echo =>     * ) echo "Ah bon ?";;
540 Guillemets typographiques ouvrants. =>     * ) echo "Ah bon ?";;
540 Il manque un espace insécable. =>     * ) echo "Ah bon ?";;
540 Guillemets typographiques fermants. =>     * ) echo "Ah bon ?";;
540 Une de ces ponctuations est superflue. =>     * ) echo "Ah bon ?";;

541 Mot inconnu : esac => esac

544 Pas d’espace avant ce signe. => La seule chose qui mérite vraiment d'être expliquée est sans doute `* )`.

547 Il manque un espace insécable. => Il existe aussi plusieurs structures pour les modèles, telles que :

549 Typographie : points de suspension. Utilisez le caractère dédié. => case "$truc....." in
549 Guillemets typographiques fermants. => case "$truc....." in

550 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     [nN] *) echo "Blablabla...";;
550 Mot inconnu : echo =>     [nN] *) echo "Blablabla...";;
550 Guillemets typographiques ouvrants. =>     [nN] *) echo "Blablabla...";;
550 Typographie : points de suspension. Utilisez le caractère dédié. =>     [nN] *) echo "Blablabla...";;
550 Guillemets typographiques fermants. =>     [nN] *) echo "Blablabla...";;
550 Une de ces ponctuations est superflue. =>     [nN] *) echo "Blablabla...";;

551 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     n* | N* ) echo "Bla....";;
551 Pas d’espace avant ce signe. =>     n* | N* ) echo "Bla....";;
551 Mot inconnu : echo =>     n* | N* ) echo "Bla....";;
551 Guillemets typographiques ouvrants. =>     n* | N* ) echo "Bla....";;
551 Mot inconnu : Bla =>     n* | N* ) echo "Bla....";;
551 Typographie : points de suspension. Utilisez le caractère dédié. =>     n* | N* ) echo "Bla....";;
551 Guillemets typographiques fermants. =>     n* | N* ) echo "Bla....";;
551 Une de ces ponctuations est superflue. =>     n* | N* ) echo "Bla....";;

554 Typographie : points de suspension. Utilisez le caractère dédié. => Et plein d'autres encore...

559 Il manque un espace insécable. => voici un petit script censé refaire un prompt avec quelques commandes basiques :

562 Il manque un espace insécable. => #!/bin/bash

563 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   

564 Mot inconnu : clear => clear

565 Mot inconnu : echo => echo 
565 Espace(s) en fin de ligne à supprimer. => echo 

566 Mot inconnu : echo => echo "#################### Script ############################"

567 Mot inconnu : echo => echo 
567 Espace(s) en fin de ligne à supprimer. => echo 

568 Mot inconnu : echo => echo "#############################"

569 Mot inconnu : echo => echo -n "LOGIN: "
569 Il manque un espace à côté du tiret. => echo -n "LOGIN: "
569 Guillemets typographiques ouvrants. => echo -n "LOGIN: "
569 Il manque un espace insécable. => echo -n "LOGIN: "
569 Guillemets fermants. => echo -n "LOGIN: "

570 Mot inconnu : read => read login

571 Mot inconnu : echo => echo -n "Hôte: "
571 Il manque un espace à côté du tiret. => echo -n "Hôte: "
571 Guillemets typographiques ouvrants. => echo -n "Hôte: "
571 Il manque un espace insécable. => echo -n "Hôte: "
571 Guillemets fermants. => echo -n "Hôte: "

572 Mot inconnu : read => read hote
572 Mot inconnu : hote => read hote

573 Mot inconnu : echo => echo "#############################"

574 Mot inconnu : echo => echo

575 Mot inconnu : echo => echo "### Pour l'aide tapez help ###"
575 Mot inconnu : help => echo "### Pour l'aide tapez help ###"

576 Mot inconnu : echo => echo 
576 Espace(s) en fin de ligne à supprimer. => echo 

577 Mot inconnu : while => while [ 1 ]; do                                 # permet une boucle infinie
577 Pas d’espace après ce signe. => while [ 1 ]; do                                 # permet une boucle infinie
577 Pas d’espace avant ce signe. => while [ 1 ]; do                                 # permet une boucle infinie
577 Espace(s) surnuméraire(s) à supprimer. => while [ 1 ]; do                                 # permet une boucle infinie

578 Mot inconnu : echo => echo -n ""$login"@"$hote"$ "                    # qui s'arrête avec break
578 Il manque un espace à côté du tiret. => echo -n ""$login"@"$hote"$ "                    # qui s'arrête avec break
578 Guillemets typographiques fermants. => echo -n ""$login"@"$hote"$ "                    # qui s'arrête avec break
578 Mot inconnu : hote => echo -n ""$login"@"$hote"$ "                    # qui s'arrête avec break
578 Guillemets typographiques fermants. => echo -n ""$login"@"$hote"$ "                    # qui s'arrête avec break
578 Guillemets isolés. => echo -n ""$login"@"$hote"$ "                    # qui s'arrête avec break

579 Mot inconnu : read => read reps

582 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   help | hlp )
582 Mot inconnu : help =>   help | hlp )
582 Mot inconnu : hlp =>   help | hlp )
582 Pas d’espace avant ce signe. =>   help | hlp )

583 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>      echo "À propos de TS --> about"
583 Mot inconnu : echo =>      echo "À propos de TS --> about"
583 Guillemets typographiques ouvrants. =>      echo "À propos de TS --> about"
583 Guillemets typographiques fermants. =>      echo "À propos de TS --> about"

584 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>      echo "ls --> liste les fichiers"
584 Mot inconnu : echo =>      echo "ls --> liste les fichiers"
584 Guillemets typographiques ouvrants. =>      echo "ls --> liste les fichiers"
584 Mot inconnu : ls =>      echo "ls --> liste les fichiers"
584 Guillemets typographiques fermants. =>      echo "ls --> liste les fichiers"

585 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>      echo "rm --> détruit un fichier (guidé)"
585 Mot inconnu : echo =>      echo "rm --> détruit un fichier (guidé)"
585 Guillemets typographiques ouvrants. =>      echo "rm --> détruit un fichier (guidé)"
585 Mot inconnu : rm =>      echo "rm --> détruit un fichier (guidé)"

586 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>      echo "rmd --> efface un dossier (guidé)"
586 Mot inconnu : echo =>      echo "rmd --> efface un dossier (guidé)"
586 Guillemets typographiques ouvrants. =>      echo "rmd --> efface un dossier (guidé)"
586 Mot inconnu : rmd =>      echo "rmd --> efface un dossier (guidé)"

587 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>      echo "noyau --> version du noyau Linux"
587 Mot inconnu : echo =>      echo "noyau --> version du noyau Linux"
587 Guillemets typographiques ouvrants. =>      echo "noyau --> version du noyau Linux"
587 Guillemets typographiques fermants. =>      echo "noyau --> version du noyau Linux"

588 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>      echo "connect --> savoir qui s'est connecté dernièrement";;
588 Mot inconnu : echo =>      echo "connect --> savoir qui s'est connecté dernièrement";;
588 Guillemets typographiques ouvrants. =>      echo "connect --> savoir qui s'est connecté dernièrement";;
588 Mot inconnu : connect =>      echo "connect --> savoir qui s'est connecté dernièrement";;
588 Guillemets typographiques fermants. =>      echo "connect --> savoir qui s'est connecté dernièrement";;
588 Une de ces ponctuations est superflue. =>      echo "connect --> savoir qui s'est connecté dernièrement";;

589 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   ls )
589 Mot inconnu : ls =>   ls )
589 Pas d’espace avant ce signe. =>   ls )

590 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>      ls -la;;
590 Mot inconnu : ls =>      ls -la;;
590 Il manque un espace à côté du tiret. =>      ls -la;;
590 Une de ces ponctuations est superflue. =>      ls -la;;

591 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   rm )
591 Mot inconnu : rm =>   rm )
591 Pas d’espace avant ce signe. =>   rm )

592 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>      echo -n "Quel fichier voulez-vous effacer : "
592 Mot inconnu : echo =>      echo -n "Quel fichier voulez-vous effacer : "
592 Il manque un espace à côté du tiret. =>      echo -n "Quel fichier voulez-vous effacer : "
592 Guillemets typographiques ouvrants. =>      echo -n "Quel fichier voulez-vous effacer : "
592 Il manque un espace insécable. =>      echo -n "Quel fichier voulez-vous effacer : "
592 Guillemets fermants. =>      echo -n "Quel fichier voulez-vous effacer : "

593 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>      read eff
593 Mot inconnu : read =>      read eff
593 Mot inconnu : eff =>      read eff

594 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>      rm -f $eff;;
594 Mot inconnu : rm =>      rm -f $eff;;
594 Il manque un espace à côté du tiret. =>      rm -f $eff;;
594 Mot inconnu : eff =>      rm -f $eff;;
594 Une de ces ponctuations est superflue. =>      rm -f $eff;;

595 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   rmd | rmdir )
595 Mot inconnu : rmd =>   rmd | rmdir )
595 Mot inconnu : rmdir =>   rmd | rmdir )
595 Pas d’espace avant ce signe. =>   rmd | rmdir )

596 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>      echo -n "Quel répertoire voulez-vous effacer : "
596 Mot inconnu : echo =>      echo -n "Quel répertoire voulez-vous effacer : "
596 Il manque un espace à côté du tiret. =>      echo -n "Quel répertoire voulez-vous effacer : "
596 Guillemets typographiques ouvrants. =>      echo -n "Quel répertoire voulez-vous effacer : "
596 Il manque un espace insécable. =>      echo -n "Quel répertoire voulez-vous effacer : "
596 Guillemets fermants. =>      echo -n "Quel répertoire voulez-vous effacer : "

597 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>      read eff
597 Mot inconnu : read =>      read eff
597 Mot inconnu : eff =>      read eff

598 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>      rm -r $eff;;
598 Mot inconnu : rm =>      rm -r $eff;;
598 Il manque un espace à côté du tiret. =>      rm -r $eff;;
598 Mot inconnu : eff =>      rm -r $eff;;
598 Une de ces ponctuations est superflue. =>      rm -r $eff;;

599 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   noyau | "uname -r" )
599 Guillemets typographiques ouvrants. =>   noyau | "uname -r" )
599 Mot inconnu : uname =>   noyau | "uname -r" )
599 Il manque un espace à côté du tiret. =>   noyau | "uname -r" )
599 Guillemets typographiques fermants. =>   noyau | "uname -r" )
599 Pas d’espace avant ce signe. =>   noyau | "uname -r" )

600 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>      uname -r;;
600 Mot inconnu : uname =>      uname -r;;
600 Il manque un espace à côté du tiret. =>      uname -r;;
600 Une de ces ponctuations est superflue. =>      uname -r;;

601 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   connect )
601 Mot inconnu : connect =>   connect )
601 Pas d’espace avant ce signe. =>   connect )

602 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>      last;;
602 Mot inconnu : last =>      last;;
602 Une de ces ponctuations est superflue. =>      last;;

603 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   about | --v | vers )
603 Pas d’espace avant ce signe. =>   about | --v | vers )

604 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>      echo "Script simple pour l'initiation aux scripts shell";;
604 Mot inconnu : echo =>      echo "Script simple pour l'initiation aux scripts shell";;
604 Guillemets typographiques ouvrants. =>      echo "Script simple pour l'initiation aux scripts shell";;
604 Guillemets typographiques fermants. =>      echo "Script simple pour l'initiation aux scripts shell";;
604 Une de ces ponctuations est superflue. =>      echo "Script simple pour l'initiation aux scripts shell";;

605 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   quit | "exit" )
605 Mot inconnu : quit =>   quit | "exit" )
605 Guillemets typographiques ouvrants. =>   quit | "exit" )
605 Guillemets typographiques fermants. =>   quit | "exit" )
605 Pas d’espace avant ce signe. =>   quit | "exit" )

606 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>      echo Au revoir!!
606 Mot inconnu : echo =>      echo Au revoir!!
606 Il manque un espace insécable. =>      echo Au revoir!!

607 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>      break;;
607 Une de ces ponctuations est superflue. =>      break;;

608 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * )
608 Pas d’espace avant ce signe. =>   * )

609 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     echo "Commande inconnue";;
609 Mot inconnu : echo =>     echo "Commande inconnue";;
609 Guillemets typographiques ouvrants. =>     echo "Commande inconnue";;
609 Guillemets typographiques fermants. =>     echo "Commande inconnue";;
609 Une de ces ponctuations est superflue. =>     echo "Commande inconnue";;

610 Mot inconnu : esac => esac

611 Mot inconnu : done => done

617 Majuscule en début de phrase, sauf éventuellement lors d’une énumération. => ce programme. En effet, celui-ci est plus lisible et cela évite aussi de faire

618 Majuscule en début de phrase, sauf éventuellement lors d’une énumération. => des erreurs. C'est pourquoi il est préférable de bien structurer le code que vous

623 Il manque un espace insécable. => L'instruction `for` exécute ce qui est dans son bloc un nombre de fois prédéfini. Sa syntaxe est la suivante :

625 Il manque un espace insécable. => for variable in valeurs; do

626 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     instructions

627 Mot inconnu : done => done

630 Il manque un espace insécable. => ou le classique:

632 Pas d’espace après ce signe. => for (( i=$min; i<=$max; i++ )); do
632 Il manque un espace insécable. => for (( i=$min; i<=$max; i++ )); do
632 Il manque un espace insécable. => for (( i=$min; i<=$max; i++ )); do
632 Pas d’espace avant ce signe. => for (( i=$min; i<=$max; i++ )); do

633 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     instructions_avec_i # ou pas
633 Mot inconnu : instructions_avec_i =>     instructions_avec_i # ou pas

634 Mot inconnu : done => done

637 Mot inconnu : iable => Comme vous l'aurez sans doute remarqué, on assigne une valeur différente à //variable// à chaque itération. On peut aussi très facilement utiliser des fichiers comme "valeur".\\
637 Guillemets typographiques ouvrants. => Comme vous l'aurez sans doute remarqué, on assigne une valeur différente à //variable// à chaque itération. On peut aussi très facilement utiliser des fichiers comme "valeur".\\
637 Guillemets typographiques fermants. => Comme vous l'aurez sans doute remarqué, on assigne une valeur différente à //variable// à chaque itération. On peut aussi très facilement utiliser des fichiers comme "valeur".\\

638 Il manque un espace insécable. => Rien ne vaut un exemple :

640 Il manque un espace insécable. => #!/bin/sh

641 Mot inconnu : txt => for var in *.txt; do
641 Il manque un espace insécable. => for var in *.txt; do

642 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     echo "$var"
642 Mot inconnu : echo =>     echo "$var"
642 Guillemets typographiques fermants. =>     echo "$var"

643 Mot inconnu : done => done 
643 Espace(s) en fin de ligne à supprimer. => done 

646 Il manque un espace insécable. => On peut voir une syntaxe un peu particulière :

647 Mot inconnu : txt => <code bash>$(sort *.txt)</code>

650 Il manque un espace insécable. => On peut aussi utiliser cette instruction simplement avec des nombres, cela permet de connaître le nombre d'itérations :

652 Il manque un espace insécable. => #!/bin/sh

653 Il manque un espace insécable. => for var in 1 2 3 4 5 6 7 8 9; do

654 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     echo $var
654 Mot inconnu : echo =>     echo $var

655 Mot inconnu : done => done 
655 Espace(s) en fin de ligne à supprimer. => done 

658 Pléonasme. => On peut très bien aussi utiliser d'autres types de variables, comme par exemple des chaînes de caractères :
658 Il manque un espace insécable. => On peut très bien aussi utiliser d'autres types de variables, comme par exemple des chaînes de caractères :

660 Il manque un espace insécable. => #!/bin/sh

661 Mot inconnu : Breezy => for var in Ubuntu Breezy 5.10; do
661 Il manque un espace insécable. => for var in Ubuntu Breezy 5.10; do

662 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     echo $var
662 Mot inconnu : echo =>     echo $var

663 Mot inconnu : done => done 
663 Espace(s) en fin de ligne à supprimer. => done 

666 Mot inconnu : Breezy => Il faut quand même faire attention au fait que //Ubuntu Breezy 5.10// est différent de //"Ubuntu Breezy 5.10"// dans ce cas. En effet, tous les mots placés entre "" sont considérés comme faisant partie de la même chaîne de caractères. Sans les "", sh considèrera qu'il y a une liste de trois chaînes de caractères.
666 Guillemets typographiques ouvrants. => Il faut quand même faire attention au fait que //Ubuntu Breezy 5.10// est différent de //"Ubuntu Breezy 5.10"// dans ce cas. En effet, tous les mots placés entre "" sont considérés comme faisant partie de la même chaîne de caractères. Sans les "", sh considèrera qu'il y a une liste de trois chaînes de caractères.
666 Mot inconnu : Breezy => Il faut quand même faire attention au fait que //Ubuntu Breezy 5.10// est différent de //"Ubuntu Breezy 5.10"// dans ce cas. En effet, tous les mots placés entre "" sont considérés comme faisant partie de la même chaîne de caractères. Sans les "", sh considèrera qu'il y a une liste de trois chaînes de caractères.
666 Guillemets typographiques fermants. => Il faut quand même faire attention au fait que //Ubuntu Breezy 5.10// est différent de //"Ubuntu Breezy 5.10"// dans ce cas. En effet, tous les mots placés entre "" sont considérés comme faisant partie de la même chaîne de caractères. Sans les "", sh considèrera qu'il y a une liste de trois chaînes de caractères.
666 Mot inconnu : sh => Il faut quand même faire attention au fait que //Ubuntu Breezy 5.10// est différent de //"Ubuntu Breezy 5.10"// dans ce cas. En effet, tous les mots placés entre "" sont considérés comme faisant partie de la même chaîne de caractères. Sans les "", sh considèrera qu'il y a une liste de trois chaînes de caractères.

671 Typographie : points de suspension. Utilisez le caractère dédié. => Les fonctions sont indispensables pour bien structurer un programme mais aussi pouvoir le simplifier, créer une tâche, la rappeler... Voici la syntaxe générale de 'déclaration' d'une fonction :
671 Guillemets typographiques ouvrants. => Les fonctions sont indispensables pour bien structurer un programme mais aussi pouvoir le simplifier, créer une tâche, la rappeler... Voici la syntaxe générale de 'déclaration' d'une fonction :
671 Guillemets typographiques fermants. => Les fonctions sont indispensables pour bien structurer un programme mais aussi pouvoir le simplifier, créer une tâche, la rappeler... Voici la syntaxe générale de 'déclaration' d'une fonction :
671 Il manque un espace insécable. => Les fonctions sont indispensables pour bien structurer un programme mais aussi pouvoir le simplifier, créer une tâche, la rappeler... Voici la syntaxe générale de 'déclaration' d'une fonction :

673 Mot inconnu : nom_fonction => nom_fonction(){

674 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   instructions

678 Il manque un trait d’union si “même” se rapporte à “elle”. => Cette partie ne fait rien en elle même, elle dit juste que quand on appellera nom_fonction, elle fera instruction. Pour appeler une fonction (qui ne possède pas d'argument, voir plus loin) rien de plus simple :
678 Mot inconnu : nom_fonction => Cette partie ne fait rien en elle même, elle dit juste que quand on appellera nom_fonction, elle fera instruction. Pour appeler une fonction (qui ne possède pas d'argument, voir plus loin) rien de plus simple :
678 Il manque un espace insécable. => Cette partie ne fait rien en elle même, elle dit juste que quand on appellera nom_fonction, elle fera instruction. Pour appeler une fonction (qui ne possède pas d'argument, voir plus loin) rien de plus simple :

680 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   nom_fonction
680 Mot inconnu : nom_fonction =>   nom_fonction

682 Il manque un espace insécable. => Rien ne vaut un petit exemple :

684 Il manque un espace insécable. => #!/bin/sh

687 Mot inconnu : mafonction => mafonction(){

688 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   echo 'La liste des fichiers de ce répertoire'
688 Mot inconnu : echo =>   echo 'La liste des fichiers de ce répertoire'
688 Guillemets typographiques ouvrants. =>   echo 'La liste des fichiers de ce répertoire'
688 Guillemets typographiques fermants. =>   echo 'La liste des fichiers de ce répertoire'

689 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   ls -l
689 Mot inconnu : ls =>   ls -l
689 Il manque un espace à côté du tiret. =>   ls -l

693 Mot inconnu : echo => echo 'Vous allez voir la liste des fichiers de ce répertoire:'
693 Guillemets typographiques ouvrants. => echo 'Vous allez voir la liste des fichiers de ce répertoire:'

694 Mot inconnu : mafonction => mafonction       #appel de ma fonction
694 Espace(s) surnuméraire(s) à supprimer. => mafonction       #appel de ma fonction

696 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   

697 Mot inconnu : echo => Comme vous l'avez sans doute remarqué, quand on appelle la fonction, on exécute simplement ce qu'on lui a défini au début, dans notre exemple, echo... et ls -l, on peut donc faire exécuter n'importe quoi à une fonction. 
697 Typographie : points de suspension. Utilisez le caractère dédié. => Comme vous l'avez sans doute remarqué, quand on appelle la fonction, on exécute simplement ce qu'on lui a défini au début, dans notre exemple, echo... et ls -l, on peut donc faire exécuter n'importe quoi à une fonction. 
697 Mot inconnu : ls => Comme vous l'avez sans doute remarqué, quand on appelle la fonction, on exécute simplement ce qu'on lui a défini au début, dans notre exemple, echo... et ls -l, on peut donc faire exécuter n'importe quoi à une fonction. 
697 Il manque un espace à côté du tiret. => Comme vous l'avez sans doute remarqué, quand on appelle la fonction, on exécute simplement ce qu'on lui a défini au début, dans notre exemple, echo... et ls -l, on peut donc faire exécuter n'importe quoi à une fonction. 
697 Espace(s) en fin de ligne à supprimer. => Comme vous l'avez sans doute remarqué, quand on appelle la fonction, on exécute simplement ce qu'on lui a défini au début, dans notre exemple, echo... et ls -l, on peut donc faire exécuter n'importe quoi à une fonction. 

699 Mot inconnu : bash => Les fonctions peuvent être définies n'importe où dans le code du moment qu'elles sont définies avant d'être utilisées. Même si en bash les variables sont globales, il est possible de les déclarer comme locales au sein d'une fonction en la précédant du mot clé local: local ma_fonction .
699 Il manque un espace insécable. => Les fonctions peuvent être définies n'importe où dans le code du moment qu'elles sont définies avant d'être utilisées. Même si en bash les variables sont globales, il est possible de les déclarer comme locales au sein d'une fonction en la précédant du mot clé local: local ma_fonction .
699 Mot inconnu : ma_fonction => Les fonctions peuvent être définies n'importe où dans le code du moment qu'elles sont définies avant d'être utilisées. Même si en bash les variables sont globales, il est possible de les déclarer comme locales au sein d'une fonction en la précédant du mot clé local: local ma_fonction .

701 Il manque un espace insécable. => Exemple: un sleep interactif :
701 Mot inconnu : sleep => Exemple: un sleep interactif :
701 Il manque un espace insécable. => Exemple: un sleep interactif :

703 Il manque un espace insécable. => #!/bin/bash

705 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>         echo -e "$1\nBye"
705 Mot inconnu : echo =>         echo -e "$1\nBye"
705 Il manque un espace à côté du tiret. =>         echo -e "$1\nBye"
705 Mot inconnu : nBye =>         echo -e "$1\nBye"
705 Guillemets typographiques fermants. =>         echo -e "$1\nBye"

706 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>         exit

708 Il manque un espace à côté du tiret. => test -z "$1" && info "requiert 1 argument pour le temps d'attente..." || PRINT=$(($1*500))
708 Guillemets typographiques fermants. => test -z "$1" && info "requiert 1 argument pour le temps d'attente..." || PRINT=$(($1*500))
708 Guillemets typographiques ouvrants. => test -z "$1" && info "requiert 1 argument pour le temps d'attente..." || PRINT=$(($1*500))
708 Typographie : points de suspension. Utilisez le caractère dédié. => test -z "$1" && info "requiert 1 argument pour le temps d'attente..." || PRINT=$(($1*500))
708 Guillemets typographiques fermants. => test -z "$1" && info "requiert 1 argument pour le temps d'attente..." || PRINT=$(($1*500))
708 Mot inconnu : PRINT => test -z "$1" && info "requiert 1 argument pour le temps d'attente..." || PRINT=$(($1*500))
708 Signe de multiplication typographique. => test -z "$1" && info "requiert 1 argument pour le temps d'attente..." || PRINT=$(($1*500))

709 Il manque un espace à côté du tiret. => test -z $(echo "$1" | grep -e "^[0-9]*$") && info "'$1' est un mauvais argument"
709 Mot inconnu : echo => test -z $(echo "$1" | grep -e "^[0-9]*$") && info "'$1' est un mauvais argument"
709 Guillemets typographiques fermants. => test -z $(echo "$1" | grep -e "^[0-9]*$") && info "'$1' est un mauvais argument"
709 Mot inconnu : grep => test -z $(echo "$1" | grep -e "^[0-9]*$") && info "'$1' est un mauvais argument"
709 Il manque un espace à côté du tiret. => test -z $(echo "$1" | grep -e "^[0-9]*$") && info "'$1' est un mauvais argument"
709 Guillemets typographiques fermants. => test -z $(echo "$1" | grep -e "^[0-9]*$") && info "'$1' est un mauvais argument"
709 Guillemets typographiques fermants. => test -z $(echo "$1" | grep -e "^[0-9]*$") && info "'$1' est un mauvais argument"

710 Il manque un espace à côté du tiret. => test $1 -gt 0 || info "Je ne prends que les entiers > 0"
710 Mot inconnu : gt => test $1 -gt 0 || info "Je ne prends que les entiers > 0"
710 Guillemets typographiques ouvrants. => test $1 -gt 0 || info "Je ne prends que les entiers > 0"
710 Guillemets typographiques fermants. => test $1 -gt 0 || info "Je ne prends que les entiers > 0"

711 Mot inconnu : print_until_sleep => print_until_sleep(){

712 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>          local COUNT=0
712 Mot inconnu : COUNT =>          local COUNT=0

713 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>          while [ -d /proc/$1 ]; do
713 Mot inconnu : while =>          while [ -d /proc/$1 ]; do
713 Pas d’espace après ce signe. =>          while [ -d /proc/$1 ]; do
713 Mot inconnu : proc =>          while [ -d /proc/$1 ]; do
713 Pas d’espace avant ce signe. =>          while [ -d /proc/$1 ]; do

714 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     

715 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>                   test $(($COUNT%$2)) -eq 0 && echo -n "*"
715 Mot inconnu : COUNT =>                   test $(($COUNT%$2)) -eq 0 && echo -n "*"
715 Mot inconnu : eq =>                   test $(($COUNT%$2)) -eq 0 && echo -n "*"
715 Mot inconnu : echo =>                   test $(($COUNT%$2)) -eq 0 && echo -n "*"
715 Il manque un espace à côté du tiret. =>                   test $(($COUNT%$2)) -eq 0 && echo -n "*"

716 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>                   COUNT=$(($COUNT+1))
716 Mot inconnu : COUNT =>                   COUNT=$(($COUNT+1))
716 Mot inconnu : COUNT =>                   COUNT=$(($COUNT+1))

717 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>          done
717 Mot inconnu : done =>          done

719 Mot inconnu : sleep => sleep $1 & print_until_sleep $! $PRINT
719 Mot inconnu : print_until_sleep => sleep $1 & print_until_sleep $! $PRINT
719 Mot inconnu : PRINT => sleep $1 & print_until_sleep $! $PRINT

720 Mot inconnu : echo => echo -e "\nBye"
720 Il manque un espace à côté du tiret. => echo -e "\nBye"
720 Mot inconnu : nBye => echo -e "\nBye"
720 Guillemets typographiques fermants. => echo -e "\nBye"

726 Il manque un espace insécable. => Pour extraire une chaîne d'une chaîne on utilise : **${ ''chaîne'' : ''position'' : ''nombre de caractères'' }** (n'oubliez pas le **:** qui sépare les "paramètres").
726 Guillemets typographiques ouvrants. => Pour extraire une chaîne d'une chaîne on utilise : **${ ''chaîne'' : ''position'' : ''nombre de caractères'' }** (n'oubliez pas le **:** qui sépare les "paramètres").
726 Guillemets typographiques fermants. => Pour extraire une chaîne d'une chaîne on utilise : **${ ''chaîne'' : ''position'' : ''nombre de caractères'' }** (n'oubliez pas le **:** qui sépare les "paramètres").
726 Il manque un espace insécable. => Pour extraire une chaîne d'une chaîne on utilise : **${ ''chaîne'' : ''position'' : ''nombre de caractères'' }** (n'oubliez pas le **:** qui sépare les "paramètres").
726 Guillemets typographiques ouvrants. => Pour extraire une chaîne d'une chaîne on utilise : **${ ''chaîne'' : ''position'' : ''nombre de caractères'' }** (n'oubliez pas le **:** qui sépare les "paramètres").
726 Guillemets typographiques fermants. => Pour extraire une chaîne d'une chaîne on utilise : **${ ''chaîne'' : ''position'' : ''nombre de caractères'' }** (n'oubliez pas le **:** qui sépare les "paramètres").
726 Il manque un espace insécable. => Pour extraire une chaîne d'une chaîne on utilise : **${ ''chaîne'' : ''position'' : ''nombre de caractères'' }** (n'oubliez pas le **:** qui sépare les "paramètres").
726 Guillemets typographiques ouvrants. => Pour extraire une chaîne d'une chaîne on utilise : **${ ''chaîne'' : ''position'' : ''nombre de caractères'' }** (n'oubliez pas le **:** qui sépare les "paramètres").
726 Guillemets typographiques fermants. => Pour extraire une chaîne d'une chaîne on utilise : **${ ''chaîne'' : ''position'' : ''nombre de caractères'' }** (n'oubliez pas le **:** qui sépare les "paramètres").
726 Guillemets typographiques ouvrants. => Pour extraire une chaîne d'une chaîne on utilise : **${ ''chaîne'' : ''position'' : ''nombre de caractères'' }** (n'oubliez pas le **:** qui sépare les "paramètres").
726 Guillemets typographiques fermants. => Pour extraire une chaîne d'une chaîne on utilise : **${ ''chaîne'' : ''position'' : ''nombre de caractères'' }** (n'oubliez pas le **:** qui sépare les "paramètres").

728 Guillemets typographiques ouvrants. => <note important>Dans la partie ''chaîne'' pour faire référence à une variable **on ne met pas de $** ! Tandis que dans les autres options le $ est nécessaire (sauf si vous n'utilisez pas de variable). Il y a de quoi s’emmêler les pinceaux. Si vous n'avez pas compris (ce n'est pas étonnant), les exemples de cette partie vous aideront beaucoup.</note>
728 Guillemets typographiques fermants. => <note important>Dans la partie ''chaîne'' pour faire référence à une variable **on ne met pas de $** ! Tandis que dans les autres options le $ est nécessaire (sauf si vous n'utilisez pas de variable). Il y a de quoi s’emmêler les pinceaux. Si vous n'avez pas compris (ce n'est pas étonnant), les exemples de cette partie vous aideront beaucoup.</note>
728 Il manque un espace insécable. => <note important>Dans la partie ''chaîne'' pour faire référence à une variable **on ne met pas de $** ! Tandis que dans les autres options le $ est nécessaire (sauf si vous n'utilisez pas de variable). Il y a de quoi s’emmêler les pinceaux. Si vous n'avez pas compris (ce n'est pas étonnant), les exemples de cette partie vous aideront beaucoup.</note>

730 Il manque un espace insécable. => Par exemple pour savoir ce que l'on aime manger en fonction de sa langue (vous êtes alors vraiment ultra geek 8-O !) :
730 Il manque un espace insécable. => Par exemple pour savoir ce que l'on aime manger en fonction de sa langue (vous êtes alors vraiment ultra geek 8-O !) :

732 Il manque un espace insécable. => #!/bin/bash

734 Pas d’espace après ce signe. => if [ ${LANG:0:2} = "fr" ]; then
734 Mot inconnu : LANG => if [ ${LANG:0:2} = "fr" ]; then
734 Il manque un espace. => if [ ${LANG:0:2} = "fr" ]; then
734 Guillemets typographiques ouvrants. => if [ ${LANG:0:2} = "fr" ]; then
734 Guillemets typographiques fermants. => if [ ${LANG:0:2} = "fr" ]; then
734 Pas d’espace avant ce signe. => if [ ${LANG:0:2} = "fr" ]; then
734 Mot inconnu : then => if [ ${LANG:0:2} = "fr" ]; then

735 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     echo "Vous aimez les moules frites !"
735 Mot inconnu : echo =>     echo "Vous aimez les moules frites !"
735 Guillemets typographiques ouvrants. =>     echo "Vous aimez les moules frites !"
735 Il manque un espace insécable. =>     echo "Vous aimez les moules frites !"
735 Guillemets typographiques fermants. =>     echo "Vous aimez les moules frites !"

736 Mot inconnu : elif => elif [ ${LANG:0:2} = "en" ]; then
736 Pas d’espace après ce signe. => elif [ ${LANG:0:2} = "en" ]; then
736 Mot inconnu : LANG => elif [ ${LANG:0:2} = "en" ]; then
736 Il manque un espace. => elif [ ${LANG:0:2} = "en" ]; then
736 Guillemets typographiques ouvrants. => elif [ ${LANG:0:2} = "en" ]; then
736 Guillemets typographiques fermants. => elif [ ${LANG:0:2} = "en" ]; then
736 Pas d’espace avant ce signe. => elif [ ${LANG:0:2} = "en" ]; then
736 Mot inconnu : then => elif [ ${LANG:0:2} = "en" ]; then

737 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     echo "You love the... pudding !"
737 Mot inconnu : echo =>     echo "You love the... pudding !"
737 Guillemets typographiques ouvrants. =>     echo "You love the... pudding !"
737 Mot inconnu : You =>     echo "You love the... pudding !"
737 Mot inconnu : the =>     echo "You love the... pudding !"
737 Typographie : points de suspension. Utilisez le caractère dédié. =>     echo "You love the... pudding !"
737 Il manque un espace insécable. =>     echo "You love the... pudding !"
737 Guillemets typographiques fermants. =>     echo "You love the... pudding !"

738 Mot inconnu : elif => elif [ ${LANG:0:2} = "es" ]; then
738 Pas d’espace après ce signe. => elif [ ${LANG:0:2} = "es" ]; then
738 Mot inconnu : LANG => elif [ ${LANG:0:2} = "es" ]; then
738 Il manque un espace. => elif [ ${LANG:0:2} = "es" ]; then
738 Guillemets typographiques ouvrants. => elif [ ${LANG:0:2} = "es" ]; then
738 Guillemets typographiques fermants. => elif [ ${LANG:0:2} = "es" ]; then
738 Pas d’espace avant ce signe. => elif [ ${LANG:0:2} = "es" ]; then
738 Mot inconnu : then => elif [ ${LANG:0:2} = "es" ]; then

739 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     echo "Te gusta el jamón !"    
739 Mot inconnu : echo =>     echo "Te gusta el jamón !"    
739 Guillemets typographiques ouvrants. =>     echo "Te gusta el jamón !"    
739 Mot inconnu : gusta =>     echo "Te gusta el jamón !"    
739 Mot inconnu : el =>     echo "Te gusta el jamón !"    
739 Mot inconnu : jamón =>     echo "Te gusta el jamón !"    
739 Il manque un espace insécable. =>     echo "Te gusta el jamón !"    
739 Guillemets typographiques fermants. =>     echo "Te gusta el jamón !"    
739 Espace(s) en fin de ligne à supprimer. =>     echo "Te gusta el jamón !"    

740 Mot inconnu : else => else

741 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     echo ":'-("
741 Mot inconnu : echo =>     echo ":'-("

743 Mot inconnu : LANG => #Noter que $LANG n'a pas le préfixe '$'. ${$LANG:0:2} ne fonctionne pas !
743 Mot inconnu : LANG => #Noter que $LANG n'a pas le préfixe '$'. ${$LANG:0:2} ne fonctionne pas !
743 Il manque un espace. => #Noter que $LANG n'a pas le préfixe '$'. ${$LANG:0:2} ne fonctionne pas !
743 Il manque un espace insécable. => #Noter que $LANG n'a pas le préfixe '$'. ${$LANG:0:2} ne fonctionne pas !

745 Il manque un espace insécable. => puis :

747 Mot inconnu : favoritefood => $ ./favoritefood

748 Il manque un espace insécable. => Vous aimez les moules frites !

749 Mot inconnu : LANG => $ env LANG=en ./favoritefood
749 Mot inconnu : favoritefood => $ env LANG=en ./favoritefood

750 Mot inconnu : You => You love the... pudding !
750 Mot inconnu : the => You love the... pudding !
750 Typographie : points de suspension. Utilisez le caractère dédié. => You love the... pudding !
750 Il manque un espace insécable. => You love the... pudding !

751 Mot inconnu : LANG => $ env LANG=es ./favoritefood
751 Mot inconnu : favoritefood => $ env LANG=es ./favoritefood

752 Mot inconnu : gusta => Te gusta el jamón !
752 Mot inconnu : el => Te gusta el jamón !
752 Mot inconnu : jamón => Te gusta el jamón !
752 Il manque un espace insécable. => Te gusta el jamón !

753 Mot inconnu : LANG => $ env LANG=it ./favoritefood
753 Mot inconnu : it => $ env LANG=it ./favoritefood
753 Mot inconnu : favoritefood => $ env LANG=it ./favoritefood

758 Guillemets typographiques ouvrants. => Une variante permet de tronquer uniquement le début de la chaîne. C'est **${ ''chaîne'' : ''nombre de caractères''}** .\\
758 Guillemets typographiques fermants. => Une variante permet de tronquer uniquement le début de la chaîne. C'est **${ ''chaîne'' : ''nombre de caractères''}** .\\
758 Il manque un espace insécable. => Une variante permet de tronquer uniquement le début de la chaîne. C'est **${ ''chaîne'' : ''nombre de caractères''}** .\\
758 Guillemets typographiques ouvrants. => Une variante permet de tronquer uniquement le début de la chaîne. C'est **${ ''chaîne'' : ''nombre de caractères''}** .\\
758 Guillemets typographiques fermants. => Une variante permet de tronquer uniquement le début de la chaîne. C'est **${ ''chaîne'' : ''nombre de caractères''}** .\\

759 Il manque un espace insécable. => Le tout peut s'illustrer par un (vraiment) petit exemple :

761 Il manque un espace insécable. => #!/bin/bash

763 Mot inconnu : echo => echo ${1:$2}

764 Mot inconnu : echo => #Noter bien que echo ${1:2} tronquerait les 2 premiers caractères (et non le nombre indiqué par le 2e paramètre).
764 Nombre ordinal singulier. Exemples : 2ᵉ, 3ᵉ, 4ᵉ… => #Noter bien que echo ${1:2} tronquerait les 2 premiers caractères (et non le nombre indiqué par le 2e paramètre).

766 Il manque un espace insécable. => puis :

768 Mot inconnu : truncbegin => $ ./truncbegin "Hello world !" 5
768 Guillemets typographiques ouvrants. => $ ./truncbegin "Hello world !" 5
768 Mot inconnu : world => $ ./truncbegin "Hello world !" 5
768 Il manque un espace insécable. => $ ./truncbegin "Hello world !" 5
768 Guillemets typographiques fermants. => $ ./truncbegin "Hello world !" 5

769 Mot inconnu : world => world !
769 Il manque un espace insécable. => world !

780 Mot inconnu : echo => echo -e '\033[A;B;Cm toto \033[0m'
780 Il manque un espace à côté du tiret. => echo -e '\033[A;B;Cm toto \033[0m'
780 Il manque un espace insécable. => echo -e '\033[A;B;Cm toto \033[0m'
780 Il manque un espace. => echo -e '\033[A;B;Cm toto \033[0m'
780 Il manque un espace insécable. => echo -e '\033[A;B;Cm toto \033[0m'
780 Il manque un espace. => echo -e '\033[A;B;Cm toto \033[0m'
780 Guillemets typographiques fermants. => echo -e '\033[A;B;Cm toto \033[0m'

782 Il manque un espace insécable. => Dans la commande passée ci-dessus, nous pouvons constater qu’il y a 3 paramètres présents: A, B et C.\\

783 Il manque un espace insécable. => A : correspond à un effet affecté au texte affiché
783 S’il s’agit d’un impératif, ajoutez un “s”. => A : correspond à un effet affecté au texte affiché

784 Il manque un espace insécable. => B : correspond à la couleur du texte
784 S’il s’agit d’un impératif, ajoutez un “s”. => B : correspond à la couleur du texte

785 Il manque un espace insécable. => C : identifie la couleur du fond du texte affiché

787 Il manque un espace insécable. => Et enfin on termine notre affichage avec « \033[0m », qui spécifie au terminal de revenir aux couleurs définies par défaut.
787 Avec une unité de mesure, mettez un espace insécable. => Et enfin on termine notre affichage avec « \033[0m », qui spécifie au terminal de revenir aux couleurs définies par défaut.
787 Il manque un espace insécable. => Et enfin on termine notre affichage avec « \033[0m », qui spécifie au terminal de revenir aux couleurs définies par défaut.

791 Il manque un espace insécable. => Nous allons commencer par les différents effets possibles :

801 Mot inconnu : __Souligné__ => |4|__Souligné__|

829 Mot inconnu : echo => echo -e '\033[1;30;47m toto \033[0;32m est sur \033[1;33m un bateau \033[0m'
829 Il manque un espace à côté du tiret. => echo -e '\033[1;30;47m toto \033[0;32m est sur \033[1;33m un bateau \033[0m'
829 Il manque un espace insécable. => echo -e '\033[1;30;47m toto \033[0;32m est sur \033[1;33m un bateau \033[0m'
829 Il manque un espace. => echo -e '\033[1;30;47m toto \033[0;32m est sur \033[1;33m un bateau \033[0m'
829 Il manque un espace insécable. => echo -e '\033[1;30;47m toto \033[0;32m est sur \033[1;33m un bateau \033[0m'
829 Il manque un espace. => echo -e '\033[1;30;47m toto \033[0;32m est sur \033[1;33m un bateau \033[0m'
829 Il manque un espace insécable. => echo -e '\033[1;30;47m toto \033[0;32m est sur \033[1;33m un bateau \033[0m'
829 Il manque un espace. => echo -e '\033[1;30;47m toto \033[0;32m est sur \033[1;33m un bateau \033[0m'
829 Il manque un espace insécable. => echo -e '\033[1;30;47m toto \033[0;32m est sur \033[1;33m un bateau \033[0m'
829 Il manque un espace. => echo -e '\033[1;30;47m toto \033[0;32m est sur \033[1;33m un bateau \033[0m'
829 Guillemets typographiques fermants. => echo -e '\033[1;30;47m toto \033[0;32m est sur \033[1;33m un bateau \033[0m'

834 Mot inconnu : script_shell => Comme indiqué dans la [[script_shell#liens|section liens]] de cette page, de très bon exemples et exercices illustrent le cours disponible sur cette page :\\ 
834 Accord de nombre erroné avec « exemples ». => Comme indiqué dans la [[script_shell#liens|section liens]] de cette page, de très bon exemples et exercices illustrent le cours disponible sur cette page :\\ 
834 Accord de nombre erroné avec « bon ». => Comme indiqué dans la [[script_shell#liens|section liens]] de cette page, de très bon exemples et exercices illustrent le cours disponible sur cette page :\\ 
834 Il manque un espace insécable. => Comme indiqué dans la [[script_shell#liens|section liens]] de cette page, de très bon exemples et exercices illustrent le cours disponible sur cette page :\\ 
834 Espace(s) en fin de ligne à supprimer. => Comme indiqué dans la [[script_shell#liens|section liens]] de cette page, de très bon exemples et exercices illustrent le cours disponible sur cette page :\\ 

835 Mot inconnu : Bash => [[http://abs.traduc.org/abs-5.3-fr/apm.html|Guide avancé d'écriture des scripts Bash - Une exploration en profondeur de l'art de la programmation shell]]
835 Tiret d’incise : un tiret demi-cadratin [1] ou cadratin [2] est requis. (Ou éventuellement le signe “moins” [3], s’il s’agit d’une soustraction.) => [[http://abs.traduc.org/abs-5.3-fr/apm.html|Guide avancé d'écriture des scripts Bash - Une exploration en profondeur de l'art de la programmation shell]]

837 Il manque un espace insécable. => Aux structures décrites ci-dessus, il est nécessaire, pour réaliser des scripts poussés, de connaître les commandes shell les plus usitées.\\ Vous en trouverez une présentation sur cette autre page du wiki : [[projets:ecole:scripting:initiation_au_shell]] .
837 Il manque un espace. => Aux structures décrites ci-dessus, il est nécessaire, pour réaliser des scripts poussés, de connaître les commandes shell les plus usitées.\\ Vous en trouverez une présentation sur cette autre page du wiki : [[projets:ecole:scripting:initiation_au_shell]] .
837 Mot inconnu : ecole => Aux structures décrites ci-dessus, il est nécessaire, pour réaliser des scripts poussés, de connaître les commandes shell les plus usitées.\\ Vous en trouverez une présentation sur cette autre page du wiki : [[projets:ecole:scripting:initiation_au_shell]] .
837 Mot inconnu : scripting => Aux structures décrites ci-dessus, il est nécessaire, pour réaliser des scripts poussés, de connaître les commandes shell les plus usitées.\\ Vous en trouverez une présentation sur cette autre page du wiki : [[projets:ecole:scripting:initiation_au_shell]] .
837 Il manque un espace. => Aux structures décrites ci-dessus, il est nécessaire, pour réaliser des scripts poussés, de connaître les commandes shell les plus usitées.\\ Vous en trouverez une présentation sur cette autre page du wiki : [[projets:ecole:scripting:initiation_au_shell]] .

839 Il manque un espace insécable. => La programmation de script shell étant ouverte à tous, cela permet de bénéficier de nombreux scripts pour des applications très variées ; cependant, **la plupart sont proposés sans aucune garantie**.\\ 
839 Espace(s) en fin de ligne à supprimer. => La programmation de script shell étant ouverte à tous, cela permet de bénéficier de nombreux scripts pour des applications très variées ; cependant, **la plupart sont proposés sans aucune garantie**.\\ 

842 Mot inconnu : topic => Une fois vos armes faites, proposez vos contributions sur le topic du forum [[http://forum.ubuntu-fr.org/viewtopic.php?id=204074|[VOS SCRIPTS UTILES]]] et rajoutez un lien dans la page du wiki ci-dessus.

846 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * Des vérifications approfondies doivent être effectuées sur TOUTES les commandes utilisées.

847 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * Des commentaires détaillés doivent apparaître lors de chaque étape. De même, chaque étape doit être suivie d'un "echo <voici ce que je fais>" (particulièrement utile notamment lors du débogage).
847 Guillemets typographiques ouvrants. =>   * Des commentaires détaillés doivent apparaître lors de chaque étape. De même, chaque étape doit être suivie d'un "echo <voici ce que je fais>" (particulièrement utile notamment lors du débogage).
847 Mot inconnu : echo =>   * Des commentaires détaillés doivent apparaître lors de chaque étape. De même, chaque étape doit être suivie d'un "echo <voici ce que je fais>" (particulièrement utile notamment lors du débogage).

848 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * Lors d'une mise à jour, un fil de discussion doit être précisé pour tracer les bugs éventuels.

849 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * Avertir les utilisateurs des dégâts que peuvent causer les commandes utilisées. (Ces deux dernières remarques ne concernent bien sûr que les scripts que l'on souhaite diffuser.)

850 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * Commencer par : <code bash>#!/bin/bash
850 Il manque un espace insécable. =>   * Commencer par : <code bash>#!/bin/bash

852 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * Créer des fonctions pour des actions précises :<code bash>nom_de_la_fonction()
852 Il manque un espace insécable. =>   * Créer des fonctions pour des actions précises :<code bash>nom_de_la_fonction()
852 Mot inconnu : nom_de_la_fonction =>   * Créer des fonctions pour des actions précises :<code bash>nom_de_la_fonction()

854 Typographie : points de suspension. Utilisez le caractère dédié. => ...

857 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * Utiliser des chemins absolus pour les dossiers et des chemins relatifs pour les noms de fichiers : <code bash>$CHEMIN_DU_DOSSIER/$NOM_DU_FICHIER</code>
857 Il manque un espace insécable. =>   * Utiliser des chemins absolus pour les dossiers et des chemins relatifs pour les noms de fichiers : <code bash>$CHEMIN_DU_DOSSIER/$NOM_DU_FICHIER</code>
857 Mot inconnu : CHEMIN_DU_DOSSIER =>   * Utiliser des chemins absolus pour les dossiers et des chemins relatifs pour les noms de fichiers : <code bash>$CHEMIN_DU_DOSSIER/$NOM_DU_FICHIER</code>
857 Mot inconnu : NOM_DU_FICHIER =>   * Utiliser des chemins absolus pour les dossiers et des chemins relatifs pour les noms de fichiers : <code bash>$CHEMIN_DU_DOSSIER/$NOM_DU_FICHIER</code>

858 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * Utiliser les entrées de commandes pour les fonctions :<code bash>nom_de_la_fonction $1 $2 $3 ....</code>
858 Il manque un espace insécable. =>   * Utiliser les entrées de commandes pour les fonctions :<code bash>nom_de_la_fonction $1 $2 $3 ....</code>
858 Mot inconnu : nom_de_la_fonction =>   * Utiliser les entrées de commandes pour les fonctions :<code bash>nom_de_la_fonction $1 $2 $3 ....</code>
858 Typographie : points de suspension. Utilisez le caractère dédié. =>   * Utiliser les entrées de commandes pour les fonctions :<code bash>nom_de_la_fonction $1 $2 $3 ....</code>

859 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * Si votre script doit s'arrêter à cause d'une erreur, d'une variable qui ne correspond pas à vos attentes utiliser des numéros exit différents : <code bash>exit 100;
859 Il manque un espace insécable. =>   * Si votre script doit s'arrêter à cause d'une erreur, d'une variable qui ne correspond pas à vos attentes utiliser des numéros exit différents : <code bash>exit 100;
859 Il manque un espace insécable. =>   * Si votre script doit s'arrêter à cause d'une erreur, d'une variable qui ne correspond pas à vos attentes utiliser des numéros exit différents : <code bash>exit 100;

860 Il manque un espace insécable. => exit 101;

861 Il manque un espace insécable. => exit 102;

862 Typographie : points de suspension. Utilisez le caractère dédié. => ....</code>Ça permettra d'identifier d'où vient l'erreur.

863 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * Utiliser le tableau ${PIPESTATUS[@]} pour récupérer les états des autres commandes.
863 Mot inconnu : PIPESTATUS =>   * Utiliser le tableau ${PIPESTATUS[@]} pour récupérer les états des autres commandes.

864 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * On peut écrire une fonction d'erreur du type : <code bash>
864 Il manque un espace insécable. =>   * On peut écrire une fonction d'erreur du type : <code bash>

867 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     tab=( ${PIPESTATUS[@]} )
867 Mot inconnu : tab =>     tab=( ${PIPESTATUS[@]} )
867 Pas d’espace après ce signe. =>     tab=( ${PIPESTATUS[@]} )
867 Mot inconnu : PIPESTATUS =>     tab=( ${PIPESTATUS[@]} )
867 Pas d’espace avant ce signe. =>     tab=( ${PIPESTATUS[@]} )

869 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     for (( i=0; i < ${#tab[@]}; i++ )); do ((i+=i)); done
869 Pas d’espace après ce signe. =>     for (( i=0; i < ${#tab[@]}; i++ )); do ((i+=i)); done
869 Il manque un espace insécable. =>     for (( i=0; i < ${#tab[@]}; i++ )); do ((i+=i)); done
869 Pas d’espace avant ce signe. =>     for (( i=0; i < ${#tab[@]}; i++ )); do ((i+=i)); done
869 Mot inconnu : done =>     for (( i=0; i < ${#tab[@]}; i++ )); do ((i+=i)); done

871 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     if ((i > 0)); then
871 Mot inconnu : then =>     if ((i > 0)); then

872 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>         zenity --error --title="Une erreur est survenue" --text="Une erreur est survenue "
872 Mot inconnu : zenity =>         zenity --error --title="Une erreur est survenue" --text="Une erreur est survenue "
872 Mot inconnu : error =>         zenity --error --title="Une erreur est survenue" --text="Une erreur est survenue "
872 Mot inconnu : title =>         zenity --error --title="Une erreur est survenue" --text="Une erreur est survenue "
872 Guillemets typographiques ouvrants. =>         zenity --error --title="Une erreur est survenue" --text="Une erreur est survenue "
872 Guillemets typographiques fermants. =>         zenity --error --title="Une erreur est survenue" --text="Une erreur est survenue "
872 Mot inconnu : text =>         zenity --error --title="Une erreur est survenue" --text="Une erreur est survenue "
872 Guillemets typographiques ouvrants. =>         zenity --error --title="Une erreur est survenue" --text="Une erreur est survenue "
872 Guillemets fermants. =>         zenity --error --title="Une erreur est survenue" --text="Une erreur est survenue "

873 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>         exit 100

874 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>     fi

877 Il manque un espace insécable. => <note tip>Astuce : le plus important dans tout programme est l'algorithme utilisé.</note>

878 Il manque un espace insécable. => Exemple :

879 Il manque un espace insécable. => supposons que vous ayez une base de données, avec 3 catégories d'enregistrements possibles :

882 Il manque un espace insécable. => Deux possibilités s'offrent à vous :

883 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * calculer le nombre d'éléphants bleus + éléphants blancs

885 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * calculer le nombre total d'éléphants - nombre d'éléphants roses
885 Tiret d’incise : un tiret demi-cadratin [1] ou cadratin [2] est requis. (Ou éventuellement le signe “moins” [3], s’il s’agit d’une soustraction.) =>   * calculer le nombre total d'éléphants - nombre d'éléphants roses

887 Il manque un espace insécable. => Quel algorithme choisissez-vous ?

889 Il manque un espace insécable. => Résultat : le premier car dans le deuxième il faut d'abord calculer le nombre total d'éléphants, donc un calcul en plus :-P .

893 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * (fr) http://marcg.developpez.com/ksh/ : Pour ceux qui souhaitent aller plus loin dans la conception de script shell.
893 Il manque un espace insécable. =>   * (fr) http://marcg.developpez.com/ksh/ : Pour ceux qui souhaitent aller plus loin dans la conception de script shell.

894 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * (fr) [[http://abs.traduc.org/abs-fr/|Guide avancé d'écriture des scripts Bash]] : Un très bon tutoriel concernant la réalisation du script shell. C'est l'un des plus complets et les mieux détaillés disponibles en français. Il contient également [[http://abs.traduc.org/abs-5.3-fr/apa.html|des exemples de script complets]], une [[http://abs.traduc.org/abs-5.3-fr/apb.html|carte de référence]] (variables, tests...). Ce site est un site qui vaut réellement le détour pour tous ceux qui cherchent à créer des scripts complets en utilisant au mieux les performances du shell.
894 Mot inconnu : Bash =>   * (fr) [[http://abs.traduc.org/abs-fr/|Guide avancé d'écriture des scripts Bash]] : Un très bon tutoriel concernant la réalisation du script shell. C'est l'un des plus complets et les mieux détaillés disponibles en français. Il contient également [[http://abs.traduc.org/abs-5.3-fr/apa.html|des exemples de script complets]], une [[http://abs.traduc.org/abs-5.3-fr/apb.html|carte de référence]] (variables, tests...). Ce site est un site qui vaut réellement le détour pour tous ceux qui cherchent à créer des scripts complets en utilisant au mieux les performances du shell.
894 Il manque un espace insécable. =>   * (fr) [[http://abs.traduc.org/abs-fr/|Guide avancé d'écriture des scripts Bash]] : Un très bon tutoriel concernant la réalisation du script shell. C'est l'un des plus complets et les mieux détaillés disponibles en français. Il contient également [[http://abs.traduc.org/abs-5.3-fr/apa.html|des exemples de script complets]], une [[http://abs.traduc.org/abs-5.3-fr/apb.html|carte de référence]] (variables, tests...). Ce site est un site qui vaut réellement le détour pour tous ceux qui cherchent à créer des scripts complets en utilisant au mieux les performances du shell.
894 Typographie : points de suspension. Utilisez le caractère dédié. =>   * (fr) [[http://abs.traduc.org/abs-fr/|Guide avancé d'écriture des scripts Bash]] : Un très bon tutoriel concernant la réalisation du script shell. C'est l'un des plus complets et les mieux détaillés disponibles en français. Il contient également [[http://abs.traduc.org/abs-5.3-fr/apa.html|des exemples de script complets]], une [[http://abs.traduc.org/abs-5.3-fr/apb.html|carte de référence]] (variables, tests...). Ce site est un site qui vaut réellement le détour pour tous ceux qui cherchent à créer des scripts complets en utilisant au mieux les performances du shell.

895 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * (fr) https://openclassrooms.com/courses/reprenez-le-controle-a-l-aide-de-linux : Un tutoriel très complet pour linux qui comporte quelques parties sur la réalisation de scripts bash.
895 Il manque un espace insécable. =>   * (fr) https://openclassrooms.com/courses/reprenez-le-controle-a-l-aide-de-linux : Un tutoriel très complet pour linux qui comporte quelques parties sur la réalisation de scripts bash.
895 Mot inconnu : linux =>   * (fr) https://openclassrooms.com/courses/reprenez-le-controle-a-l-aide-de-linux : Un tutoriel très complet pour linux qui comporte quelques parties sur la réalisation de scripts bash.
895 Mot inconnu : bash =>   * (fr) https://openclassrooms.com/courses/reprenez-le-controle-a-l-aide-de-linux : Un tutoriel très complet pour linux qui comporte quelques parties sur la réalisation de scripts bash.

896 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * (en) [[http://www.ibm.com/developerworks/library/l-bash-parameters.html|Bash parameters and parameter expansions]]. En anglais mais contient de nombreux exemples concernant la gestion et l'analyse des paramètres.
896 Mot inconnu : Bash =>   * (en) [[http://www.ibm.com/developerworks/library/l-bash-parameters.html|Bash parameters and parameter expansions]]. En anglais mais contient de nombreux exemples concernant la gestion et l'analyse des paramètres.
896 Mot inconnu : parameters =>   * (en) [[http://www.ibm.com/developerworks/library/l-bash-parameters.html|Bash parameters and parameter expansions]]. En anglais mais contient de nombreux exemples concernant la gestion et l'analyse des paramètres.
896 Mot inconnu : and =>   * (en) [[http://www.ibm.com/developerworks/library/l-bash-parameters.html|Bash parameters and parameter expansions]]. En anglais mais contient de nombreux exemples concernant la gestion et l'analyse des paramètres.
896 Mot inconnu : parameter =>   * (en) [[http://www.ibm.com/developerworks/library/l-bash-parameters.html|Bash parameters and parameter expansions]]. En anglais mais contient de nombreux exemples concernant la gestion et l'analyse des paramètres.

897 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * (fr ) [[ftp://ftp-developpez.com/eric-sanchis/IntroProgBash.pdf|Introduction à Bash]]
897 Pas d’espace avant ce signe. =>   * (fr ) [[ftp://ftp-developpez.com/eric-sanchis/IntroProgBash.pdf|Introduction à Bash]]
897 Mot inconnu : ftp-developpez =>   * (fr ) [[ftp://ftp-developpez.com/eric-sanchis/IntroProgBash.pdf|Introduction à Bash]]
897 Mot inconnu : eric-sanchis =>   * (fr ) [[ftp://ftp-developpez.com/eric-sanchis/IntroProgBash.pdf|Introduction à Bash]]
897 Mot inconnu : IntroProgBash =>   * (fr ) [[ftp://ftp-developpez.com/eric-sanchis/IntroProgBash.pdf|Introduction à Bash]]
897 Mot inconnu : Bash =>   * (fr ) [[ftp://ftp-developpez.com/eric-sanchis/IntroProgBash.pdf|Introduction à Bash]]

898 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * (fr ) [[http://www.scotchlinux.tuxfamily.org/]] exemples de scripts bash, quelques trucs utiles ( fonctions, fonctions comme paramètres... ) 
898 Pas d’espace avant ce signe. =>   * (fr ) [[http://www.scotchlinux.tuxfamily.org/]] exemples de scripts bash, quelques trucs utiles ( fonctions, fonctions comme paramètres... ) 
898 Mot inconnu : bash =>   * (fr ) [[http://www.scotchlinux.tuxfamily.org/]] exemples de scripts bash, quelques trucs utiles ( fonctions, fonctions comme paramètres... ) 
898 Pas d’espace après ce signe. =>   * (fr ) [[http://www.scotchlinux.tuxfamily.org/]] exemples de scripts bash, quelques trucs utiles ( fonctions, fonctions comme paramètres... ) 
898 Typographie : points de suspension. Utilisez le caractère dédié. =>   * (fr ) [[http://www.scotchlinux.tuxfamily.org/]] exemples de scripts bash, quelques trucs utiles ( fonctions, fonctions comme paramètres... ) 
898 Pas d’espace avant ce signe. =>   * (fr ) [[http://www.scotchlinux.tuxfamily.org/]] exemples de scripts bash, quelques trucs utiles ( fonctions, fonctions comme paramètres... ) 
898 Espace(s) en fin de ligne à supprimer. =>   * (fr ) [[http://www.scotchlinux.tuxfamily.org/]] exemples de scripts bash, quelques trucs utiles ( fonctions, fonctions comme paramètres... ) 

899 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * (en) [[https://www.shellcheck.net/]] Permet de corriger la syntaxe du script (parenthèse oubliée, graphie incorrecte d'une commande, un "if" sans son "fi", un "while sans son "do" ou son "done", etc...).
899 Guillemets typographiques ouvrants. =>   * (en) [[https://www.shellcheck.net/]] Permet de corriger la syntaxe du script (parenthèse oubliée, graphie incorrecte d'une commande, un "if" sans son "fi", un "while sans son "do" ou son "done", etc...).
899 Guillemets typographiques fermants. =>   * (en) [[https://www.shellcheck.net/]] Permet de corriger la syntaxe du script (parenthèse oubliée, graphie incorrecte d'une commande, un "if" sans son "fi", un "while sans son "do" ou son "done", etc...).
899 Guillemets typographiques ouvrants. =>   * (en) [[https://www.shellcheck.net/]] Permet de corriger la syntaxe du script (parenthèse oubliée, graphie incorrecte d'une commande, un "if" sans son "fi", un "while sans son "do" ou son "done", etc...).
899 Guillemets typographiques fermants. =>   * (en) [[https://www.shellcheck.net/]] Permet de corriger la syntaxe du script (parenthèse oubliée, graphie incorrecte d'une commande, un "if" sans son "fi", un "while sans son "do" ou son "done", etc...).
899 Guillemets typographiques ouvrants. =>   * (en) [[https://www.shellcheck.net/]] Permet de corriger la syntaxe du script (parenthèse oubliée, graphie incorrecte d'une commande, un "if" sans son "fi", un "while sans son "do" ou son "done", etc...).
899 Mot inconnu : while =>   * (en) [[https://www.shellcheck.net/]] Permet de corriger la syntaxe du script (parenthèse oubliée, graphie incorrecte d'une commande, un "if" sans son "fi", un "while sans son "do" ou son "done", etc...).
899 Guillemets typographiques ouvrants. =>   * (en) [[https://www.shellcheck.net/]] Permet de corriger la syntaxe du script (parenthèse oubliée, graphie incorrecte d'une commande, un "if" sans son "fi", un "while sans son "do" ou son "done", etc...).
899 Guillemets typographiques fermants. =>   * (en) [[https://www.shellcheck.net/]] Permet de corriger la syntaxe du script (parenthèse oubliée, graphie incorrecte d'une commande, un "if" sans son "fi", un "while sans son "do" ou son "done", etc...).
899 Guillemets typographiques ouvrants. =>   * (en) [[https://www.shellcheck.net/]] Permet de corriger la syntaxe du script (parenthèse oubliée, graphie incorrecte d'une commande, un "if" sans son "fi", un "while sans son "do" ou son "done", etc...).
899 Mot inconnu : done =>   * (en) [[https://www.shellcheck.net/]] Permet de corriger la syntaxe du script (parenthèse oubliée, graphie incorrecte d'une commande, un "if" sans son "fi", un "while sans son "do" ou son "done", etc...).
899 Guillemets typographiques fermants. =>   * (en) [[https://www.shellcheck.net/]] Permet de corriger la syntaxe du script (parenthèse oubliée, graphie incorrecte d'une commande, un "if" sans son "fi", un "while sans son "do" ou son "done", etc...).
899 Un seul point après « etc. » =>   * (en) [[https://www.shellcheck.net/]] Permet de corriger la syntaxe du script (parenthèse oubliée, graphie incorrecte d'une commande, un "if" sans son "fi", un "while sans son "do" ou son "done", etc...).

903 Il manque un espace insécable. => //Contributeurs: [[:utilisateurs:Gapz]], [[:utilisateurs:Gloubiboulga]] ,[[:utilisateurs:sparky]] et [[:utilisateurs:deax_one]]//
903 Il manque un espace. => //Contributeurs: [[:utilisateurs:Gapz]], [[:utilisateurs:Gloubiboulga]] ,[[:utilisateurs:sparky]] et [[:utilisateurs:deax_one]]//
903 Il manque un espace. => //Contributeurs: [[:utilisateurs:Gapz]], [[:utilisateurs:Gloubiboulga]] ,[[:utilisateurs:sparky]] et [[:utilisateurs:deax_one]]//
903 Il manque un espace. => //Contributeurs: [[:utilisateurs:Gapz]], [[:utilisateurs:Gloubiboulga]] ,[[:utilisateurs:sparky]] et [[:utilisateurs:deax_one]]//
903 Il manque un espace. => //Contributeurs: [[:utilisateurs:Gapz]], [[:utilisateurs:Gloubiboulga]] ,[[:utilisateurs:sparky]] et [[:utilisateurs:deax_one]]//
