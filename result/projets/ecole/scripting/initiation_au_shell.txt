7 Mot inconnu : gapz => Ceci est un compte-rendu du cours donné par gapz et FiFouille sur le canal IRC #ubuntu-fr-classroom le 27 janvier 2007. Ce cours est orienté débutant et a pour but de donner de solides bases. Pour le suivre il suffit de savoir ouvrir un terminal.
7 Mot inconnu : FiFouille => Ceci est un compte-rendu du cours donné par gapz et FiFouille sur le canal IRC #ubuntu-fr-classroom le 27 janvier 2007. Ce cours est orienté débutant et a pour but de donner de solides bases. Pour le suivre il suffit de savoir ouvrir un terminal.
7 Mot inconnu : IRC => Ceci est un compte-rendu du cours donné par gapz et FiFouille sur le canal IRC #ubuntu-fr-classroom le 27 janvier 2007. Ce cours est orienté débutant et a pour but de donner de solides bases. Pour le suivre il suffit de savoir ouvrir un terminal.

17 Mot inconnu : icons => {{icons:iconnote.png  }}
17 Il manque un espace. => {{icons:iconnote.png  }}
17 Mot inconnu : iconnote => {{icons:iconnote.png  }}
17 Mot inconnu : png => {{icons:iconnote.png  }}
17 Espace(s) surnuméraire(s) à supprimer. => {{icons:iconnote.png  }}

18 Mot inconnu : sh => >Quand on parle du Shell, on fait souvent référence à l'interpréteur de commande, autrefois nommé sh (contraction de shell), et qui a ensuite donné naissance à tout un éventail d'interpréteurs tels que bash, csh, zsh, ksh... qu'il ne faut pas confondre avec un émulateur de terminal comme xterm, eterm, gnome-terminal qui est un outil graphique qui permet d'avoir accès au shell.
18 Mot inconnu : bash => >Quand on parle du Shell, on fait souvent référence à l'interpréteur de commande, autrefois nommé sh (contraction de shell), et qui a ensuite donné naissance à tout un éventail d'interpréteurs tels que bash, csh, zsh, ksh... qu'il ne faut pas confondre avec un émulateur de terminal comme xterm, eterm, gnome-terminal qui est un outil graphique qui permet d'avoir accès au shell.
18 Mot inconnu : csh => >Quand on parle du Shell, on fait souvent référence à l'interpréteur de commande, autrefois nommé sh (contraction de shell), et qui a ensuite donné naissance à tout un éventail d'interpréteurs tels que bash, csh, zsh, ksh... qu'il ne faut pas confondre avec un émulateur de terminal comme xterm, eterm, gnome-terminal qui est un outil graphique qui permet d'avoir accès au shell.
18 Mot inconnu : zsh => >Quand on parle du Shell, on fait souvent référence à l'interpréteur de commande, autrefois nommé sh (contraction de shell), et qui a ensuite donné naissance à tout un éventail d'interpréteurs tels que bash, csh, zsh, ksh... qu'il ne faut pas confondre avec un émulateur de terminal comme xterm, eterm, gnome-terminal qui est un outil graphique qui permet d'avoir accès au shell.
18 Mot inconnu : ksh => >Quand on parle du Shell, on fait souvent référence à l'interpréteur de commande, autrefois nommé sh (contraction de shell), et qui a ensuite donné naissance à tout un éventail d'interpréteurs tels que bash, csh, zsh, ksh... qu'il ne faut pas confondre avec un émulateur de terminal comme xterm, eterm, gnome-terminal qui est un outil graphique qui permet d'avoir accès au shell.
18 Typographie : points de suspension. Utilisez le caractère dédié. => >Quand on parle du Shell, on fait souvent référence à l'interpréteur de commande, autrefois nommé sh (contraction de shell), et qui a ensuite donné naissance à tout un éventail d'interpréteurs tels que bash, csh, zsh, ksh... qu'il ne faut pas confondre avec un émulateur de terminal comme xterm, eterm, gnome-terminal qui est un outil graphique qui permet d'avoir accès au shell.
18 Mot inconnu : xterm => >Quand on parle du Shell, on fait souvent référence à l'interpréteur de commande, autrefois nommé sh (contraction de shell), et qui a ensuite donné naissance à tout un éventail d'interpréteurs tels que bash, csh, zsh, ksh... qu'il ne faut pas confondre avec un émulateur de terminal comme xterm, eterm, gnome-terminal qui est un outil graphique qui permet d'avoir accès au shell.
18 Mot inconnu : eterm => >Quand on parle du Shell, on fait souvent référence à l'interpréteur de commande, autrefois nommé sh (contraction de shell), et qui a ensuite donné naissance à tout un éventail d'interpréteurs tels que bash, csh, zsh, ksh... qu'il ne faut pas confondre avec un émulateur de terminal comme xterm, eterm, gnome-terminal qui est un outil graphique qui permet d'avoir accès au shell.

20 Mot inconnu : Fx => En réalité, les vrais terminaux sont accessibles via la combinaison de touche CTRL + ALT + Fx (où x est un chiffre entre 1 et 6) lorsque vous êtes dans un environnement graphique, le 7 correspondant à cette session. Si vous êtes dans un vrai Terminal, il faut théoriquement utiliser ALT + Fx. À noter également qu'un émulateur permet d'afficher une sorte de TTY (TéléTYpe) dans la session graphique.
20 Mot inconnu : Fx => En réalité, les vrais terminaux sont accessibles via la combinaison de touche CTRL + ALT + Fx (où x est un chiffre entre 1 et 6) lorsque vous êtes dans un environnement graphique, le 7 correspondant à cette session. Si vous êtes dans un vrai Terminal, il faut théoriquement utiliser ALT + Fx. À noter également qu'un émulateur permet d'afficher une sorte de TTY (TéléTYpe) dans la session graphique.
20 Mot inconnu : TTY => En réalité, les vrais terminaux sont accessibles via la combinaison de touche CTRL + ALT + Fx (où x est un chiffre entre 1 et 6) lorsque vous êtes dans un environnement graphique, le 7 correspondant à cette session. Si vous êtes dans un vrai Terminal, il faut théoriquement utiliser ALT + Fx. À noter également qu'un émulateur permet d'afficher une sorte de TTY (TéléTYpe) dans la session graphique.
20 Mot inconnu : TéléTYpe => En réalité, les vrais terminaux sont accessibles via la combinaison de touche CTRL + ALT + Fx (où x est un chiffre entre 1 et 6) lorsque vous êtes dans un environnement graphique, le 7 correspondant à cette session. Si vous êtes dans un vrai Terminal, il faut théoriquement utiliser ALT + Fx. À noter également qu'un émulateur permet d'afficher une sorte de TTY (TéléTYpe) dans la session graphique.

22 Il manque un trait d’union. => Le Shell vous donne accès à toute une gamme d'outils très performants qui permettent d'effectuer des tâches impossibles jusque là mais aussi de les automatiser, et cela d'une manière assez simple. De nombreuses interfaces graphiques sont certes disponibles, mais le shell reste très léger, rapide, accessible, efficace...
22 Typographie : points de suspension. Utilisez le caractère dédié. => Le Shell vous donne accès à toute une gamme d'outils très performants qui permettent d'effectuer des tâches impossibles jusque là mais aussi de les automatiser, et cela d'une manière assez simple. De nombreuses interfaces graphiques sont certes disponibles, mais le shell reste très léger, rapide, accessible, efficace...

28 Mot inconnu : stdin => En général, un programme dispose d'une **entrée standard**, d'une **sortie standard**, et d'une **sortie d'erreur standard**, aussi connues sous le nom de **stdin**, **stdout**, **stderr**. Globalement stdin représente le clavier, stdout l'écran et stderr la sortie des messages d'erreur vers l'écran : ceci peut bien entendu varier suivant les programmes, il ne s'agit que d'un exemple.
28 Mot inconnu : stdout => En général, un programme dispose d'une **entrée standard**, d'une **sortie standard**, et d'une **sortie d'erreur standard**, aussi connues sous le nom de **stdin**, **stdout**, **stderr**. Globalement stdin représente le clavier, stdout l'écran et stderr la sortie des messages d'erreur vers l'écran : ceci peut bien entendu varier suivant les programmes, il ne s'agit que d'un exemple.
28 Mot inconnu : stderr => En général, un programme dispose d'une **entrée standard**, d'une **sortie standard**, et d'une **sortie d'erreur standard**, aussi connues sous le nom de **stdin**, **stdout**, **stderr**. Globalement stdin représente le clavier, stdout l'écran et stderr la sortie des messages d'erreur vers l'écran : ceci peut bien entendu varier suivant les programmes, il ne s'agit que d'un exemple.
28 Mot inconnu : stdin => En général, un programme dispose d'une **entrée standard**, d'une **sortie standard**, et d'une **sortie d'erreur standard**, aussi connues sous le nom de **stdin**, **stdout**, **stderr**. Globalement stdin représente le clavier, stdout l'écran et stderr la sortie des messages d'erreur vers l'écran : ceci peut bien entendu varier suivant les programmes, il ne s'agit que d'un exemple.
28 Mot inconnu : stdout => En général, un programme dispose d'une **entrée standard**, d'une **sortie standard**, et d'une **sortie d'erreur standard**, aussi connues sous le nom de **stdin**, **stdout**, **stderr**. Globalement stdin représente le clavier, stdout l'écran et stderr la sortie des messages d'erreur vers l'écran : ceci peut bien entendu varier suivant les programmes, il ne s'agit que d'un exemple.
28 Mot inconnu : stderr => En général, un programme dispose d'une **entrée standard**, d'une **sortie standard**, et d'une **sortie d'erreur standard**, aussi connues sous le nom de **stdin**, **stdout**, **stderr**. Globalement stdin représente le clavier, stdout l'écran et stderr la sortie des messages d'erreur vers l'écran : ceci peut bien entendu varier suivant les programmes, il ne s'agit que d'un exemple.
28 Il manque un espace insécable. => En général, un programme dispose d'une **entrée standard**, d'une **sortie standard**, et d'une **sortie d'erreur standard**, aussi connues sous le nom de **stdin**, **stdout**, **stderr**. Globalement stdin représente le clavier, stdout l'écran et stderr la sortie des messages d'erreur vers l'écran : ceci peut bien entendu varier suivant les programmes, il ne s'agit que d'un exemple.

30 Il manque un espace insécable. => À chaque entrée/sortie est associée un numéro appelé **descripteur de fichier** comme vous pouvez le voir dans ce tableau récapitulatif :

32 Espace(s) surnuméraire(s) à supprimer. => ^ Entrées/Sorties             ^ Nom      ^ Numéro   ^  
32 Espace(s) surnuméraire(s) à supprimer. => ^ Entrées/Sorties             ^ Nom      ^ Numéro   ^  
32 Espace(s) surnuméraire(s) à supprimer. => ^ Entrées/Sorties             ^ Nom      ^ Numéro   ^  
32 Espace(s) en fin de ligne à supprimer. => ^ Entrées/Sorties             ^ Nom      ^ Numéro   ^  

33 Espace(s) surnuméraire(s) à supprimer. => | Entrée standard             |  stdin   |   0      |
33 Mot inconnu : stdin => | Entrée standard             |  stdin   |   0      |
33 Espace(s) surnuméraire(s) à supprimer. => | Entrée standard             |  stdin   |   0      |
33 Espace(s) surnuméraire(s) à supprimer. => | Entrée standard             |  stdin   |   0      |

34 Espace(s) surnuméraire(s) à supprimer. => | Sortie standard             |  stdout  |   1      |
34 Mot inconnu : stdout => | Sortie standard             |  stdout  |   1      |
34 Espace(s) surnuméraire(s) à supprimer. => | Sortie standard             |  stdout  |   1      |
34 Espace(s) surnuméraire(s) à supprimer. => | Sortie standard             |  stdout  |   1      |

35 Espace(s) surnuméraire(s) à supprimer. => | Sortie d'erreur standard    |  stderr  |   2      |
35 Mot inconnu : stderr => | Sortie d'erreur standard    |  stderr  |   2      |
35 Espace(s) surnuméraire(s) à supprimer. => | Sortie d'erreur standard    |  stderr  |   2      |
35 Espace(s) surnuméraire(s) à supprimer. => | Sortie d'erreur standard    |  stderr  |   2      |

39 Guillemets typographiques ouvrants. => Concrètement si vous exécutez "lfdfdfj" dans un terminal, "bash: lfdfdfj: command not found" sera retourné sur stderr. Par contre, si vous tapez ls, le résultat sera retourné sur stdout.
39 Mot inconnu : lfdfdfj => Concrètement si vous exécutez "lfdfdfj" dans un terminal, "bash: lfdfdfj: command not found" sera retourné sur stderr. Par contre, si vous tapez ls, le résultat sera retourné sur stdout.
39 Guillemets typographiques fermants. => Concrètement si vous exécutez "lfdfdfj" dans un terminal, "bash: lfdfdfj: command not found" sera retourné sur stderr. Par contre, si vous tapez ls, le résultat sera retourné sur stdout.
39 Guillemets typographiques ouvrants. => Concrètement si vous exécutez "lfdfdfj" dans un terminal, "bash: lfdfdfj: command not found" sera retourné sur stderr. Par contre, si vous tapez ls, le résultat sera retourné sur stdout.
39 Mot inconnu : bash => Concrètement si vous exécutez "lfdfdfj" dans un terminal, "bash: lfdfdfj: command not found" sera retourné sur stderr. Par contre, si vous tapez ls, le résultat sera retourné sur stdout.
39 Il manque un espace insécable. => Concrètement si vous exécutez "lfdfdfj" dans un terminal, "bash: lfdfdfj: command not found" sera retourné sur stderr. Par contre, si vous tapez ls, le résultat sera retourné sur stdout.
39 Mot inconnu : lfdfdfj => Concrètement si vous exécutez "lfdfdfj" dans un terminal, "bash: lfdfdfj: command not found" sera retourné sur stderr. Par contre, si vous tapez ls, le résultat sera retourné sur stdout.
39 Il manque un espace insécable. => Concrètement si vous exécutez "lfdfdfj" dans un terminal, "bash: lfdfdfj: command not found" sera retourné sur stderr. Par contre, si vous tapez ls, le résultat sera retourné sur stdout.
39 Mot inconnu : command => Concrètement si vous exécutez "lfdfdfj" dans un terminal, "bash: lfdfdfj: command not found" sera retourné sur stderr. Par contre, si vous tapez ls, le résultat sera retourné sur stdout.
39 Mot inconnu : not => Concrètement si vous exécutez "lfdfdfj" dans un terminal, "bash: lfdfdfj: command not found" sera retourné sur stderr. Par contre, si vous tapez ls, le résultat sera retourné sur stdout.
39 Mot inconnu : found => Concrètement si vous exécutez "lfdfdfj" dans un terminal, "bash: lfdfdfj: command not found" sera retourné sur stderr. Par contre, si vous tapez ls, le résultat sera retourné sur stdout.
39 Guillemets typographiques fermants. => Concrètement si vous exécutez "lfdfdfj" dans un terminal, "bash: lfdfdfj: command not found" sera retourné sur stderr. Par contre, si vous tapez ls, le résultat sera retourné sur stdout.
39 Mot inconnu : stderr => Concrètement si vous exécutez "lfdfdfj" dans un terminal, "bash: lfdfdfj: command not found" sera retourné sur stderr. Par contre, si vous tapez ls, le résultat sera retourné sur stdout.
39 Mot inconnu : ls => Concrètement si vous exécutez "lfdfdfj" dans un terminal, "bash: lfdfdfj: command not found" sera retourné sur stderr. Par contre, si vous tapez ls, le résultat sera retourné sur stdout.
39 Mot inconnu : stdout => Concrètement si vous exécutez "lfdfdfj" dans un terminal, "bash: lfdfdfj: command not found" sera retourné sur stderr. Par contre, si vous tapez ls, le résultat sera retourné sur stdout.

47 Mot inconnu : icons => {{icons:icone_danger.png  }}
47 Il manque un espace. => {{icons:icone_danger.png  }}
47 Mot inconnu : icone_danger => {{icons:icone_danger.png  }}
47 Mot inconnu : png => {{icons:icone_danger.png  }}
47 Espace(s) surnuméraire(s) à supprimer. => {{icons:icone_danger.png  }}

48 Mot inconnu : Dokuwiki => >Dokuwiki remplace automatiquement > >  et < <(sans l'espace entre les deux) par un guillemet comme ça >> et comme ça <<, donc jusqu'à ce qu'une solution soit trouvée (par vous peut être...) pensez à faire le changement mentalement.
48 Typographie : points de suspension. Utilisez le caractère dédié. => >Dokuwiki remplace automatiquement > >  et < <(sans l'espace entre les deux) par un guillemet comme ça >> et comme ça <<, donc jusqu'à ce qu'une solution soit trouvée (par vous peut être...) pensez à faire le changement mentalement.

54 Guillemets typographiques ouvrants. => Prenons un exemple, on connaît la commande "ls" qui donne la liste des fichiers d'un répertoire et on veut enregistrer le résultat dans un fichier. Pour cela on    va rediriger le résultat de la sortie standard dans le fichier test à l'aide de la commande suivante :
54 Mot inconnu : ls => Prenons un exemple, on connaît la commande "ls" qui donne la liste des fichiers d'un répertoire et on veut enregistrer le résultat dans un fichier. Pour cela on    va rediriger le résultat de la sortie standard dans le fichier test à l'aide de la commande suivante :
54 Guillemets typographiques fermants. => Prenons un exemple, on connaît la commande "ls" qui donne la liste des fichiers d'un répertoire et on veut enregistrer le résultat dans un fichier. Pour cela on    va rediriger le résultat de la sortie standard dans le fichier test à l'aide de la commande suivante :
54 Espace(s) surnuméraire(s) à supprimer. => Prenons un exemple, on connaît la commande "ls" qui donne la liste des fichiers d'un répertoire et on veut enregistrer le résultat dans un fichier. Pour cela on    va rediriger le résultat de la sortie standard dans le fichier test à l'aide de la commande suivante :
54 Il manque un espace insécable. => Prenons un exemple, on connaît la commande "ls" qui donne la liste des fichiers d'un répertoire et on veut enregistrer le résultat dans un fichier. Pour cela on    va rediriger le résultat de la sortie standard dans le fichier test à l'aide de la commande suivante :

56 Mot inconnu : ls => <code>ls > test</code>

58 Mot inconnu : stderr => De même si on veut enregistrer stderr de la commande "lfdfdfj", on utilise :
58 Guillemets typographiques ouvrants. => De même si on veut enregistrer stderr de la commande "lfdfdfj", on utilise :
58 Mot inconnu : lfdfdfj => De même si on veut enregistrer stderr de la commande "lfdfdfj", on utilise :
58 Guillemets typographiques fermants. => De même si on veut enregistrer stderr de la commande "lfdfdfj", on utilise :
58 Il manque un espace insécable. => De même si on veut enregistrer stderr de la commande "lfdfdfj", on utilise :

60 Mot inconnu : lfdfdfj => <code>lfdfdfj 2> test</code>

62 Mot inconnu : stdout => Dans le premier exemple, on peut constater que l'on ne précise pas le descripteur de fichier redirigé (1), en effet le descripteur de fichier redirigé par défaut est stdout.

66 Il manque un espace insécable. => Pour conserver le fichier original, vous pouvez utiliser ">>" qui n'écrasera pas le contenu du fichier s'il existe déjà. Par exemple :

68 Mot inconnu : ls => <code>ls >> test</code>

70 Il faut élider “si” et l’accoler au pronom. => Si test n'existe pas il sera créé, si il existe le résultat sera ajouté à son contenu (à la fin du fichier). De la même manière, vous pouvez rediriger stderr : 
70 Mot inconnu : stderr => Si test n'existe pas il sera créé, si il existe le résultat sera ajouté à son contenu (à la fin du fichier). De la même manière, vous pouvez rediriger stderr : 
70 Il manque un espace insécable. => Si test n'existe pas il sera créé, si il existe le résultat sera ajouté à son contenu (à la fin du fichier). De la même manière, vous pouvez rediriger stderr : 
70 Espace(s) en fin de ligne à supprimer. => Si test n'existe pas il sera créé, si il existe le résultat sera ajouté à son contenu (à la fin du fichier). De la même manière, vous pouvez rediriger stderr : 

72 Mot inconnu : lfdfdfj => <code>lfdfdfj 2>> test</code>

74 Guillemets typographiques ouvrants. => Mais il est également possible de rediriger une sortie vers une autre sortie, par exemple "2>&1" signifie "rediriger stderr vers ce que représente stdout". Ainsi 
74 Guillemets typographiques fermants. => Mais il est également possible de rediriger une sortie vers une autre sortie, par exemple "2>&1" signifie "rediriger stderr vers ce que représente stdout". Ainsi 
74 Guillemets typographiques ouvrants. => Mais il est également possible de rediriger une sortie vers une autre sortie, par exemple "2>&1" signifie "rediriger stderr vers ce que représente stdout". Ainsi 
74 Mot inconnu : stderr => Mais il est également possible de rediriger une sortie vers une autre sortie, par exemple "2>&1" signifie "rediriger stderr vers ce que représente stdout". Ainsi 
74 Mot inconnu : stdout => Mais il est également possible de rediriger une sortie vers une autre sortie, par exemple "2>&1" signifie "rediriger stderr vers ce que représente stdout". Ainsi 
74 Guillemets typographiques fermants. => Mais il est également possible de rediriger une sortie vers une autre sortie, par exemple "2>&1" signifie "rediriger stderr vers ce que représente stdout". Ainsi 
74 Espace(s) en fin de ligne à supprimer. => Mais il est également possible de rediriger une sortie vers une autre sortie, par exemple "2>&1" signifie "rediriger stderr vers ce que représente stdout". Ainsi 

76 Mot inconnu : ls => <code>ls > test 2>&1</code>

78 Majuscule en début de phrase, sauf éventuellement lors d’une énumération. => redirigera stdout et stderr dans le fichier test. Vous remarquerez que les redirections s'effectuent de droite à gauche : la sortie stderr 2 est tout d'abord redirigée vers la sortie stdout 1, puis la sortie standard de ls s'inscrit dans le fichier test.
78 Mot inconnu : stdout => redirigera stdout et stderr dans le fichier test. Vous remarquerez que les redirections s'effectuent de droite à gauche : la sortie stderr 2 est tout d'abord redirigée vers la sortie stdout 1, puis la sortie standard de ls s'inscrit dans le fichier test.
78 Mot inconnu : stderr => redirigera stdout et stderr dans le fichier test. Vous remarquerez que les redirections s'effectuent de droite à gauche : la sortie stderr 2 est tout d'abord redirigée vers la sortie stdout 1, puis la sortie standard de ls s'inscrit dans le fichier test.
78 Il manque un espace insécable. => redirigera stdout et stderr dans le fichier test. Vous remarquerez que les redirections s'effectuent de droite à gauche : la sortie stderr 2 est tout d'abord redirigée vers la sortie stdout 1, puis la sortie standard de ls s'inscrit dans le fichier test.
78 Mot inconnu : stderr => redirigera stdout et stderr dans le fichier test. Vous remarquerez que les redirections s'effectuent de droite à gauche : la sortie stderr 2 est tout d'abord redirigée vers la sortie stdout 1, puis la sortie standard de ls s'inscrit dans le fichier test.
78 Mot inconnu : stdout => redirigera stdout et stderr dans le fichier test. Vous remarquerez que les redirections s'effectuent de droite à gauche : la sortie stderr 2 est tout d'abord redirigée vers la sortie stdout 1, puis la sortie standard de ls s'inscrit dans le fichier test.
78 Mot inconnu : ls => redirigera stdout et stderr dans le fichier test. Vous remarquerez que les redirections s'effectuent de droite à gauche : la sortie stderr 2 est tout d'abord redirigée vers la sortie stdout 1, puis la sortie standard de ls s'inscrit dans le fichier test.

82 Mot inconnu : stdin => Pour rediriger vers l'entrée standard stdin, nous allons utiliser "<" et "<<". 
82 Espace(s) en fin de ligne à supprimer. => Pour rediriger vers l'entrée standard stdin, nous allons utiliser "<" et "<<". 

84 Guillemets typographiques ouvrants. => "wc" permet de compter le nombre de lignes (option -l) ou de mots (option -w), plus d'informations dans la page man de wc, en entrée. Pour compter le nombre de lignes d'un fichier on peut donc utiliser :
84 Mot inconnu : wc => "wc" permet de compter le nombre de lignes (option -l) ou de mots (option -w), plus d'informations dans la page man de wc, en entrée. Pour compter le nombre de lignes d'un fichier on peut donc utiliser :
84 Guillemets typographiques fermants. => "wc" permet de compter le nombre de lignes (option -l) ou de mots (option -w), plus d'informations dans la page man de wc, en entrée. Pour compter le nombre de lignes d'un fichier on peut donc utiliser :
84 Il manque un espace à côté du tiret. => "wc" permet de compter le nombre de lignes (option -l) ou de mots (option -w), plus d'informations dans la page man de wc, en entrée. Pour compter le nombre de lignes d'un fichier on peut donc utiliser :
84 Il manque un espace à côté du tiret. => "wc" permet de compter le nombre de lignes (option -l) ou de mots (option -w), plus d'informations dans la page man de wc, en entrée. Pour compter le nombre de lignes d'un fichier on peut donc utiliser :
84 Mot inconnu : wc => "wc" permet de compter le nombre de lignes (option -l) ou de mots (option -w), plus d'informations dans la page man de wc, en entrée. Pour compter le nombre de lignes d'un fichier on peut donc utiliser :
84 Il manque un espace insécable. => "wc" permet de compter le nombre de lignes (option -l) ou de mots (option -w), plus d'informations dans la page man de wc, en entrée. Pour compter le nombre de lignes d'un fichier on peut donc utiliser :

86 Mot inconnu : wc => <code>wc -l < fichier</code>
86 Il manque un espace à côté du tiret. => <code>wc -l < fichier</code>

88 Mot inconnu : wc => Cette commande donnera le même résultat car wc peut prendre un fichier comme paramètre :
88 Il manque un espace insécable. => Cette commande donnera le même résultat car wc peut prendre un fichier comme paramètre :

89 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>  

90 Mot inconnu : wc => <code>wc -l fichier</code>
90 Il manque un espace à côté du tiret. => <code>wc -l fichier</code>

92 Mot inconnu : stdin => "<<" permet lui aussi de rediriger stdin mais jusqu'à une chaîne de caractère que l'on précisera : littéralement on pourrait dire que << transmet notre entrée standard (clavier) au programme à sa gauche, et cela jusqu'à ce qu'il rencontre une ligne EOF ((End of File : Fin de fichier)).
92 Il manque un espace insécable. => "<<" permet lui aussi de rediriger stdin mais jusqu'à une chaîne de caractère que l'on précisera : littéralement on pourrait dire que << transmet notre entrée standard (clavier) au programme à sa gauche, et cela jusqu'à ce qu'il rencontre une ligne EOF ((End of File : Fin de fichier)).
92 Mot inconnu : EOF => "<<" permet lui aussi de rediriger stdin mais jusqu'à une chaîne de caractère que l'on précisera : littéralement on pourrait dire que << transmet notre entrée standard (clavier) au programme à sa gauche, et cela jusqu'à ce qu'il rencontre une ligne EOF ((End of File : Fin de fichier)).
92 Mot inconnu : End => "<<" permet lui aussi de rediriger stdin mais jusqu'à une chaîne de caractère que l'on précisera : littéralement on pourrait dire que << transmet notre entrée standard (clavier) au programme à sa gauche, et cela jusqu'à ce qu'il rencontre une ligne EOF ((End of File : Fin de fichier)).
92 Mot inconnu : of => "<<" permet lui aussi de rediriger stdin mais jusqu'à une chaîne de caractère que l'on précisera : littéralement on pourrait dire que << transmet notre entrée standard (clavier) au programme à sa gauche, et cela jusqu'à ce qu'il rencontre une ligne EOF ((End of File : Fin de fichier)).
92 Il manque un espace insécable. => "<<" permet lui aussi de rediriger stdin mais jusqu'à une chaîne de caractère que l'on précisera : littéralement on pourrait dire que << transmet notre entrée standard (clavier) au programme à sa gauche, et cela jusqu'à ce qu'il rencontre une ligne EOF ((End of File : Fin de fichier)).

94 Mot inconnu : EOF => Par exemple la commande suivante vous permettra de taper un texte, d'aller à la ligne autant de fois que vous voulez en appuyant sur Entrée, puis lorsque vous taperez EOF (pour End of File, fin du fichier) et entrée, elle comptera le nombre de lignes (celle de EOF non comprise) que vous avez entrées.
94 Mot inconnu : End => Par exemple la commande suivante vous permettra de taper un texte, d'aller à la ligne autant de fois que vous voulez en appuyant sur Entrée, puis lorsque vous taperez EOF (pour End of File, fin du fichier) et entrée, elle comptera le nombre de lignes (celle de EOF non comprise) que vous avez entrées.
94 Mot inconnu : of => Par exemple la commande suivante vous permettra de taper un texte, d'aller à la ligne autant de fois que vous voulez en appuyant sur Entrée, puis lorsque vous taperez EOF (pour End of File, fin du fichier) et entrée, elle comptera le nombre de lignes (celle de EOF non comprise) que vous avez entrées.
94 Mot inconnu : EOF => Par exemple la commande suivante vous permettra de taper un texte, d'aller à la ligne autant de fois que vous voulez en appuyant sur Entrée, puis lorsque vous taperez EOF (pour End of File, fin du fichier) et entrée, elle comptera le nombre de lignes (celle de EOF non comprise) que vous avez entrées.

96 Mot inconnu : wc => <code>wc -l << EOF</code>
96 Il manque un espace à côté du tiret. => <code>wc -l << EOF</code>
96 Mot inconnu : EOF => <code>wc -l << EOF</code>

98 Accord de genre erroné : « chaîne » est féminin. => Vous pouvez bien sur spécifier un chaîne différente de EOF comme FIN, END...
98 Accord de genre erroné : « un » est un déterminant masculin. => Vous pouvez bien sur spécifier un chaîne différente de EOF comme FIN, END...
98 Mot inconnu : EOF => Vous pouvez bien sur spécifier un chaîne différente de EOF comme FIN, END...
98 Mot inconnu : END => Vous pouvez bien sur spécifier un chaîne différente de EOF comme FIN, END...
98 Typographie : points de suspension. Utilisez le caractère dédié. => Vous pouvez bien sur spécifier un chaîne différente de EOF comme FIN, END...

100 Il manque un espace insécable. => En utilisant ">>" et "<<" nous pouvons facilement ajouter du texte dans un fichier de notre choix de la même manière qu'un éditeur de texte : 
100 Espace(s) en fin de ligne à supprimer. => En utilisant ">>" et "<<" nous pouvons facilement ajouter du texte dans un fichier de notre choix de la même manière qu'un éditeur de texte : 

102 Mot inconnu : cat => <code>cat >> fichier << EOF</code>
102 Mot inconnu : EOF => <code>cat >> fichier << EOF</code>

104 Mot inconnu : EOF => Le texte tapé sera ajouté au fichier jusqu'à ce que vous vous écriviez EOF et validiez par entrée.

107 Il manque un espace insécable. => Expliquons cette syntaxe très souvent rencontrée et reprise sans explication : <code>commande >/dev/null 2>&1</code>

108 Il manque un espace insécable. => Dans l'ordre, est exécuté :

110 Dialogues et énumérations : un tiret cadratin [1] ou demi-cadratin [2], suivi d’un espace insécable, est requis. => - commande (dont les stdout et stderr sont redirigées)
110 Mot inconnu : stdout => - commande (dont les stdout et stderr sont redirigées)
110 Mot inconnu : stderr => - commande (dont les stdout et stderr sont redirigées)

112 Dialogues et énumérations : un tiret cadratin [1] ou demi-cadratin [2], suivi d’un espace insécable, est requis. => - stdout vers /dev/null (le trou noir)
112 Mot inconnu : stdout => - stdout vers /dev/null (le trou noir)

114 Dialogues et énumérations : un tiret cadratin [1] ou demi-cadratin [2], suivi d’un espace insécable, est requis. => - stderr vers stdout ... donc vers /dev/null
114 Mot inconnu : stderr => - stderr vers stdout ... donc vers /dev/null
114 Mot inconnu : stdout => - stderr vers stdout ... donc vers /dev/null
114 Typographie : points de suspension. Utilisez le caractère dédié. => - stderr vers stdout ... donc vers /dev/null

118 Il manque un espace insécable. => C'est équivalent à : <code>commande > /dev/null 2 > /dev/null</code>

121 Mot inconnu : icons => {{icons:iconnote.png  }}
121 Il manque un espace. => {{icons:iconnote.png  }}
121 Mot inconnu : iconnote => {{icons:iconnote.png  }}
121 Mot inconnu : png => {{icons:iconnote.png  }}
121 Espace(s) surnuméraire(s) à supprimer. => {{icons:iconnote.png  }}

122 Mot inconnu : null => >Même si cela ne traite pas directement des redirections, il est important de connaitre un fichier spécial nommé **null**. Il permet de rediriger un descripteur de fichier vers un fichier qui supprimera toutes les données qui lui seront ajoutées. Il porte le nom d'**absorbeur de données**. Si par exemple vous ne voulez pas voir le résultat d'une commande, il vous suffit de rediriger stdout vers /dev/null : "ls >/dev/null". Pour plus d'information sur le fichier null voir la page man de null.
122 Mot inconnu : stdout => >Même si cela ne traite pas directement des redirections, il est important de connaitre un fichier spécial nommé **null**. Il permet de rediriger un descripteur de fichier vers un fichier qui supprimera toutes les données qui lui seront ajoutées. Il porte le nom d'**absorbeur de données**. Si par exemple vous ne voulez pas voir le résultat d'une commande, il vous suffit de rediriger stdout vers /dev/null : "ls >/dev/null". Pour plus d'information sur le fichier null voir la page man de null.
122 Il manque un espace insécable. => >Même si cela ne traite pas directement des redirections, il est important de connaitre un fichier spécial nommé **null**. Il permet de rediriger un descripteur de fichier vers un fichier qui supprimera toutes les données qui lui seront ajoutées. Il porte le nom d'**absorbeur de données**. Si par exemple vous ne voulez pas voir le résultat d'une commande, il vous suffit de rediriger stdout vers /dev/null : "ls >/dev/null". Pour plus d'information sur le fichier null voir la page man de null.
122 Guillemets typographiques ouvrants. => >Même si cela ne traite pas directement des redirections, il est important de connaitre un fichier spécial nommé **null**. Il permet de rediriger un descripteur de fichier vers un fichier qui supprimera toutes les données qui lui seront ajoutées. Il porte le nom d'**absorbeur de données**. Si par exemple vous ne voulez pas voir le résultat d'une commande, il vous suffit de rediriger stdout vers /dev/null : "ls >/dev/null". Pour plus d'information sur le fichier null voir la page man de null.
122 Mot inconnu : ls => >Même si cela ne traite pas directement des redirections, il est important de connaitre un fichier spécial nommé **null**. Il permet de rediriger un descripteur de fichier vers un fichier qui supprimera toutes les données qui lui seront ajoutées. Il porte le nom d'**absorbeur de données**. Si par exemple vous ne voulez pas voir le résultat d'une commande, il vous suffit de rediriger stdout vers /dev/null : "ls >/dev/null". Pour plus d'information sur le fichier null voir la page man de null.
122 Mot inconnu : null => >Même si cela ne traite pas directement des redirections, il est important de connaitre un fichier spécial nommé **null**. Il permet de rediriger un descripteur de fichier vers un fichier qui supprimera toutes les données qui lui seront ajoutées. Il porte le nom d'**absorbeur de données**. Si par exemple vous ne voulez pas voir le résultat d'une commande, il vous suffit de rediriger stdout vers /dev/null : "ls >/dev/null". Pour plus d'information sur le fichier null voir la page man de null.
122 Mot inconnu : null => >Même si cela ne traite pas directement des redirections, il est important de connaitre un fichier spécial nommé **null**. Il permet de rediriger un descripteur de fichier vers un fichier qui supprimera toutes les données qui lui seront ajoutées. Il porte le nom d'**absorbeur de données**. Si par exemple vous ne voulez pas voir le résultat d'une commande, il vous suffit de rediriger stdout vers /dev/null : "ls >/dev/null". Pour plus d'information sur le fichier null voir la page man de null.

128 Il manque un espace insécable. => Si vous avez besoin de plus d'informations sur une commande n'hésitez pas à consulter son manuel via la commande :

130 Mot inconnu : nom_du_programme => <code>man nom_du_programme</code>

132 Mot inconnu : fondadamentales => Pour cette partie, consulter http://doc.ubuntu-fr.org/console/commandes_de_base pour les commandes fondadamentales : cp, mv, ls, cd, rm, chmod, chown et find.
132 Il manque un espace insécable. => Pour cette partie, consulter http://doc.ubuntu-fr.org/console/commandes_de_base pour les commandes fondadamentales : cp, mv, ls, cd, rm, chmod, chown et find.
132 Mot inconnu : cp => Pour cette partie, consulter http://doc.ubuntu-fr.org/console/commandes_de_base pour les commandes fondadamentales : cp, mv, ls, cd, rm, chmod, chown et find.
132 Mot inconnu : mv => Pour cette partie, consulter http://doc.ubuntu-fr.org/console/commandes_de_base pour les commandes fondadamentales : cp, mv, ls, cd, rm, chmod, chown et find.
132 Mot inconnu : ls => Pour cette partie, consulter http://doc.ubuntu-fr.org/console/commandes_de_base pour les commandes fondadamentales : cp, mv, ls, cd, rm, chmod, chown et find.
132 Mot inconnu : rm => Pour cette partie, consulter http://doc.ubuntu-fr.org/console/commandes_de_base pour les commandes fondadamentales : cp, mv, ls, cd, rm, chmod, chown et find.
132 Mot inconnu : chmod => Pour cette partie, consulter http://doc.ubuntu-fr.org/console/commandes_de_base pour les commandes fondadamentales : cp, mv, ls, cd, rm, chmod, chown et find.
132 Mot inconnu : chown => Pour cette partie, consulter http://doc.ubuntu-fr.org/console/commandes_de_base pour les commandes fondadamentales : cp, mv, ls, cd, rm, chmod, chown et find.
132 Mot inconnu : find => Pour cette partie, consulter http://doc.ubuntu-fr.org/console/commandes_de_base pour les commandes fondadamentales : cp, mv, ls, cd, rm, chmod, chown et find.

134 Mot inconnu : Cut => ==== Cut ====

136 Mot inconnu : cut => Pour présenter l'outil **cut** nous allons par exemple considérer que nous voulons obtenir le premier mot (correspondant au nom de l'utilisateur) du fichier /etc/passwd.

138 Mot inconnu : cut => Avec cut, vous pouvez supprimer une partie de chaque ligne d'un fichier, soit en indiquant un séparateur (avec l'option -d), soit en indiquant la position (via -c). 
138 Il manque un espace à côté du tiret. => Avec cut, vous pouvez supprimer une partie de chaque ligne d'un fichier, soit en indiquant un séparateur (avec l'option -d), soit en indiquant la position (via -c). 
138 Il manque un espace à côté du tiret. => Avec cut, vous pouvez supprimer une partie de chaque ligne d'un fichier, soit en indiquant un séparateur (avec l'option -d), soit en indiquant la position (via -c). 
138 Espace(s) en fin de ligne à supprimer. => Avec cut, vous pouvez supprimer une partie de chaque ligne d'un fichier, soit en indiquant un séparateur (avec l'option -d), soit en indiquant la position (via -c). 

140 Il manque un espace insécable. => Voyons tout de suite un exemple : 
140 Espace(s) en fin de ligne à supprimer. => Voyons tout de suite un exemple : 

142 Mot inconnu : cut => <code>cut -d: -f1 /etc/passwd</code>
142 Il manque un espace à côté du tiret. => <code>cut -d: -f1 /etc/passwd</code>
142 Il manque un espace insécable. => <code>cut -d: -f1 /etc/passwd</code>
142 Mot inconnu : f1 => <code>cut -d: -f1 /etc/passwd</code>

144 Mot inconnu : f1 => L'option "-d:" indique que le **séparateur** sera ":", et "-f1" indique que l'on veut récupérer seulement la **première partie**. 
144 Guillemets typographiques fermants. => L'option "-d:" indique que le **séparateur** sera ":", et "-f1" indique que l'on veut récupérer seulement la **première partie**. 
144 Espace(s) en fin de ligne à supprimer. => L'option "-d:" indique que le **séparateur** sera ":", et "-f1" indique que l'on veut récupérer seulement la **première partie**. 

146 Mot inconnu : icons => {{:icons:icontip.png  }}
146 Il manque un espace. => {{:icons:icontip.png  }}
146 Mot inconnu : icontip => {{:icons:icontip.png  }}
146 Mot inconnu : png => {{:icons:icontip.png  }}
146 Espace(s) surnuméraire(s) à supprimer. => {{:icons:icontip.png  }}

147 Il manque un espace à côté du tiret. => >Pour utiliser l'espace comme caractère de séparation, utilisez l'option -d" ".
147 Guillemets typographiques fermants. => >Pour utiliser l'espace comme caractère de séparation, utilisez l'option -d" ".
147 Guillemets fermants. => >Pour utiliser l'espace comme caractère de séparation, utilisez l'option -d" ".

149 Il manque un espace insécable. => On peut aussi récupérer plusieurs parties en une seule fois en les séparant par des virgules, ici les parties 1 et 5 :

151 Mot inconnu : cut => <code>cut -d" " -f1,5 un_fichier</code>
151 Il manque un espace à côté du tiret. => <code>cut -d" " -f1,5 un_fichier</code>
151 Guillemets typographiques fermants. => <code>cut -d" " -f1,5 un_fichier</code>
151 Guillemets isolés. => <code>cut -d" " -f1,5 un_fichier</code>
151 Mot inconnu : f1 => <code>cut -d" " -f1,5 un_fichier</code>
151 Il manque un espace. => <code>cut -d" " -f1,5 un_fichier</code>
151 Mot inconnu : un_fichier => <code>cut -d" " -f1,5 un_fichier</code>

153 Il manque un espace insécable. => Maintenant si l'on travaille en fonction de la position : 
153 Espace(s) en fin de ligne à supprimer. => Maintenant si l'on travaille en fonction de la position : 

155 Mot inconnu : cut => <code>cut -c 1-10 /etc/passwd</code>
155 Il manque un espace à côté du tiret. => <code>cut -c 1-10 /etc/passwd</code>

157 Mot inconnu : passwd => Vous l'aurez compris cette commande récupère les caractères de 1 à 10 du fichier passwd.

159 Mot inconnu : Head => ==== Head et Tail ====
159 Mot inconnu : Tail => ==== Head et Tail ====

161 Erreur de numérisation ? Virgules au lieu de points ? => Il est souvent utile de ne voir que le début ou que la fin d'un texte, du résultat d'une commande,... Il existe pour cela deux outils : **head** (tête en français) et **tail** (queue en français).
161 Typographie : points de suspension. Utilisez le caractère dédié. => Il est souvent utile de ne voir que le début ou que la fin d'un texte, du résultat d'une commande,... Il existe pour cela deux outils : **head** (tête en français) et **tail** (queue en français).
161 Il manque un espace insécable. => Il est souvent utile de ne voir que le début ou que la fin d'un texte, du résultat d'une commande,... Il existe pour cela deux outils : **head** (tête en français) et **tail** (queue en français).
161 Mot inconnu : head => Il est souvent utile de ne voir que le début ou que la fin d'un texte, du résultat d'une commande,... Il existe pour cela deux outils : **head** (tête en français) et **tail** (queue en français).
161 Mot inconnu : tail => Il est souvent utile de ne voir que le début ou que la fin d'un texte, du résultat d'une commande,... Il existe pour cela deux outils : **head** (tête en français) et **tail** (queue en français).

163 Il manque un espace insécable. => Par exemple, on désire afficher les 5 premières lignes du fichier /var/log/Xorg.0.log :

165 Mot inconnu : head => <code>head -n 5 /var/log/Xorg.0.log</code>
165 Il manque un espace à côté du tiret. => <code>head -n 5 /var/log/Xorg.0.log</code>

167 Il manque un espace insécable. => Pour les 5 dernières :

169 Mot inconnu : tail => <code>tail -n 5 /var/log/Xorg.0.log</code>
169 Il manque un espace à côté du tiret. => <code>tail -n 5 /var/log/Xorg.0.log</code>

171 Typographie : points de suspension. Utilisez le caractère dédié. => Pour récupérer le résultat d'une commande, nous allons utiliser l'opérateur | appelé **pipe** (qui signifie tuyau...), son fonctionnement sera expliqué plus bas. Pour récupérer les 5 dernières du résultat de dmesg :
171 Mot inconnu : dmesg => Pour récupérer le résultat d'une commande, nous allons utiliser l'opérateur | appelé **pipe** (qui signifie tuyau...), son fonctionnement sera expliqué plus bas. Pour récupérer les 5 dernières du résultat de dmesg :
171 Il manque un espace insécable. => Pour récupérer le résultat d'une commande, nous allons utiliser l'opérateur | appelé **pipe** (qui signifie tuyau...), son fonctionnement sera expliqué plus bas. Pour récupérer les 5 dernières du résultat de dmesg :

173 Mot inconnu : dmesg => <code>dmesg | tail -n 5</code>
173 Mot inconnu : tail => <code>dmesg | tail -n 5</code>
173 Il manque un espace à côté du tiret. => <code>dmesg | tail -n 5</code>

175 Il manque un espace à côté du tiret. => L'option -f permet d'afficher, à chaque fois qu'ils ont lieu, les ajouts au fichier, par exemple : 
175 Il manque un espace insécable. => L'option -f permet d'afficher, à chaque fois qu'ils ont lieu, les ajouts au fichier, par exemple : 
175 Espace(s) en fin de ligne à supprimer. => L'option -f permet d'afficher, à chaque fois qu'ils ont lieu, les ajouts au fichier, par exemple : 

177 Mot inconnu : tail => <code>tail -f /var/log/syslog</code>
177 Il manque un espace à côté du tiret. => <code>tail -f /var/log/syslog</code>

185 Il manque un espace insécable. => Cet opérateur permet d'envoyer la **sortie standard** d'un programme **vers** **l'entrée standard** d'un second programme, cela permet ainsi l'enchaînement des commandes. Par exemple : 
185 Espace(s) en fin de ligne à supprimer. => Cet opérateur permet d'envoyer la **sortie standard** d'un programme **vers** **l'entrée standard** d'un second programme, cela permet ainsi l'enchaînement des commandes. Par exemple : 

187 Mot inconnu : ls => <code>ls | wc -l</code>
187 Mot inconnu : wc => <code>ls | wc -l</code>
187 Il manque un espace à côté du tiret. => <code>ls | wc -l</code>

189 Guillemets typographiques ouvrants. => La sortie standard de "ls" devient l'entrée standard de "wc -l".
189 Mot inconnu : ls => La sortie standard de "ls" devient l'entrée standard de "wc -l".
189 Guillemets typographiques fermants. => La sortie standard de "ls" devient l'entrée standard de "wc -l".
189 Guillemets typographiques ouvrants. => La sortie standard de "ls" devient l'entrée standard de "wc -l".
189 Mot inconnu : wc => La sortie standard de "ls" devient l'entrée standard de "wc -l".
189 Il manque un espace à côté du tiret. => La sortie standard de "ls" devient l'entrée standard de "wc -l".
189 Guillemets typographiques fermants. => La sortie standard de "ls" devient l'entrée standard de "wc -l".

191 Il manque un espace insécable. => Autres exemples : 
191 Espace(s) en fin de ligne à supprimer. => Autres exemples : 

193 Mot inconnu : cat => <code>cat fichier | wc -l</code>
193 Mot inconnu : wc => <code>cat fichier | wc -l</code>
193 Il manque un espace à côté du tiret. => <code>cat fichier | wc -l</code>

195 Mot inconnu : ls => <code>ls -l | sort</code>
195 Il manque un espace à côté du tiret. => <code>ls -l | sort</code>

197 Mot inconnu : icons => {{:icons:icontip.png  }}
197 Il manque un espace. => {{:icons:icontip.png  }}
197 Mot inconnu : icontip => {{:icons:icontip.png  }}
197 Mot inconnu : png => {{:icons:icontip.png  }}
197 Espace(s) surnuméraire(s) à supprimer. => {{:icons:icontip.png  }}

198 Guillemets typographiques ouvrants. => >sort permet de trier les lignes d'un fichier texte, pour plus d'information "man sort". 
198 Guillemets typographiques fermants. => >sort permet de trier les lignes d'un fichier texte, pour plus d'information "man sort". 
198 Espace(s) en fin de ligne à supprimer. => >sort permet de trier les lignes d'un fichier texte, pour plus d'information "man sort". 

200 Il manque un espace insécable. => Vous pouvez bien sûr étendre cela à plus de deux programmes : 
200 Espace(s) en fin de ligne à supprimer. => Vous pouvez bien sûr étendre cela à plus de deux programmes : 

202 Mot inconnu : cat => <code>cat fichier | wc -l | wc -L</code>
202 Mot inconnu : wc => <code>cat fichier | wc -l | wc -L</code>
202 Il manque un espace à côté du tiret. => <code>cat fichier | wc -l | wc -L</code>
202 Mot inconnu : wc => <code>cat fichier | wc -l | wc -L</code>
202 Il manque un espace à côté du tiret. => <code>cat fichier | wc -l | wc -L</code>

204 Il manque un espace insécable. => Vous pouvez aussi utiliser les redirections vues précédemment : 
204 Espace(s) en fin de ligne à supprimer. => Vous pouvez aussi utiliser les redirections vues précédemment : 

206 Mot inconnu : ls => <code>ls -la > fichier | wc -l</code>
206 Il manque un espace à côté du tiret. => <code>ls -la > fichier | wc -l</code>
206 Mot inconnu : wc => <code>ls -la > fichier | wc -l</code>
206 Il manque un espace à côté du tiret. => <code>ls -la > fichier | wc -l</code>

208 Guillemets typographiques ouvrants. => Dans le cas de "ls -la > fichier" nous pouvons remarquer qu'il n'y a rien sur stdout ou stderr. Pour pallier à cela le programme tee permet de copier l'entrée standard sur la sortie standard et dans un fichier : "ls -la | tee fichier". 
208 Mot inconnu : ls => Dans le cas de "ls -la > fichier" nous pouvons remarquer qu'il n'y a rien sur stdout ou stderr. Pour pallier à cela le programme tee permet de copier l'entrée standard sur la sortie standard et dans un fichier : "ls -la | tee fichier". 
208 Il manque un espace à côté du tiret. => Dans le cas de "ls -la > fichier" nous pouvons remarquer qu'il n'y a rien sur stdout ou stderr. Pour pallier à cela le programme tee permet de copier l'entrée standard sur la sortie standard et dans un fichier : "ls -la | tee fichier". 
208 Guillemets typographiques fermants. => Dans le cas de "ls -la > fichier" nous pouvons remarquer qu'il n'y a rien sur stdout ou stderr. Pour pallier à cela le programme tee permet de copier l'entrée standard sur la sortie standard et dans un fichier : "ls -la | tee fichier". 
208 Mot inconnu : stdout => Dans le cas de "ls -la > fichier" nous pouvons remarquer qu'il n'y a rien sur stdout ou stderr. Pour pallier à cela le programme tee permet de copier l'entrée standard sur la sortie standard et dans un fichier : "ls -la | tee fichier". 
208 Mot inconnu : stderr => Dans le cas de "ls -la > fichier" nous pouvons remarquer qu'il n'y a rien sur stdout ou stderr. Pour pallier à cela le programme tee permet de copier l'entrée standard sur la sortie standard et dans un fichier : "ls -la | tee fichier". 
208 Il manque un espace insécable. => Dans le cas de "ls -la > fichier" nous pouvons remarquer qu'il n'y a rien sur stdout ou stderr. Pour pallier à cela le programme tee permet de copier l'entrée standard sur la sortie standard et dans un fichier : "ls -la | tee fichier". 
208 Guillemets typographiques ouvrants. => Dans le cas de "ls -la > fichier" nous pouvons remarquer qu'il n'y a rien sur stdout ou stderr. Pour pallier à cela le programme tee permet de copier l'entrée standard sur la sortie standard et dans un fichier : "ls -la | tee fichier". 
208 Mot inconnu : ls => Dans le cas de "ls -la > fichier" nous pouvons remarquer qu'il n'y a rien sur stdout ou stderr. Pour pallier à cela le programme tee permet de copier l'entrée standard sur la sortie standard et dans un fichier : "ls -la | tee fichier". 
208 Il manque un espace à côté du tiret. => Dans le cas de "ls -la > fichier" nous pouvons remarquer qu'il n'y a rien sur stdout ou stderr. Pour pallier à cela le programme tee permet de copier l'entrée standard sur la sortie standard et dans un fichier : "ls -la | tee fichier". 
208 Guillemets typographiques fermants. => Dans le cas de "ls -la > fichier" nous pouvons remarquer qu'il n'y a rien sur stdout ou stderr. Pour pallier à cela le programme tee permet de copier l'entrée standard sur la sortie standard et dans un fichier : "ls -la | tee fichier". 
208 Espace(s) en fin de ligne à supprimer. => Dans le cas de "ls -la > fichier" nous pouvons remarquer qu'il n'y a rien sur stdout ou stderr. Pour pallier à cela le programme tee permet de copier l'entrée standard sur la sortie standard et dans un fichier : "ls -la | tee fichier". 

210 Il manque un espace insécable. => Ainsi on utilisera :

212 Mot inconnu : ls => <code>ls -la | tee fichier | wc -l</code>
212 Il manque un espace à côté du tiret. => <code>ls -la | tee fichier | wc -l</code>
212 Mot inconnu : wc => <code>ls -la | tee fichier | wc -l</code>
212 Il manque un espace à côté du tiret. => <code>ls -la | tee fichier | wc -l</code>

216 Il manque un espace insécable. => Cet opérateur permet de lancer simultanément deux commandes dont la première sera lancée en arrière plan. Par exemple :

218 Mot inconnu : ls => <code>ls & ls -la</code>
218 Mot inconnu : ls => <code>ls & ls -la</code>
218 Il manque un espace à côté du tiret. => <code>ls & ls -la</code>

220 Mot inconnu : icons => {{icons:iconnote.png  }}
220 Il manque un espace. => {{icons:iconnote.png  }}
220 Mot inconnu : iconnote => {{icons:iconnote.png  }}
220 Mot inconnu : png => {{icons:iconnote.png  }}
220 Espace(s) surnuméraire(s) à supprimer. => {{icons:iconnote.png  }}

221 Il manque un espace insécable. => Vous pouvez aussi l'utiliser pour mettre un programme en arrière plan : "ed &". Pour reprendre la main sur ce programme il faut utiliser la commande fg.
221 Guillemets typographiques ouvrants. => Vous pouvez aussi l'utiliser pour mettre un programme en arrière plan : "ed &". Pour reprendre la main sur ce programme il faut utiliser la commande fg.
221 Mot inconnu : ed => Vous pouvez aussi l'utiliser pour mettre un programme en arrière plan : "ed &". Pour reprendre la main sur ce programme il faut utiliser la commande fg.

226 Il manque un espace insécable. => Pour pouvoir bien comprendre ce que fait cet opérateur il faut d'abord parler rapidement des **codes de retour** : quand vous lancez une commande, si elle se termine correctement alors le code de retour est "0", ce qui correspond à un succès, dans le cas contraire le code de retour est différent de 0 (bien entendu les codes de retour différents de 0 ont une signification qui ne sera pas expliquée ici). 
226 Guillemets typographiques ouvrants. => Pour pouvoir bien comprendre ce que fait cet opérateur il faut d'abord parler rapidement des **codes de retour** : quand vous lancez une commande, si elle se termine correctement alors le code de retour est "0", ce qui correspond à un succès, dans le cas contraire le code de retour est différent de 0 (bien entendu les codes de retour différents de 0 ont une signification qui ne sera pas expliquée ici). 
226 Guillemets typographiques fermants. => Pour pouvoir bien comprendre ce que fait cet opérateur il faut d'abord parler rapidement des **codes de retour** : quand vous lancez une commande, si elle se termine correctement alors le code de retour est "0", ce qui correspond à un succès, dans le cas contraire le code de retour est différent de 0 (bien entendu les codes de retour différents de 0 ont une signification qui ne sera pas expliquée ici). 
226 Espace(s) en fin de ligne à supprimer. => Pour pouvoir bien comprendre ce que fait cet opérateur il faut d'abord parler rapidement des **codes de retour** : quand vous lancez une commande, si elle se termine correctement alors le code de retour est "0", ce qui correspond à un succès, dans le cas contraire le code de retour est différent de 0 (bien entendu les codes de retour différents de 0 ont une signification qui ne sera pas expliquée ici). 

228 Il manque un espace insécable. => Si par exemple vous rentrez une commande erronée, le code de retour sera différent de 0 : "fgsfdg". 
228 Guillemets typographiques ouvrants. => Si par exemple vous rentrez une commande erronée, le code de retour sera différent de 0 : "fgsfdg". 
228 Mot inconnu : fgsfdg => Si par exemple vous rentrez une commande erronée, le code de retour sera différent de 0 : "fgsfdg". 
228 Guillemets typographiques fermants. => Si par exemple vous rentrez une commande erronée, le code de retour sera différent de 0 : "fgsfdg". 
228 Espace(s) en fin de ligne à supprimer. => Si par exemple vous rentrez une commande erronée, le code de retour sera différent de 0 : "fgsfdg". 

230 Il manque un espace insécable. => Pour voir le code de retour de la dernière commande lancée : 
230 Espace(s) en fin de ligne à supprimer. => Pour voir le code de retour de la dernière commande lancée : 

232 Mot inconnu : echo => <code>echo $?</code>

234 Il manque un espace insécable. => L'opérateur "&&" permet de lancer une commande si et seulement si la première (celle à gauche de l'opérateur) s'est correctement terminée : 
234 Espace(s) en fin de ligne à supprimer. => L'opérateur "&&" permet de lancer une commande si et seulement si la première (celle à gauche de l'opérateur) s'est correctement terminée : 

236 Mot inconnu : ls => <code>ls && ls /</code>
236 Mot inconnu : ls => <code>ls && ls /</code>

238 Guillemets typographiques ouvrants. => Si la commande "ls" se termine correctement alors "ls /" sera exécutée. Un second exemple : 
238 Mot inconnu : ls => Si la commande "ls" se termine correctement alors "ls /" sera exécutée. Un second exemple : 
238 Guillemets typographiques fermants. => Si la commande "ls" se termine correctement alors "ls /" sera exécutée. Un second exemple : 
238 Guillemets typographiques ouvrants. => Si la commande "ls" se termine correctement alors "ls /" sera exécutée. Un second exemple : 
238 Mot inconnu : ls => Si la commande "ls" se termine correctement alors "ls /" sera exécutée. Un second exemple : 
238 Il manque un espace insécable. => Si la commande "ls" se termine correctement alors "ls /" sera exécutée. Un second exemple : 
238 Espace(s) en fin de ligne à supprimer. => Si la commande "ls" se termine correctement alors "ls /" sera exécutée. Un second exemple : 

240 Mot inconnu : fdgfdsg => <code>fdgfdsg && ls</code>
240 Mot inconnu : ls => <code>fdgfdsg && ls</code>

244 Il manque un espace insécable. => C'est simplement l'inverse de "&&". La commande à gauche de l'opérateur est exécutée seulement si le code de retour de la première commande est différent de 0 (donc s'il y a eu une erreur) :

246 Mot inconnu : fhgfdsjk => <code>fhgfdsjk || ls</code>
246 Mot inconnu : ls => <code>fhgfdsjk || ls</code>

248 Guillemets typographiques ouvrants. => Dans ce cas "ls" sera exécuté.
248 Mot inconnu : ls => Dans ce cas "ls" sera exécuté.
248 Guillemets typographiques fermants. => Dans ce cas "ls" sera exécuté.

250 Guillemets fermants. => ==== Présentation de ";" ====

252 Il manque les traits d’union. => Cet opérateur est équivalent à un retour à la ligne, c'est à dire que "ls; ls -l" exécutera "ls" dans un premier temps puis, une fois la première commande finie et quel que soit son code de retour, "ls -l" sera exécuté.
252 Guillemets typographiques ouvrants. => Cet opérateur est équivalent à un retour à la ligne, c'est à dire que "ls; ls -l" exécutera "ls" dans un premier temps puis, une fois la première commande finie et quel que soit son code de retour, "ls -l" sera exécuté.
252 Mot inconnu : ls => Cet opérateur est équivalent à un retour à la ligne, c'est à dire que "ls; ls -l" exécutera "ls" dans un premier temps puis, une fois la première commande finie et quel que soit son code de retour, "ls -l" sera exécuté.
252 Il manque un espace insécable. => Cet opérateur est équivalent à un retour à la ligne, c'est à dire que "ls; ls -l" exécutera "ls" dans un premier temps puis, une fois la première commande finie et quel que soit son code de retour, "ls -l" sera exécuté.
252 Mot inconnu : ls => Cet opérateur est équivalent à un retour à la ligne, c'est à dire que "ls; ls -l" exécutera "ls" dans un premier temps puis, une fois la première commande finie et quel que soit son code de retour, "ls -l" sera exécuté.
252 Il manque un espace à côté du tiret. => Cet opérateur est équivalent à un retour à la ligne, c'est à dire que "ls; ls -l" exécutera "ls" dans un premier temps puis, une fois la première commande finie et quel que soit son code de retour, "ls -l" sera exécuté.
252 Guillemets typographiques fermants. => Cet opérateur est équivalent à un retour à la ligne, c'est à dire que "ls; ls -l" exécutera "ls" dans un premier temps puis, une fois la première commande finie et quel que soit son code de retour, "ls -l" sera exécuté.
252 Guillemets typographiques ouvrants. => Cet opérateur est équivalent à un retour à la ligne, c'est à dire que "ls; ls -l" exécutera "ls" dans un premier temps puis, une fois la première commande finie et quel que soit son code de retour, "ls -l" sera exécuté.
252 Mot inconnu : ls => Cet opérateur est équivalent à un retour à la ligne, c'est à dire que "ls; ls -l" exécutera "ls" dans un premier temps puis, une fois la première commande finie et quel que soit son code de retour, "ls -l" sera exécuté.
252 Guillemets typographiques fermants. => Cet opérateur est équivalent à un retour à la ligne, c'est à dire que "ls; ls -l" exécutera "ls" dans un premier temps puis, une fois la première commande finie et quel que soit son code de retour, "ls -l" sera exécuté.
252 Guillemets typographiques ouvrants. => Cet opérateur est équivalent à un retour à la ligne, c'est à dire que "ls; ls -l" exécutera "ls" dans un premier temps puis, une fois la première commande finie et quel que soit son code de retour, "ls -l" sera exécuté.
252 Mot inconnu : ls => Cet opérateur est équivalent à un retour à la ligne, c'est à dire que "ls; ls -l" exécutera "ls" dans un premier temps puis, une fois la première commande finie et quel que soit son code de retour, "ls -l" sera exécuté.
252 Il manque un espace à côté du tiret. => Cet opérateur est équivalent à un retour à la ligne, c'est à dire que "ls; ls -l" exécutera "ls" dans un premier temps puis, une fois la première commande finie et quel que soit son code de retour, "ls -l" sera exécuté.
252 Guillemets typographiques fermants. => Cet opérateur est équivalent à un retour à la ligne, c'est à dire que "ls; ls -l" exécutera "ls" dans un premier temps puis, une fois la première commande finie et quel que soit son code de retour, "ls -l" sera exécuté.

259 Mot inconnu : regex => Les **expressions rationnelles**, souvent appelées **expressions régulières**, **regex** ou **regular expressions** sont des notations qui permettent de décrire des chaînes de caractères, d'en reconnaître, d'en manipuler.
259 Mot inconnu : regular => Les **expressions rationnelles**, souvent appelées **expressions régulières**, **regex** ou **regular expressions** sont des notations qui permettent de décrire des chaînes de caractères, d'en reconnaître, d'en manipuler.

261 Il manque un espace insécable. => Pour commencer nous allons chercher grâce à elles des mots dans le dictionnaire /usr/share/dict/french, malheureusement celui-ci a des problèmes d'accents, on va donc le convertir en un fichier où l'on pourra lire les accents :

263 Mot inconnu : iconv => <code>iconv -f ISO-8859-15 -t UTF-8 /usr/share/dict/french > /tmp/french.utf8</code>
263 Il manque un espace à côté du tiret. => <code>iconv -f ISO-8859-15 -t UTF-8 /usr/share/dict/french > /tmp/french.utf8</code>

265 Mot inconnu : iconv => Pour plus d'informations sur iconv, voir la page du manuel. Maintenant notre dictionnaire est /tmp/french.utf8 .

267 Il manque un espace à côté du tiret. => Nous allons chercher les mots qui finissent par -er, pour cela on parcourt le fichier avec grep et on ne sort que les lignes finissant par -er :
267 Mot inconnu : er => Nous allons chercher les mots qui finissent par -er, pour cela on parcourt le fichier avec grep et on ne sort que les lignes finissant par -er :
267 Mot inconnu : grep => Nous allons chercher les mots qui finissent par -er, pour cela on parcourt le fichier avec grep et on ne sort que les lignes finissant par -er :
267 Il manque un espace à côté du tiret. => Nous allons chercher les mots qui finissent par -er, pour cela on parcourt le fichier avec grep et on ne sort que les lignes finissant par -er :
267 Mot inconnu : er => Nous allons chercher les mots qui finissent par -er, pour cela on parcourt le fichier avec grep et on ne sort que les lignes finissant par -er :
267 Il manque un espace insécable. => Nous allons chercher les mots qui finissent par -er, pour cela on parcourt le fichier avec grep et on ne sort que les lignes finissant par -er :

269 Mot inconnu : grep => <code>grep 'er$' /tmp/french.utf8</code>
269 Guillemets typographiques ouvrants. => <code>grep 'er$' /tmp/french.utf8</code>
269 Mot inconnu : er => <code>grep 'er$' /tmp/french.utf8</code>

273 Mot inconnu : absol => Maintenant on désire chercher les mots commençant par absol- :
273 Il manque un espace insécable. => Maintenant on désire chercher les mots commençant par absol- :

275 Mot inconnu : grep => <code>grep '^absol' /tmp/french.utf8</code>
275 Mot inconnu : absol => <code>grep '^absol' /tmp/french.utf8</code>
275 Guillemets typographiques fermants. => <code>grep '^absol' /tmp/french.utf8</code>

279 Mot inconnu : wildcard => On cherche maintenant les mots de 4 caractères commençant et finissant par un t, pour cela on utilise l'opérateur "**.**" qui remplace n'importe quel caractère, il est parfois appelé **wildcard** : 
279 Il manque un espace insécable. => On cherche maintenant les mots de 4 caractères commençant et finissant par un t, pour cela on utilise l'opérateur "**.**" qui remplace n'importe quel caractère, il est parfois appelé **wildcard** : 
279 Espace(s) en fin de ligne à supprimer. => On cherche maintenant les mots de 4 caractères commençant et finissant par un t, pour cela on utilise l'opérateur "**.**" qui remplace n'importe quel caractère, il est parfois appelé **wildcard** : 

281 Mot inconnu : grep => <code>grep '^t..t$' /tmp/french.utf8</code>
281 Typographie : un ou trois points ? => <code>grep '^t..t$' /tmp/french.utf8</code>

283 Guillemets typographiques ouvrants. => Pour avoir exactement la ligne contenant "coucou", qui doit donc commencer et finir par coucou : 
283 Guillemets typographiques fermants. => Pour avoir exactement la ligne contenant "coucou", qui doit donc commencer et finir par coucou : 
283 Il manque un espace insécable. => Pour avoir exactement la ligne contenant "coucou", qui doit donc commencer et finir par coucou : 
283 Espace(s) en fin de ligne à supprimer. => Pour avoir exactement la ligne contenant "coucou", qui doit donc commencer et finir par coucou : 

285 Mot inconnu : grep => <code>grep '^coucou$' /tmp/french.utf8</code>

289 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * * représente **0 ou plus** caractères. Exemple : d* = 0 ou plus fois "d".
289 Il manque un espace insécable. =>   * * représente **0 ou plus** caractères. Exemple : d* = 0 ou plus fois "d".
289 Guillemets typographiques ouvrants. =>   * * représente **0 ou plus** caractères. Exemple : d* = 0 ou plus fois "d".
289 Guillemets typographiques fermants. =>   * * représente **0 ou plus** caractères. Exemple : d* = 0 ou plus fois "d".

290 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * + représente **1 ou plus** caractères.  
290 Espace(s) en fin de ligne à supprimer. =>   * + représente **1 ou plus** caractères.  

291 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>   * ? représente **0 ou 1** caractère.
291 Il manque un espace insécable. =>   * ? représente **0 ou 1** caractère.

293 Guillemets typographiques ouvrants. => Par exemple si l'on cherche les mots commençant par "t" et finissant par "tant" : 
293 Guillemets typographiques fermants. => Par exemple si l'on cherche les mots commençant par "t" et finissant par "tant" : 
293 Guillemets typographiques ouvrants. => Par exemple si l'on cherche les mots commençant par "t" et finissant par "tant" : 
293 Guillemets typographiques fermants. => Par exemple si l'on cherche les mots commençant par "t" et finissant par "tant" : 
293 Il manque un espace insécable. => Par exemple si l'on cherche les mots commençant par "t" et finissant par "tant" : 
293 Espace(s) en fin de ligne à supprimer. => Par exemple si l'on cherche les mots commençant par "t" et finissant par "tant" : 

295 Mot inconnu : grep => <code>grep '^t.*tant$' /tmp/french.utf8</code>

297 Guillemets typographiques fermants. => "^t" nous donne les mots commençant par "t", "tant$" prends ceux finissant par "tant" et au milieu on veut 0 ou plus fois n'importe quel caractère, donc le ".".
297 Guillemets typographiques ouvrants. => "^t" nous donne les mots commençant par "t", "tant$" prends ceux finissant par "tant" et au milieu on veut 0 ou plus fois n'importe quel caractère, donc le ".".
297 Guillemets typographiques fermants. => "^t" nous donne les mots commençant par "t", "tant$" prends ceux finissant par "tant" et au milieu on veut 0 ou plus fois n'importe quel caractère, donc le ".".
297 Guillemets typographiques ouvrants. => "^t" nous donne les mots commençant par "t", "tant$" prends ceux finissant par "tant" et au milieu on veut 0 ou plus fois n'importe quel caractère, donc le ".".
297 Guillemets typographiques ouvrants. => "^t" nous donne les mots commençant par "t", "tant$" prends ceux finissant par "tant" et au milieu on veut 0 ou plus fois n'importe quel caractère, donc le ".".
297 Guillemets typographiques fermants. => "^t" nous donne les mots commençant par "t", "tant$" prends ceux finissant par "tant" et au milieu on veut 0 ou plus fois n'importe quel caractère, donc le ".".
297 Guillemets fermants. => "^t" nous donne les mots commençant par "t", "tant$" prends ceux finissant par "tant" et au milieu on veut 0 ou plus fois n'importe quel caractère, donc le ".".
297 Guillemets typographiques fermants. => "^t" nous donne les mots commençant par "t", "tant$" prends ceux finissant par "tant" et au milieu on veut 0 ou plus fois n'importe quel caractère, donc le ".".

299 Guillemets typographiques ouvrants. => On veut maintenant chercher les mots contenant "m" ou "mm", pour cela on va utiliser une expression régulière étendue, il faudra donc utiliser l'option "-E" de grep : 
299 Guillemets typographiques fermants. => On veut maintenant chercher les mots contenant "m" ou "mm", pour cela on va utiliser une expression régulière étendue, il faudra donc utiliser l'option "-E" de grep : 
299 Guillemets typographiques ouvrants. => On veut maintenant chercher les mots contenant "m" ou "mm", pour cela on va utiliser une expression régulière étendue, il faudra donc utiliser l'option "-E" de grep : 
299 Guillemets typographiques fermants. => On veut maintenant chercher les mots contenant "m" ou "mm", pour cela on va utiliser une expression régulière étendue, il faudra donc utiliser l'option "-E" de grep : 
299 Guillemets typographiques fermants. => On veut maintenant chercher les mots contenant "m" ou "mm", pour cela on va utiliser une expression régulière étendue, il faudra donc utiliser l'option "-E" de grep : 
299 Mot inconnu : grep => On veut maintenant chercher les mots contenant "m" ou "mm", pour cela on va utiliser une expression régulière étendue, il faudra donc utiliser l'option "-E" de grep : 
299 Il manque un espace insécable. => On veut maintenant chercher les mots contenant "m" ou "mm", pour cela on va utiliser une expression régulière étendue, il faudra donc utiliser l'option "-E" de grep : 
299 Espace(s) en fin de ligne à supprimer. => On veut maintenant chercher les mots contenant "m" ou "mm", pour cela on va utiliser une expression régulière étendue, il faudra donc utiliser l'option "-E" de grep : 

301 Mot inconnu : grep => <code>grep -E 'm{1,2}' /tmp/french.utf8</code>
301 Il manque un espace à côté du tiret. => <code>grep -E 'm{1,2}' /tmp/french.utf8</code>
301 Guillemets typographiques ouvrants. => <code>grep -E 'm{1,2}' /tmp/french.utf8</code>

303 Il manque un espace insécable. => Remarque : cette expression donne les mots contenant 1 ou 2 m consécutifs ou non.

305 Mot inconnu : icons => {{:icons:icontip.png  }}
305 Il manque un espace. => {{:icons:icontip.png  }}
305 Mot inconnu : icontip => {{:icons:icontip.png  }}
305 Mot inconnu : png => {{:icons:icontip.png  }}
305 Espace(s) surnuméraire(s) à supprimer. => {{:icons:icontip.png  }}

306 Il manque un espace à côté du tiret. => >Les expressions régulières étendues se calculent moins rapidement que celles de bases, pour alléger les programmes elles sont regroupées et accessibles via -E.

308 Guillemets typographiques ouvrants. => Pour être toujours plus fou, on veut maintenant trouver tous les noms finissant par "eux" ou "eut" pour créer des noms de domaines en ".eu". Pour cela on prend les mots qui commencent par n'importe quoi grâce à "^.*", puis qui terminent par "x" ou "t" grâce à "[xt]", tout ça avec "eu" au milieu bien sûr :
308 Guillemets typographiques fermants. => Pour être toujours plus fou, on veut maintenant trouver tous les noms finissant par "eux" ou "eut" pour créer des noms de domaines en ".eu". Pour cela on prend les mots qui commencent par n'importe quoi grâce à "^.*", puis qui terminent par "x" ou "t" grâce à "[xt]", tout ça avec "eu" au milieu bien sûr :
308 Guillemets typographiques ouvrants. => Pour être toujours plus fou, on veut maintenant trouver tous les noms finissant par "eux" ou "eut" pour créer des noms de domaines en ".eu". Pour cela on prend les mots qui commencent par n'importe quoi grâce à "^.*", puis qui terminent par "x" ou "t" grâce à "[xt]", tout ça avec "eu" au milieu bien sûr :
308 Guillemets typographiques fermants. => Pour être toujours plus fou, on veut maintenant trouver tous les noms finissant par "eux" ou "eut" pour créer des noms de domaines en ".eu". Pour cela on prend les mots qui commencent par n'importe quoi grâce à "^.*", puis qui terminent par "x" ou "t" grâce à "[xt]", tout ça avec "eu" au milieu bien sûr :
308 Guillemets fermants. => Pour être toujours plus fou, on veut maintenant trouver tous les noms finissant par "eux" ou "eut" pour créer des noms de domaines en ".eu". Pour cela on prend les mots qui commencent par n'importe quoi grâce à "^.*", puis qui terminent par "x" ou "t" grâce à "[xt]", tout ça avec "eu" au milieu bien sûr :
308 Guillemets typographiques fermants. => Pour être toujours plus fou, on veut maintenant trouver tous les noms finissant par "eux" ou "eut" pour créer des noms de domaines en ".eu". Pour cela on prend les mots qui commencent par n'importe quoi grâce à "^.*", puis qui terminent par "x" ou "t" grâce à "[xt]", tout ça avec "eu" au milieu bien sûr :
308 Guillemets typographiques ouvrants. => Pour être toujours plus fou, on veut maintenant trouver tous les noms finissant par "eux" ou "eut" pour créer des noms de domaines en ".eu". Pour cela on prend les mots qui commencent par n'importe quoi grâce à "^.*", puis qui terminent par "x" ou "t" grâce à "[xt]", tout ça avec "eu" au milieu bien sûr :
308 Guillemets typographiques fermants. => Pour être toujours plus fou, on veut maintenant trouver tous les noms finissant par "eux" ou "eut" pour créer des noms de domaines en ".eu". Pour cela on prend les mots qui commencent par n'importe quoi grâce à "^.*", puis qui terminent par "x" ou "t" grâce à "[xt]", tout ça avec "eu" au milieu bien sûr :
308 Guillemets typographiques ouvrants. => Pour être toujours plus fou, on veut maintenant trouver tous les noms finissant par "eux" ou "eut" pour créer des noms de domaines en ".eu". Pour cela on prend les mots qui commencent par n'importe quoi grâce à "^.*", puis qui terminent par "x" ou "t" grâce à "[xt]", tout ça avec "eu" au milieu bien sûr :
308 Guillemets typographiques fermants. => Pour être toujours plus fou, on veut maintenant trouver tous les noms finissant par "eux" ou "eut" pour créer des noms de domaines en ".eu". Pour cela on prend les mots qui commencent par n'importe quoi grâce à "^.*", puis qui terminent par "x" ou "t" grâce à "[xt]", tout ça avec "eu" au milieu bien sûr :
308 Mot inconnu : xt => Pour être toujours plus fou, on veut maintenant trouver tous les noms finissant par "eux" ou "eut" pour créer des noms de domaines en ".eu". Pour cela on prend les mots qui commencent par n'importe quoi grâce à "^.*", puis qui terminent par "x" ou "t" grâce à "[xt]", tout ça avec "eu" au milieu bien sûr :
308 Guillemets typographiques ouvrants. => Pour être toujours plus fou, on veut maintenant trouver tous les noms finissant par "eux" ou "eut" pour créer des noms de domaines en ".eu". Pour cela on prend les mots qui commencent par n'importe quoi grâce à "^.*", puis qui terminent par "x" ou "t" grâce à "[xt]", tout ça avec "eu" au milieu bien sûr :
308 Guillemets typographiques fermants. => Pour être toujours plus fou, on veut maintenant trouver tous les noms finissant par "eux" ou "eut" pour créer des noms de domaines en ".eu". Pour cela on prend les mots qui commencent par n'importe quoi grâce à "^.*", puis qui terminent par "x" ou "t" grâce à "[xt]", tout ça avec "eu" au milieu bien sûr :
308 Il manque un espace insécable. => Pour être toujours plus fou, on veut maintenant trouver tous les noms finissant par "eux" ou "eut" pour créer des noms de domaines en ".eu". Pour cela on prend les mots qui commencent par n'importe quoi grâce à "^.*", puis qui terminent par "x" ou "t" grâce à "[xt]", tout ça avec "eu" au milieu bien sûr :

310 Mot inconnu : grep => <code>grep '^.*eu[xt]$' /tmp/french.utf8</code>
310 Mot inconnu : xt => <code>grep '^.*eu[xt]$' /tmp/french.utf8</code>

312 Mot inconnu : KDE => On peut ainsi chercher les jeux pour KDE et pour GNOME, en supposant que tout jeu pour KDE qui se respecte commence par un "k" et par "g" pour GNOME. Pour cela on cherche tous les jeux, et on ne garde que ceux qui commencent par "k" ou "g" :
312 Mot inconnu : KDE => On peut ainsi chercher les jeux pour KDE et pour GNOME, en supposant que tout jeu pour KDE qui se respecte commence par un "k" et par "g" pour GNOME. Pour cela on cherche tous les jeux, et on ne garde que ceux qui commencent par "k" ou "g" :
312 Guillemets typographiques ouvrants. => On peut ainsi chercher les jeux pour KDE et pour GNOME, en supposant que tout jeu pour KDE qui se respecte commence par un "k" et par "g" pour GNOME. Pour cela on cherche tous les jeux, et on ne garde que ceux qui commencent par "k" ou "g" :
312 Guillemets typographiques fermants. => On peut ainsi chercher les jeux pour KDE et pour GNOME, en supposant que tout jeu pour KDE qui se respecte commence par un "k" et par "g" pour GNOME. Pour cela on cherche tous les jeux, et on ne garde que ceux qui commencent par "k" ou "g" :
312 Guillemets typographiques ouvrants. => On peut ainsi chercher les jeux pour KDE et pour GNOME, en supposant que tout jeu pour KDE qui se respecte commence par un "k" et par "g" pour GNOME. Pour cela on cherche tous les jeux, et on ne garde que ceux qui commencent par "k" ou "g" :
312 Guillemets typographiques fermants. => On peut ainsi chercher les jeux pour KDE et pour GNOME, en supposant que tout jeu pour KDE qui se respecte commence par un "k" et par "g" pour GNOME. Pour cela on cherche tous les jeux, et on ne garde que ceux qui commencent par "k" ou "g" :
312 Guillemets typographiques ouvrants. => On peut ainsi chercher les jeux pour KDE et pour GNOME, en supposant que tout jeu pour KDE qui se respecte commence par un "k" et par "g" pour GNOME. Pour cela on cherche tous les jeux, et on ne garde que ceux qui commencent par "k" ou "g" :
312 Guillemets typographiques fermants. => On peut ainsi chercher les jeux pour KDE et pour GNOME, en supposant que tout jeu pour KDE qui se respecte commence par un "k" et par "g" pour GNOME. Pour cela on cherche tous les jeux, et on ne garde que ceux qui commencent par "k" ou "g" :
312 Guillemets typographiques ouvrants. => On peut ainsi chercher les jeux pour KDE et pour GNOME, en supposant que tout jeu pour KDE qui se respecte commence par un "k" et par "g" pour GNOME. Pour cela on cherche tous les jeux, et on ne garde que ceux qui commencent par "k" ou "g" :
312 Guillemets typographiques fermants. => On peut ainsi chercher les jeux pour KDE et pour GNOME, en supposant que tout jeu pour KDE qui se respecte commence par un "k" et par "g" pour GNOME. Pour cela on cherche tous les jeux, et on ne garde que ceux qui commencent par "k" ou "g" :
312 Il manque un espace insécable. => On peut ainsi chercher les jeux pour KDE et pour GNOME, en supposant que tout jeu pour KDE qui se respecte commence par un "k" et par "g" pour GNOME. Pour cela on cherche tous les jeux, et on ne garde que ceux qui commencent par "k" ou "g" :

314 Mot inconnu : apt-cache => <code>apt-cache search games | grep '^[gk]'</code>
314 Mot inconnu : search => <code>apt-cache search games | grep '^[gk]'</code>
314 Mot inconnu : games => <code>apt-cache search games | grep '^[gk]'</code>
314 Mot inconnu : grep => <code>apt-cache search games | grep '^[gk]'</code>
314 Mot inconnu : gk => <code>apt-cache search games | grep '^[gk]'</code>

316 Guillemets typographiques ouvrants. => Maintenant on veut chercher les jeux qui ne commencent ni par "g" ni par "k" :
316 Guillemets typographiques fermants. => Maintenant on veut chercher les jeux qui ne commencent ni par "g" ni par "k" :
316 Guillemets typographiques ouvrants. => Maintenant on veut chercher les jeux qui ne commencent ni par "g" ni par "k" :
316 Guillemets typographiques fermants. => Maintenant on veut chercher les jeux qui ne commencent ni par "g" ni par "k" :
316 Il manque un espace insécable. => Maintenant on veut chercher les jeux qui ne commencent ni par "g" ni par "k" :

318 Mot inconnu : apt-cache => <code>apt-cache search games | grep '^[^gk].*' | grep -v '^lib'</code>
318 Mot inconnu : search => <code>apt-cache search games | grep '^[^gk].*' | grep -v '^lib'</code>
318 Mot inconnu : games => <code>apt-cache search games | grep '^[^gk].*' | grep -v '^lib'</code>
318 Mot inconnu : grep => <code>apt-cache search games | grep '^[^gk].*' | grep -v '^lib'</code>
318 Mot inconnu : gk => <code>apt-cache search games | grep '^[^gk].*' | grep -v '^lib'</code>
318 Mot inconnu : grep => <code>apt-cache search games | grep '^[^gk].*' | grep -v '^lib'</code>
318 Il manque un espace à côté du tiret. => <code>apt-cache search games | grep '^[^gk].*' | grep -v '^lib'</code>
318 Mot inconnu : lib => <code>apt-cache search games | grep '^[^gk].*' | grep -v '^lib'</code>

320 Mot inconnu : gk => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition.
320 Guillemets typographiques ouvrants. => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition.
320 Guillemets typographiques fermants. => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition.
320 Guillemets typographiques ouvrants. => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition.
320 Guillemets typographiques fermants. => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition.
320 Il manque un espace insécable. => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition.
320 Conjugaison erronée. Accord avec “on”. Le verbe devrait être à la 3ᵉ personne du singulier. => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition.
320 Guillemets typographiques ouvrants. => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition.
320 Guillemets typographiques fermants. => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition.
320 Guillemets typographiques ouvrants. => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition.
320 Guillemets typographiques fermants. => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition.
320 Guillemets fermants. => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition.
320 Guillemets typographiques ouvrants. => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition.
320 Mot inconnu : lib => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition.
320 Guillemets typographiques fermants. => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition.
320 Il manque un espace à côté du tiret. => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition.
320 Mot inconnu : grep => Comme on l'a déjà vu [^gk] retourne ce qui commence par un "g" ou un "k", le "^" devant l'expression **[]** joue le rôle de **négation** : on prends ceux qui ne commencent ni par "g" ni par "k". Puis grâce à ".*" on accepte n'importe quelle fin. Mais cette requête renvoie beaucoup trop de résultats, on effectue donc un deuxième filtrage en éliminant ceux qui commencent par "lib" grâce à l'option -v de grep qui enlève les lignes correspondant à la condition.

322 Il manque un espace insécable. => Autre exemple instructif :

324 Mot inconnu : ls => <code>ls / | grep -E '^m(edia|root)'</code>
324 Mot inconnu : grep => <code>ls / | grep -E '^m(edia|root)'</code>
324 Il manque un espace à côté du tiret. => <code>ls / | grep -E '^m(edia|root)'</code>
324 Il manque un espace avant la parenthèse. => <code>ls / | grep -E '^m(edia|root)'</code>
324 Mot inconnu : edia => <code>ls / | grep -E '^m(edia|root)'</code>
324 Mot inconnu : root => <code>ls / | grep -E '^m(edia|root)'</code>

326 Guillemets typographiques ouvrants. => Les parenthèses permettent d'isoler un regroupement, et le | correspond à "où". Ceci renvoie donc les fichiers/dossiers à la racine commençant par media ou mroot.
326 Guillemets typographiques fermants. => Les parenthèses permettent d'isoler un regroupement, et le | correspond à "où". Ceci renvoie donc les fichiers/dossiers à la racine commençant par media ou mroot.
326 Mot inconnu : mroot => Les parenthèses permettent d'isoler un regroupement, et le | correspond à "où". Ceci renvoie donc les fichiers/dossiers à la racine commençant par media ou mroot.

328 Il manque un espace insécable. => Alors que : 
328 Espace(s) en fin de ligne à supprimer. => Alors que : 

330 Mot inconnu : ls => <code>ls / | grep -E '^media|root'</code>
330 Mot inconnu : grep => <code>ls / | grep -E '^media|root'</code>
330 Il manque un espace à côté du tiret. => <code>ls / | grep -E '^media|root'</code>
330 Mot inconnu : root => <code>ls / | grep -E '^media|root'</code>

332 Mot inconnu : root => renvoie les fichiers/dossiers commençant par media ou par root.

334 Mot inconnu : Sed => ==== Sed ====

336 Il manque un espace insécable. => L'utilisation de cet outil se fait comme ceci :

337 Mot inconnu : echo => <code>echo "du texte" | sed 's/(qui)/(parquoi)'</code>
337 Guillemets typographiques ouvrants. => <code>echo "du texte" | sed 's/(qui)/(parquoi)'</code>
337 Guillemets typographiques fermants. => <code>echo "du texte" | sed 's/(qui)/(parquoi)'</code>
337 Mot inconnu : sed => <code>echo "du texte" | sed 's/(qui)/(parquoi)'</code>
337 Guillemets typographiques ouvrants. => <code>echo "du texte" | sed 's/(qui)/(parquoi)'</code>
337 Mot inconnu : parquoi => <code>echo "du texte" | sed 's/(qui)/(parquoi)'</code>

339 Il manque un espace insécable. => Ex : Pour remplacer la premiere occurence :
339 Mot inconnu : premiere => Ex : Pour remplacer la premiere occurence :
339 Mot inconnu : occurence => Ex : Pour remplacer la premiere occurence :
339 Il manque un espace insécable. => Ex : Pour remplacer la premiere occurence :

341 Mot inconnu : echo => <code>echo "jean.durand@gmail.com" | sed 's/@/ at /' | sed 's/\./ pOiNt /'</code>
341 Guillemets typographiques ouvrants. => <code>echo "jean.durand@gmail.com" | sed 's/@/ at /' | sed 's/\./ pOiNt /'</code>
341 Mot inconnu : sed => <code>echo "jean.durand@gmail.com" | sed 's/@/ at /' | sed 's/\./ pOiNt /'</code>
341 Guillemets typographiques ouvrants. => <code>echo "jean.durand@gmail.com" | sed 's/@/ at /' | sed 's/\./ pOiNt /'</code>
341 Mot inconnu : at => <code>echo "jean.durand@gmail.com" | sed 's/@/ at /' | sed 's/\./ pOiNt /'</code>
341 Mot inconnu : sed => <code>echo "jean.durand@gmail.com" | sed 's/@/ at /' | sed 's/\./ pOiNt /'</code>
341 Guillemets typographiques ouvrants. => <code>echo "jean.durand@gmail.com" | sed 's/@/ at /' | sed 's/\./ pOiNt /'</code>
341 Mot inconnu : pOiNt => <code>echo "jean.durand@gmail.com" | sed 's/@/ at /' | sed 's/\./ pOiNt /'</code>

343 Il manque un espace insécable. => renvoie :

345 Mot inconnu : pOiNt => <code>jean pOiNt durand at gmail.com</code>
345 Mot inconnu : durand => <code>jean pOiNt durand at gmail.com</code>
345 Mot inconnu : at => <code>jean pOiNt durand at gmail.com</code>
345 Mot inconnu : gmail => <code>jean pOiNt durand at gmail.com</code>

347 Guillemets fermants. => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".". 
347 Guillemets typographiques fermants. => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".". 
347 Guillemets isolés. => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".". 
347 Mot inconnu : pOiNt => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".". 
347 Guillemets isolés. => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".". 
347 Guillemets isolés. => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".". 
347 Mot inconnu : at => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".". 
347 Guillemets fermants. => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".". 
347 Guillemets fermants. => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".". 
347 Guillemets typographiques fermants. => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".". 
347 Il manque un espace insécable. => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".". 
347 Guillemets fermants. => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".". 
347 Guillemets typographiques fermants. => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".". 
347 Guillemets fermants. => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".". 
347 Guillemets typographiques fermants. => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".". 
347 Espace(s) en fin de ligne à supprimer. => On remplace le "." par " pOiNt " et le "@" par " at ", on voit ici que l'on a mis "\" devant le ".", le "\" est le caractère d'échappement : le "." est alors considéré comme le caractère ".". 

349 Guillemets typographiques ouvrants. => De même si on veut remplacer "/" par "slash", on utiliserait
349 Guillemets typographiques fermants. => De même si on veut remplacer "/" par "slash", on utiliserait

353 Mot inconnu : sed => On peut faire la même chose en moins long en utilisant l'autre version de sed:
353 Il manque un espace insécable. => On peut faire la même chose en moins long en utilisant l'autre version de sed:

355 Mot inconnu : echo => <code>echo "jean.durand@gmail.com" | sed -e 's/@/ at /' -e 's/\./ pOiNt /'</code>
355 Guillemets typographiques ouvrants. => <code>echo "jean.durand@gmail.com" | sed -e 's/@/ at /' -e 's/\./ pOiNt /'</code>
355 Mot inconnu : sed => <code>echo "jean.durand@gmail.com" | sed -e 's/@/ at /' -e 's/\./ pOiNt /'</code>
355 Il manque un espace à côté du tiret. => <code>echo "jean.durand@gmail.com" | sed -e 's/@/ at /' -e 's/\./ pOiNt /'</code>
355 Guillemets typographiques ouvrants. => <code>echo "jean.durand@gmail.com" | sed -e 's/@/ at /' -e 's/\./ pOiNt /'</code>
355 Mot inconnu : at => <code>echo "jean.durand@gmail.com" | sed -e 's/@/ at /' -e 's/\./ pOiNt /'</code>
355 Guillemets typographiques ouvrants. => <code>echo "jean.durand@gmail.com" | sed -e 's/@/ at /' -e 's/\./ pOiNt /'</code>
355 Mot inconnu : pOiNt => <code>echo "jean.durand@gmail.com" | sed -e 's/@/ at /' -e 's/\./ pOiNt /'</code>

357 Erreur d’accord probable avec “les”. => Pour toute les occurrences ,on peut aussi utiliser :
357 Pas d’espace avant une virgule. Un espace après. => Pour toute les occurrences ,on peut aussi utiliser :
357 Il manque un espace insécable. => Pour toute les occurrences ,on peut aussi utiliser :

358 Espace(s) en fin de ligne à supprimer. => <code>s///g</code> 

359 Mot inconnu : oû => oû :
359 Il manque un espace insécable. => oû :

360 Mot inconnu : echo => <code>echo "jean.durand@gmail.com" | sed -e 's/@/ at /' -e 's/\./ pOiNt /g'</code>
360 Guillemets typographiques ouvrants. => <code>echo "jean.durand@gmail.com" | sed -e 's/@/ at /' -e 's/\./ pOiNt /g'</code>
360 Mot inconnu : sed => <code>echo "jean.durand@gmail.com" | sed -e 's/@/ at /' -e 's/\./ pOiNt /g'</code>
360 Il manque un espace à côté du tiret. => <code>echo "jean.durand@gmail.com" | sed -e 's/@/ at /' -e 's/\./ pOiNt /g'</code>
360 Guillemets typographiques ouvrants. => <code>echo "jean.durand@gmail.com" | sed -e 's/@/ at /' -e 's/\./ pOiNt /g'</code>
360 Mot inconnu : at => <code>echo "jean.durand@gmail.com" | sed -e 's/@/ at /' -e 's/\./ pOiNt /g'</code>
360 Guillemets typographiques ouvrants. => <code>echo "jean.durand@gmail.com" | sed -e 's/@/ at /' -e 's/\./ pOiNt /g'</code>
360 Mot inconnu : pOiNt => <code>echo "jean.durand@gmail.com" | sed -e 's/@/ at /' -e 's/\./ pOiNt /g'</code>

361 Il manque un espace insécable. => qui donnera :

362 Mot inconnu : pOINT => <code>jean pOINT durand at gmail pOINT com</code>
362 Mot inconnu : durand => <code>jean pOINT durand at gmail pOINT com</code>
362 Mot inconnu : at => <code>jean pOINT durand at gmail pOINT com</code>
362 Mot inconnu : gmail => <code>jean pOINT durand at gmail pOINT com</code>
362 Mot inconnu : pOINT => <code>jean pOINT durand at gmail pOINT com</code>

364 Il manque un espace insécable. => On peut de même l'appliquer sur des fichiers :

366 Mot inconnu : sed => <code>sed 's/kikoo/#kikoolol/g' /etc/config.txt</code>
366 Guillemets typographiques ouvrants. => <code>sed 's/kikoo/#kikoolol/g' /etc/config.txt</code>
366 Mot inconnu : kikoo => <code>sed 's/kikoo/#kikoolol/g' /etc/config.txt</code>
366 Guillemets typographiques fermants. => <code>sed 's/kikoo/#kikoolol/g' /etc/config.txt</code>

368 Guillemets typographiques ouvrants. => Ceci remplace toute occurrence de "kikoo" par "#kikoolol" dans le fichier /etc/config.txt mais ne le modifie pas, le résultat est donné sur la sortie standard. Pour modifier le fichier il faut ajouter l'option -i à sed.
368 Mot inconnu : kikoo => Ceci remplace toute occurrence de "kikoo" par "#kikoolol" dans le fichier /etc/config.txt mais ne le modifie pas, le résultat est donné sur la sortie standard. Pour modifier le fichier il faut ajouter l'option -i à sed.
368 Guillemets typographiques fermants. => Ceci remplace toute occurrence de "kikoo" par "#kikoolol" dans le fichier /etc/config.txt mais ne le modifie pas, le résultat est donné sur la sortie standard. Pour modifier le fichier il faut ajouter l'option -i à sed.
368 Guillemets typographiques fermants. => Ceci remplace toute occurrence de "kikoo" par "#kikoolol" dans le fichier /etc/config.txt mais ne le modifie pas, le résultat est donné sur la sortie standard. Pour modifier le fichier il faut ajouter l'option -i à sed.
368 Il manque un espace à côté du tiret. => Ceci remplace toute occurrence de "kikoo" par "#kikoolol" dans le fichier /etc/config.txt mais ne le modifie pas, le résultat est donné sur la sortie standard. Pour modifier le fichier il faut ajouter l'option -i à sed.
368 Mot inconnu : sed => Ceci remplace toute occurrence de "kikoo" par "#kikoolol" dans le fichier /etc/config.txt mais ne le modifie pas, le résultat est donné sur la sortie standard. Pour modifier le fichier il faut ajouter l'option -i à sed.

370 Il manque un espace insécable. => On peut enfin spécifier l’occurrence à remplacer :

372 Mot inconnu : echo => <code>echo "moimoimoi" | sed 's/moi/toi/3'</code>
372 Guillemets typographiques ouvrants. => <code>echo "moimoimoi" | sed 's/moi/toi/3'</code>
372 Mot inconnu : moimoimoi => <code>echo "moimoimoi" | sed 's/moi/toi/3'</code>
372 Guillemets typographiques fermants. => <code>echo "moimoimoi" | sed 's/moi/toi/3'</code>
372 Mot inconnu : sed => <code>echo "moimoimoi" | sed 's/moi/toi/3'</code>
372 Guillemets typographiques ouvrants. => <code>echo "moimoimoi" | sed 's/moi/toi/3'</code>

374 Il manque un espace insécable. => Donne : 
374 Espace(s) en fin de ligne à supprimer. => Donne : 

376 Mot inconnu : moimoitoi => <code>moimoitoi</code>

378 Typographie : points de suspension. Utilisez le caractère dédié. => <note warning>l'action de l'option /n (n=1,2,3...) et /g sur un fichier n'est pas identique

382 Il manque un espace insécable. => c'est pas clair : un exemple  
382 Espace(s) en fin de ligne à supprimer. => c'est pas clair : un exemple  

384 Mot inconnu : fichier1 => le fichier1 contient 3 lignes identiques kikoo
384 Mot inconnu : kikoo => le fichier1 contient 3 lignes identiques kikoo

386 Mot inconnu : fichier2 => le fichier2 contient kikookikookikoo et 2 lignes kikoo
386 Mot inconnu : kikookikookikoo => le fichier2 contient kikookikookikoo et 2 lignes kikoo
386 Mot inconnu : kikoo => le fichier2 contient kikookikookikoo et 2 lignes kikoo

389 Mot inconnu : sed => sed -i 's/kikoo/#kikoo/2 :
389 Il manque un espace à côté du tiret. => sed -i 's/kikoo/#kikoo/2 :
389 Guillemets typographiques ouvrants. => sed -i 's/kikoo/#kikoo/2 :
389 Mot inconnu : kikoo => sed -i 's/kikoo/#kikoo/2 :
389 Il manque un espace insécable. => sed -i 's/kikoo/#kikoo/2 :

391 Mot inconnu : fichier1 => le fichier1 n'est pas modifié !
391 Il manque un espace insécable. => le fichier1 n'est pas modifié !

392 Espace(s) en début de ligne à supprimer : utilisez les retraits de paragraphe (ou les tabulations à la rigueur). =>  

393 Mot inconnu : kikoo => le fichier 2 devient kikoo#kikookikoo les 2 autres lignes ne sont pas modifiées             
393 Espace(s) en fin de ligne à supprimer. => le fichier 2 devient kikoo#kikookikoo les 2 autres lignes ne sont pas modifiées             

396 Espace(s) en fin de ligne à supprimer. => résultat de 

397 Mot inconnu : sed => sed -i 's/kikoo/#kikoo/g  : les deux fichiers sont modifiés  
397 Il manque un espace à côté du tiret. => sed -i 's/kikoo/#kikoo/g  : les deux fichiers sont modifiés  
397 Guillemets typographiques ouvrants. => sed -i 's/kikoo/#kikoo/g  : les deux fichiers sont modifiés  
397 Mot inconnu : kikoo => sed -i 's/kikoo/#kikoo/g  : les deux fichiers sont modifiés  
397 Espace(s) surnuméraire(s) à supprimer. => sed -i 's/kikoo/#kikoo/g  : les deux fichiers sont modifiés  
397 Il manque un espace insécable. => sed -i 's/kikoo/#kikoo/g  : les deux fichiers sont modifiés  
397 Espace(s) en fin de ligne à supprimer. => sed -i 's/kikoo/#kikoo/g  : les deux fichiers sont modifiés  

399 Mot inconnu : kikoo => tous les kikoo deviennent #kikoo 
399 Espace(s) en fin de ligne à supprimer. => tous les kikoo deviennent #kikoo 

404 Mot inconnu : sed => Nous allons maintenant voir l'utilisation de variables avec sed ce qui permet d'échanger, de déplacer des parties d'une chaîne de caractères. Exemple : 
404 Il manque un espace insécable. => Nous allons maintenant voir l'utilisation de variables avec sed ce qui permet d'échanger, de déplacer des parties d'une chaîne de caractères. Exemple : 
404 Espace(s) en fin de ligne à supprimer. => Nous allons maintenant voir l'utilisation de variables avec sed ce qui permet d'échanger, de déplacer des parties d'une chaîne de caractères. Exemple : 

406 Mot inconnu : echo => <code>echo "jean.durand"  | sed -r 's/(.*)\.(.*)/\2.\1/'</code>
406 Guillemets typographiques ouvrants. => <code>echo "jean.durand"  | sed -r 's/(.*)\.(.*)/\2.\1/'</code>
406 Mot inconnu : durand => <code>echo "jean.durand"  | sed -r 's/(.*)\.(.*)/\2.\1/'</code>
406 Guillemets typographiques fermants. => <code>echo "jean.durand"  | sed -r 's/(.*)\.(.*)/\2.\1/'</code>
406 Mot inconnu : sed => <code>echo "jean.durand"  | sed -r 's/(.*)\.(.*)/\2.\1/'</code>
406 Il manque un espace à côté du tiret. => <code>echo "jean.durand"  | sed -r 's/(.*)\.(.*)/\2.\1/'</code>
406 Guillemets typographiques ouvrants. => <code>echo "jean.durand"  | sed -r 's/(.*)\.(.*)/\2.\1/'</code>

408 Guillemets typographiques fermants. => (.*) représente l'affectation des variables et \n la n-ième variable, ici on met donc ce qu'il y a avant le point ("\.") dans \1 et ce qu'il y a après dans \2 puis on met \2 devant \1, on obtient :
408 Il manque un espace insécable. => (.*) représente l'affectation des variables et \n la n-ième variable, ici on met donc ce qu'il y a avant le point ("\.") dans \1 et ce qu'il y a après dans \2 puis on met \2 devant \1, on obtient :

410 Mot inconnu : durand => <code>durand.jean</code>
410 Il manque un espace. => <code>durand.jean</code>

412 Il manque un espace insécable. => Pour terminer nous allons voir un exemple pratique : nous avons de nombreux dossiers contenant de nombreux mp3 nommés selon le schéma Knoklezout_au_taquet-Jamendo-David_TMX.mp3 et on désire avoir le nom d'artiste avant le titre de la chanson tout en enlevant la publicité pour Jamendo. 
412 Mot inconnu : mp3 => Pour terminer nous allons voir un exemple pratique : nous avons de nombreux dossiers contenant de nombreux mp3 nommés selon le schéma Knoklezout_au_taquet-Jamendo-David_TMX.mp3 et on désire avoir le nom d'artiste avant le titre de la chanson tout en enlevant la publicité pour Jamendo. 
412 Mot inconnu : Knoklezout_au_taquet-Jamendo-David_TMX => Pour terminer nous allons voir un exemple pratique : nous avons de nombreux dossiers contenant de nombreux mp3 nommés selon le schéma Knoklezout_au_taquet-Jamendo-David_TMX.mp3 et on désire avoir le nom d'artiste avant le titre de la chanson tout en enlevant la publicité pour Jamendo. 
412 Mot inconnu : mp3 => Pour terminer nous allons voir un exemple pratique : nous avons de nombreux dossiers contenant de nombreux mp3 nommés selon le schéma Knoklezout_au_taquet-Jamendo-David_TMX.mp3 et on désire avoir le nom d'artiste avant le titre de la chanson tout en enlevant la publicité pour Jamendo. 
412 Mot inconnu : Jamendo => Pour terminer nous allons voir un exemple pratique : nous avons de nombreux dossiers contenant de nombreux mp3 nommés selon le schéma Knoklezout_au_taquet-Jamendo-David_TMX.mp3 et on désire avoir le nom d'artiste avant le titre de la chanson tout en enlevant la publicité pour Jamendo. 
412 Espace(s) en fin de ligne à supprimer. => Pour terminer nous allons voir un exemple pratique : nous avons de nombreux dossiers contenant de nombreux mp3 nommés selon le schéma Knoklezout_au_taquet-Jamendo-David_TMX.mp3 et on désire avoir le nom d'artiste avant le titre de la chanson tout en enlevant la publicité pour Jamendo. 

414 Mot inconnu : rename => Pour cela nous allons utiliser **rename** (qui vient avec perl) et nos chères expressions régulières :
414 Mot inconnu : perl => Pour cela nous allons utiliser **rename** (qui vient avec perl) et nos chères expressions régulières :
414 Il manque un espace insécable. => Pour cela nous allons utiliser **rename** (qui vient avec perl) et nos chères expressions régulières :

416 Mot inconnu : rename => <code>rename 's/^(.*)-Jamendo-(.*)\.mp3/$2_-_$1.mp3/' *.mp3</code>
416 Guillemets typographiques ouvrants. => <code>rename 's/^(.*)-Jamendo-(.*)\.mp3/$2_-_$1.mp3/' *.mp3</code>
416 Mot inconnu : Jamendo => <code>rename 's/^(.*)-Jamendo-(.*)\.mp3/$2_-_$1.mp3/' *.mp3</code>
416 Mot inconnu : mp3 => <code>rename 's/^(.*)-Jamendo-(.*)\.mp3/$2_-_$1.mp3/' *.mp3</code>
416 Mot inconnu : mp3 => <code>rename 's/^(.*)-Jamendo-(.*)\.mp3/$2_-_$1.mp3/' *.mp3</code>
416 Mot inconnu : mp3 => <code>rename 's/^(.*)-Jamendo-(.*)\.mp3/$2_-_$1.mp3/' *.mp3</code>

418 Mot inconnu : sed => Le principe est le même qu'avec sed sauf que les variables sont notées $n et non plus \n : on met ce qu'il y a avant "-Jamendo-" dans $1 et ce qu'il y a après (".mp3" non compris) dans $2 puis on formate comme on le veut.
418 Il manque un espace insécable. => Le principe est le même qu'avec sed sauf que les variables sont notées $n et non plus \n : on met ce qu'il y a avant "-Jamendo-" dans $1 et ce qu'il y a après (".mp3" non compris) dans $2 puis on formate comme on le veut.
418 Mot inconnu : Jamendo => Le principe est le même qu'avec sed sauf que les variables sont notées $n et non plus \n : on met ce qu'il y a avant "-Jamendo-" dans $1 et ce qu'il y a après (".mp3" non compris) dans $2 puis on formate comme on le veut.
418 Mot inconnu : mp3 => Le principe est le même qu'avec sed sauf que les variables sont notées $n et non plus \n : on met ce qu'il y a avant "-Jamendo-" dans $1 et ce qu'il y a après (".mp3" non compris) dans $2 puis on formate comme on le veut.
418 Guillemets typographiques fermants. => Le principe est le même qu'avec sed sauf que les variables sont notées $n et non plus \n : on met ce qu'il y a avant "-Jamendo-" dans $1 et ce qu'il y a après (".mp3" non compris) dans $2 puis on formate comme on le veut.

420 Mot inconnu : rename => **rename** renomme les fichiers dans le dossier courant, pour plus de sécurité on peut utiliser ** rename -n 's/'** qui nous affiche les changements sans les effectuer, puis les effectuer une fois que l'on est sûr.
420 Mot inconnu : rename => **rename** renomme les fichiers dans le dossier courant, pour plus de sécurité on peut utiliser ** rename -n 's/'** qui nous affiche les changements sans les effectuer, puis les effectuer une fois que l'on est sûr.
420 Il manque un espace à côté du tiret. => **rename** renomme les fichiers dans le dossier courant, pour plus de sécurité on peut utiliser ** rename -n 's/'** qui nous affiche les changements sans les effectuer, puis les effectuer une fois que l'on est sûr.
420 Guillemets typographiques ouvrants. => **rename** renomme les fichiers dans le dossier courant, pour plus de sécurité on peut utiliser ** rename -n 's/'** qui nous affiche les changements sans les effectuer, puis les effectuer une fois que l'on est sûr.

424 Mot inconnu : regexp => Une introduction à Perl et une introduction au regexp :
424 Il manque un espace insécable. => Une introduction à Perl et une introduction au regexp :

427 Mot inconnu : regexp => Le livre de référence (édition 1) de Ruby avec une petite partie sur les regexp

430 Mot inconnu : FSUG => Une introduction rapide réalisée dans notre FSUG (merci à Krunch) :
430 Mot inconnu : Krunch => Une introduction rapide réalisée dans notre FSUG (merci à Krunch) :
430 Il manque un espace insécable. => Une introduction rapide réalisée dans notre FSUG (merci à Krunch) :

433 Il manque un espace insécable. => Une approche plus théorique avec Python:

436 Mot inconnu : icons => {{icons:iconnote.png  }}
436 Il manque un espace. => {{icons:iconnote.png  }}
436 Mot inconnu : iconnote => {{icons:iconnote.png  }}
436 Mot inconnu : png => {{icons:iconnote.png  }}
436 Espace(s) surnuméraire(s) à supprimer. => {{icons:iconnote.png  }}

437 Pas d’espace avant une virgule. => >Les expressions régulières sont utilisés en Python, Perl , Ruby, PHP, Java, C, C++, par des programmes comme sed, awk, grep, vim, rename, ou encore des filtres dans apache et lighttpd ( mod_rewrite, vhosts ...), adblock dans firefox... Cette liste est bien sûr non exhaustive.    
437 Mot inconnu : sed => >Les expressions régulières sont utilisés en Python, Perl , Ruby, PHP, Java, C, C++, par des programmes comme sed, awk, grep, vim, rename, ou encore des filtres dans apache et lighttpd ( mod_rewrite, vhosts ...), adblock dans firefox... Cette liste est bien sûr non exhaustive.    
437 Mot inconnu : awk => >Les expressions régulières sont utilisés en Python, Perl , Ruby, PHP, Java, C, C++, par des programmes comme sed, awk, grep, vim, rename, ou encore des filtres dans apache et lighttpd ( mod_rewrite, vhosts ...), adblock dans firefox... Cette liste est bien sûr non exhaustive.    
437 Mot inconnu : grep => >Les expressions régulières sont utilisés en Python, Perl , Ruby, PHP, Java, C, C++, par des programmes comme sed, awk, grep, vim, rename, ou encore des filtres dans apache et lighttpd ( mod_rewrite, vhosts ...), adblock dans firefox... Cette liste est bien sûr non exhaustive.    
437 Mot inconnu : vim => >Les expressions régulières sont utilisés en Python, Perl , Ruby, PHP, Java, C, C++, par des programmes comme sed, awk, grep, vim, rename, ou encore des filtres dans apache et lighttpd ( mod_rewrite, vhosts ...), adblock dans firefox... Cette liste est bien sûr non exhaustive.    
437 Mot inconnu : rename => >Les expressions régulières sont utilisés en Python, Perl , Ruby, PHP, Java, C, C++, par des programmes comme sed, awk, grep, vim, rename, ou encore des filtres dans apache et lighttpd ( mod_rewrite, vhosts ...), adblock dans firefox... Cette liste est bien sûr non exhaustive.    
437 Mot inconnu : lighttpd => >Les expressions régulières sont utilisés en Python, Perl , Ruby, PHP, Java, C, C++, par des programmes comme sed, awk, grep, vim, rename, ou encore des filtres dans apache et lighttpd ( mod_rewrite, vhosts ...), adblock dans firefox... Cette liste est bien sûr non exhaustive.    
437 Pas d’espace après ce signe. => >Les expressions régulières sont utilisés en Python, Perl , Ruby, PHP, Java, C, C++, par des programmes comme sed, awk, grep, vim, rename, ou encore des filtres dans apache et lighttpd ( mod_rewrite, vhosts ...), adblock dans firefox... Cette liste est bien sûr non exhaustive.    
437 Mot inconnu : mod_rewrite => >Les expressions régulières sont utilisés en Python, Perl , Ruby, PHP, Java, C, C++, par des programmes comme sed, awk, grep, vim, rename, ou encore des filtres dans apache et lighttpd ( mod_rewrite, vhosts ...), adblock dans firefox... Cette liste est bien sûr non exhaustive.    
437 Mot inconnu : vhosts => >Les expressions régulières sont utilisés en Python, Perl , Ruby, PHP, Java, C, C++, par des programmes comme sed, awk, grep, vim, rename, ou encore des filtres dans apache et lighttpd ( mod_rewrite, vhosts ...), adblock dans firefox... Cette liste est bien sûr non exhaustive.    
437 Typographie : points de suspension. Utilisez le caractère dédié. => >Les expressions régulières sont utilisés en Python, Perl , Ruby, PHP, Java, C, C++, par des programmes comme sed, awk, grep, vim, rename, ou encore des filtres dans apache et lighttpd ( mod_rewrite, vhosts ...), adblock dans firefox... Cette liste est bien sûr non exhaustive.    
437 Mot inconnu : adblock => >Les expressions régulières sont utilisés en Python, Perl , Ruby, PHP, Java, C, C++, par des programmes comme sed, awk, grep, vim, rename, ou encore des filtres dans apache et lighttpd ( mod_rewrite, vhosts ...), adblock dans firefox... Cette liste est bien sûr non exhaustive.    
437 Mot inconnu : firefox => >Les expressions régulières sont utilisés en Python, Perl , Ruby, PHP, Java, C, C++, par des programmes comme sed, awk, grep, vim, rename, ou encore des filtres dans apache et lighttpd ( mod_rewrite, vhosts ...), adblock dans firefox... Cette liste est bien sûr non exhaustive.    
437 Typographie : points de suspension. Utilisez le caractère dédié. => >Les expressions régulières sont utilisés en Python, Perl , Ruby, PHP, Java, C, C++, par des programmes comme sed, awk, grep, vim, rename, ou encore des filtres dans apache et lighttpd ( mod_rewrite, vhosts ...), adblock dans firefox... Cette liste est bien sûr non exhaustive.    
437 Espace(s) en fin de ligne à supprimer. => >Les expressions régulières sont utilisés en Python, Perl , Ruby, PHP, Java, C, C++, par des programmes comme sed, awk, grep, vim, rename, ou encore des filtres dans apache et lighttpd ( mod_rewrite, vhosts ...), adblock dans firefox... Cette liste est bien sûr non exhaustive.    

441 Il manque un espace insécable. => Rédigé par : [[:utilisateurs:qazer|jeromeg]], ptitdav69 et Wazzaaabid
441 Il manque un espace. => Rédigé par : [[:utilisateurs:qazer|jeromeg]], ptitdav69 et Wazzaaabid
441 Mot inconnu : qazer => Rédigé par : [[:utilisateurs:qazer|jeromeg]], ptitdav69 et Wazzaaabid
441 Mot inconnu : jeromeg => Rédigé par : [[:utilisateurs:qazer|jeromeg]], ptitdav69 et Wazzaaabid
441 Mot inconnu : ptitdav69 => Rédigé par : [[:utilisateurs:qazer|jeromeg]], ptitdav69 et Wazzaaabid
441 Mot inconnu : Wazzaaabid => Rédigé par : [[:utilisateurs:qazer|jeromeg]], ptitdav69 et Wazzaaabid
